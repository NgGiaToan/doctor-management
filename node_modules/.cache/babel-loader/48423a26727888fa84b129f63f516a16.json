{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BooleanParameterPrefixes = void 0;\n\nconst BooleanParameterPrefixes = options => {\n  const prefixes = options.prefixes || ['is', 'has'];\n  const regexp = new RegExp(`^(${prefixes.join('|')})[A-Z-_]`);\n  const wrappedPrefixes = prefixes.map(p => `\\`${p}\\``);\n  const prefixesString = wrappedPrefixes.length === 1 ? wrappedPrefixes[0] : wrappedPrefixes.slice(0, -1).join(', ') + ' or ' + wrappedPrefixes[prefixes.length - 1];\n  return {\n    Parameter: {\n      Schema(schema, _ref, parents) {\n        let {\n          report,\n          parentLocations\n        } = _ref;\n\n        if (schema.type === 'boolean' && !regexp.test(parents.Parameter.name)) {\n          report({\n            message: `Boolean parameter \\`${parents.Parameter.name}\\` should have ${prefixesString} prefix.`,\n            location: parentLocations.Parameter.child(['name'])\n          });\n        }\n      }\n\n    }\n  };\n};\n\nexports.BooleanParameterPrefixes = BooleanParameterPrefixes;","map":{"version":3,"names":["Object","defineProperty","exports","value","BooleanParameterPrefixes","options","prefixes","regexp","RegExp","join","wrappedPrefixes","map","p","prefixesString","length","slice","Parameter","Schema","schema","parents","report","parentLocations","type","test","name","message","location","child"],"sources":["C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@redocly/openapi-core/lib/rules/oas3/boolean-parameter-prefixes.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BooleanParameterPrefixes = void 0;\nconst BooleanParameterPrefixes = (options) => {\n    const prefixes = options.prefixes || ['is', 'has'];\n    const regexp = new RegExp(`^(${prefixes.join('|')})[A-Z-_]`);\n    const wrappedPrefixes = prefixes.map((p) => `\\`${p}\\``);\n    const prefixesString = wrappedPrefixes.length === 1\n        ? wrappedPrefixes[0]\n        : wrappedPrefixes.slice(0, -1).join(', ') + ' or ' + wrappedPrefixes[prefixes.length - 1];\n    return {\n        Parameter: {\n            Schema(schema, { report, parentLocations }, parents) {\n                if (schema.type === 'boolean' && !regexp.test(parents.Parameter.name)) {\n                    report({\n                        message: `Boolean parameter \\`${parents.Parameter.name}\\` should have ${prefixesString} prefix.`,\n                        location: parentLocations.Parameter.child(['name']),\n                    });\n                }\n            },\n        },\n    };\n};\nexports.BooleanParameterPrefixes = BooleanParameterPrefixes;\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,wBAAR,GAAmC,KAAK,CAAxC;;AACA,MAAMA,wBAAwB,GAAIC,OAAD,IAAa;EAC1C,MAAMC,QAAQ,GAAGD,OAAO,CAACC,QAAR,IAAoB,CAAC,IAAD,EAAO,KAAP,CAArC;EACA,MAAMC,MAAM,GAAG,IAAIC,MAAJ,CAAY,KAAIF,QAAQ,CAACG,IAAT,CAAc,GAAd,CAAmB,UAAnC,CAAf;EACA,MAAMC,eAAe,GAAGJ,QAAQ,CAACK,GAAT,CAAcC,CAAD,IAAQ,KAAIA,CAAE,IAA3B,CAAxB;EACA,MAAMC,cAAc,GAAGH,eAAe,CAACI,MAAhB,KAA2B,CAA3B,GACjBJ,eAAe,CAAC,CAAD,CADE,GAEjBA,eAAe,CAACK,KAAhB,CAAsB,CAAtB,EAAyB,CAAC,CAA1B,EAA6BN,IAA7B,CAAkC,IAAlC,IAA0C,MAA1C,GAAmDC,eAAe,CAACJ,QAAQ,CAACQ,MAAT,GAAkB,CAAnB,CAFxE;EAGA,OAAO;IACHE,SAAS,EAAE;MACPC,MAAM,CAACC,MAAD,QAAsCC,OAAtC,EAA+C;QAAA,IAAtC;UAAEC,MAAF;UAAUC;QAAV,CAAsC;;QACjD,IAAIH,MAAM,CAACI,IAAP,KAAgB,SAAhB,IAA6B,CAACf,MAAM,CAACgB,IAAP,CAAYJ,OAAO,CAACH,SAAR,CAAkBQ,IAA9B,CAAlC,EAAuE;UACnEJ,MAAM,CAAC;YACHK,OAAO,EAAG,uBAAsBN,OAAO,CAACH,SAAR,CAAkBQ,IAAK,kBAAiBX,cAAe,UADpF;YAEHa,QAAQ,EAAEL,eAAe,CAACL,SAAhB,CAA0BW,KAA1B,CAAgC,CAAC,MAAD,CAAhC;UAFP,CAAD,CAAN;QAIH;MACJ;;IARM;EADR,CAAP;AAYH,CAnBD;;AAoBAzB,OAAO,CAACE,wBAAR,GAAmCA,wBAAnC"},"metadata":{},"sourceType":"script"}