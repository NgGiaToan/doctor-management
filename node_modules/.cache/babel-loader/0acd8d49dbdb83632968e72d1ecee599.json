{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\n\nconst util_1 = require(\"./util\");\n\nconst equal = require(\"fast-deep-equal\");\n\nconst traverse = require(\"json-schema-traverse\");\n\nconst URI = require(\"uri-js\"); // TODO refactor to use keyword definitions\n\n\nconst SIMPLE_INLINED = new Set([\"type\", \"format\", \"pattern\", \"maxLength\", \"minLength\", \"maxProperties\", \"minProperties\", \"maxItems\", \"minItems\", \"maximum\", \"minimum\", \"uniqueItems\", \"multipleOf\", \"required\", \"enum\", \"const\"]);\n\nfunction inlineRef(schema) {\n  let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (typeof schema == \"boolean\") return true;\n  if (limit === true) return !hasRef(schema);\n  if (!limit) return false;\n  return countKeys(schema) <= limit;\n}\n\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\"$ref\", \"$recursiveRef\", \"$recursiveAnchor\", \"$dynamicRef\", \"$dynamicAnchor\"]);\n\nfunction hasRef(schema) {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true;\n    const sch = schema[key];\n    if (Array.isArray(sch) && sch.some(hasRef)) return true;\n    if (typeof sch == \"object\" && hasRef(sch)) return true;\n  }\n\n  return false;\n}\n\nfunction countKeys(schema) {\n  let count = 0;\n\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity;\n    count++;\n    if (SIMPLE_INLINED.has(key)) continue;\n\n    if (typeof schema[key] == \"object\") {\n      util_1.eachItem(schema[key], sch => count += countKeys(sch));\n    }\n\n    if (count === Infinity) return Infinity;\n  }\n\n  return count;\n}\n\nfunction getFullPath() {\n  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  let normalize = arguments.length > 1 ? arguments[1] : undefined;\n  if (normalize !== false) id = normalizeId(id);\n  const p = URI.parse(id);\n  return _getFullPath(p);\n}\n\nexports.getFullPath = getFullPath;\n\nfunction _getFullPath(p) {\n  return URI.serialize(p).split(\"#\")[0] + \"#\";\n}\n\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\n\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\n\nexports.normalizeId = normalizeId;\n\nfunction resolveUrl(baseId, id) {\n  id = normalizeId(id);\n  return URI.resolve(baseId, id);\n}\n\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\n\nfunction getSchemaRefs(schema) {\n  if (typeof schema == \"boolean\") return {};\n  const {\n    schemaId\n  } = this.opts;\n  const schId = normalizeId(schema[schemaId]);\n  const baseIds = {\n    \"\": schId\n  };\n  const pathPrefix = getFullPath(schId, false);\n  const localRefs = {};\n  const schemaRefs = new Set();\n  traverse(schema, {\n    allKeys: true\n  }, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return;\n    const fullPath = pathPrefix + jsonPtr;\n    let baseId = baseIds[parentJsonPtr];\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId]);\n    addAnchor.call(this, sch.$anchor);\n    addAnchor.call(this, sch.$dynamicAnchor);\n    baseIds[jsonPtr] = baseId;\n\n    function addRef(ref) {\n      ref = normalizeId(baseId ? URI.resolve(baseId, ref) : ref);\n      if (schemaRefs.has(ref)) throw ambiguos(ref);\n      schemaRefs.add(ref);\n      let schOrRef = this.refs[ref];\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef];\n\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref);\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref);\n          localRefs[ref] = sch;\n        } else {\n          this.refs[ref] = fullPath;\n        }\n      }\n\n      return ref;\n    }\n\n    function addAnchor(anchor) {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`);\n        addRef.call(this, `#${anchor}`);\n      }\n    }\n  });\n  return localRefs;\n\n  function checkAmbiguosRef(sch1, sch2, ref) {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref);\n  }\n\n  function ambiguos(ref) {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`);\n  }\n}\n\nexports.getSchemaRefs = getSchemaRefs;","map":{"version":3,"mappings":"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","names":["SIMPLE_INLINED","Set","inlineRef","schema","limit","hasRef","countKeys","exports","REF_KEYWORDS","key","has","sch","Array","isArray","some","count","Infinity","util_1","getFullPath","id","normalize","normalizeId","p","URI","parse","_getFullPath","serialize","split","TRAILING_SLASH_HASH","replace","resolveUrl","baseId","resolve","ANCHOR","getSchemaRefs","schemaId","opts","schId","baseIds","pathPrefix","localRefs","schemaRefs","traverse","allKeys","jsonPtr","_","parentJsonPtr","undefined","fullPath","addRef","call","addAnchor","$anchor","$dynamicAnchor","ref","ambiguos","add","schOrRef","refs","checkAmbiguosRef","anchor","test","Error","sch1","sch2","equal"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\compile\\resolve.ts"],"sourcesContent":["import type {AnySchema, AnySchemaObject} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\nimport * as URI from \"uri-js\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = URI.parse(id)\n  return _getFullPath(p)\n}\n\nexport function _getFullPath(p: URI.URIComponents): string {\n  return URI.serialize(p).split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(baseId: string, id: string): string {\n  id = normalizeId(id)\n  return URI.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId} = this.opts\n  const schId = normalizeId(schema[schemaId])\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let baseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = baseId\n\n    function addRef(this: Ajv, ref: string): string {\n      ref = normalizeId(baseId ? URI.resolve(baseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}