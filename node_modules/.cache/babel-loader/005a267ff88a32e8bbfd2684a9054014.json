{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNamedType = exports.normalizeTypes = exports.mapOf = exports.listOf = void 0;\n\nfunction listOf(typeName) {\n  return {\n    name: \"\".concat(typeName, \"List\"),\n    properties: {},\n    items: typeName\n  };\n}\n\nexports.listOf = listOf;\n\nfunction mapOf(typeName) {\n  return {\n    name: \"\".concat(typeName, \"Map\"),\n    properties: {},\n    additionalProperties: function additionalProperties() {\n      return typeName;\n    }\n  };\n}\n\nexports.mapOf = mapOf;\n\nfunction normalizeTypes(types) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var normalizedTypes = {};\n\n  for (var _i = 0, _Object$keys = Object.keys(types); _i < _Object$keys.length; _i++) {\n    var typeName = _Object$keys[_i];\n    normalizedTypes[typeName] = Object.assign(Object.assign({}, types[typeName]), {\n      name: typeName\n    });\n  }\n\n  for (var _i2 = 0, _Object$values = Object.values(normalizedTypes); _i2 < _Object$values.length; _i2++) {\n    var type = _Object$values[_i2];\n    normalizeType(type);\n  }\n\n  return normalizedTypes;\n\n  function normalizeType(type) {\n    if (type.additionalProperties) {\n      type.additionalProperties = resolveType(type.additionalProperties);\n    }\n\n    if (type.items) {\n      type.items = resolveType(type.items);\n    }\n\n    if (type.properties) {\n      var mappedProps = {};\n\n      for (var _i3 = 0, _Object$entries = Object.entries(type.properties); _i3 < _Object$entries.length; _i3++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2),\n            propName = _Object$entries$_i[0],\n            prop = _Object$entries$_i[1];\n\n        mappedProps[propName] = resolveType(prop);\n\n        if (options.doNotResolveExamples && prop && prop.isExample) {\n          mappedProps[propName] = Object.assign(Object.assign({}, prop), {\n            resolvable: false\n          });\n        }\n      }\n\n      type.properties = mappedProps;\n    }\n  } // typings are painful here...\n\n\n  function resolveType(type) {\n    if (typeof type === 'string') {\n      if (!normalizedTypes[type]) {\n        throw new Error(\"Unknown type name found: \".concat(type));\n      }\n\n      return normalizedTypes[type];\n    } else if (typeof type === 'function') {\n      return function (value, key) {\n        return resolveType(type(value, key));\n      };\n    } else if (type && type.name) {\n      type = Object.assign({}, type);\n      normalizeType(type);\n      return type;\n    } else if (type && type.directResolveAs) {\n      return Object.assign(Object.assign({}, type), {\n        directResolveAs: resolveType(type.directResolveAs)\n      });\n    } else {\n      return type;\n    }\n  }\n}\n\nexports.normalizeTypes = normalizeTypes;\n\nfunction isNamedType(t) {\n  return typeof (t === null || t === void 0 ? void 0 : t.name) === 'string';\n}\n\nexports.isNamedType = isNamedType;","map":null,"metadata":{},"sourceType":"script"}