{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeVisitors = void 0;\n\nfunction normalizeVisitors(visitorsConfig, types) {\n  const normalizedVisitors = {};\n  normalizedVisitors.any = {\n    enter: [],\n    leave: []\n  };\n\n  for (const typeName of Object.keys(types)) {\n    normalizedVisitors[typeName] = {\n      enter: [],\n      leave: []\n    };\n  }\n\n  normalizedVisitors.ref = {\n    enter: [],\n    leave: []\n  };\n\n  for (const {\n    ruleId,\n    severity,\n    visitor\n  } of visitorsConfig) {\n    normalizeVisitorLevel({\n      ruleId,\n      severity\n    }, visitor, null);\n  }\n\n  for (const v of Object.keys(normalizedVisitors)) {\n    normalizedVisitors[v].enter.sort((a, b) => b.depth - a.depth);\n    normalizedVisitors[v].leave.sort((a, b) => a.depth - b.depth);\n  }\n\n  return normalizedVisitors;\n\n  function addWeakNodes(ruleConf, from, to, parentContext) {\n    let stack = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    if (stack.includes(from)) return;\n    stack = [...stack, from];\n    const possibleChildren = new Set();\n\n    for (let type of Object.values(from.properties)) {\n      if (type === to) {\n        addWeakFromStack(ruleConf, stack);\n        continue;\n      }\n\n      if (typeof type === 'object' && type !== null && type.name) {\n        possibleChildren.add(type);\n      }\n    }\n\n    if (from.additionalProperties && typeof from.additionalProperties !== 'function') {\n      if (from.additionalProperties === to) {\n        addWeakFromStack(ruleConf, stack);\n      } else if (from.additionalProperties.name !== undefined) {\n        possibleChildren.add(from.additionalProperties);\n      }\n    }\n\n    if (from.items) {\n      if (from.items === to) {\n        addWeakFromStack(ruleConf, stack);\n      } else if (from.items.name !== undefined) {\n        possibleChildren.add(from.items);\n      }\n    }\n\n    for (let fromType of Array.from(possibleChildren.values())) {\n      addWeakNodes(ruleConf, fromType, to, parentContext, stack);\n    }\n\n    function addWeakFromStack(ruleConf, stack) {\n      for (const interType of stack.slice(1)) {\n        normalizedVisitors[interType.name] = normalizedVisitors[interType.name] || {\n          enter: [],\n          leave: []\n        };\n        normalizedVisitors[interType.name].enter.push(Object.assign(Object.assign({}, ruleConf), {\n          visit: () => undefined,\n          depth: 0,\n          context: {\n            isSkippedLevel: true,\n            seen: new Set(),\n            parent: parentContext\n          }\n        }));\n      }\n    }\n  }\n\n  function normalizeVisitorLevel(ruleConf, visitor, parentContext) {\n    let depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const visitorKeys = Object.keys(types);\n\n    if (depth === 0) {\n      visitorKeys.push('any');\n      visitorKeys.push('ref');\n    } else {\n      if (visitor.any) {\n        throw new Error('any() is allowed only on top level');\n      }\n\n      if (visitor.ref) {\n        throw new Error('ref() is allowed only on top level');\n      }\n    }\n\n    for (const typeName of visitorKeys) {\n      const typeVisitor = visitor[typeName];\n      const normalizedTypeVisitor = normalizedVisitors[typeName];\n      if (!typeVisitor) continue;\n      let visitorEnter;\n      let visitorLeave;\n      let visitorSkip;\n      const isObjectVisitor = typeof typeVisitor === 'object';\n\n      if (typeName === 'ref' && isObjectVisitor && typeVisitor.skip) {\n        throw new Error('ref() visitor does not support skip');\n      }\n\n      if (typeof typeVisitor === 'function') {\n        visitorEnter = typeVisitor;\n      } else if (isObjectVisitor) {\n        visitorEnter = typeVisitor.enter;\n        visitorLeave = typeVisitor.leave;\n        visitorSkip = typeVisitor.skip;\n      }\n\n      const context = {\n        activatedOn: null,\n        type: types[typeName],\n        parent: parentContext,\n        isSkippedLevel: false\n      };\n\n      if (typeof typeVisitor === 'object') {\n        normalizeVisitorLevel(ruleConf, typeVisitor, context, depth + 1);\n      }\n\n      if (parentContext) {\n        addWeakNodes(ruleConf, parentContext.type, types[typeName], parentContext);\n      }\n\n      if (visitorEnter || isObjectVisitor) {\n        if (visitorEnter && typeof visitorEnter !== 'function') {\n          throw new Error('DEV: should be function');\n        }\n\n        normalizedTypeVisitor.enter.push(Object.assign(Object.assign({}, ruleConf), {\n          visit: visitorEnter || (() => undefined),\n          skip: visitorSkip,\n          depth,\n          context\n        }));\n      }\n\n      if (visitorLeave) {\n        if (typeof visitorLeave !== 'function') {\n          throw new Error('DEV: should be function');\n        }\n\n        normalizedTypeVisitor.leave.push(Object.assign(Object.assign({}, ruleConf), {\n          visit: visitorLeave,\n          depth,\n          context\n        }));\n      }\n    }\n  }\n}\n\nexports.normalizeVisitors = normalizeVisitors;","map":{"version":3,"names":["Object","defineProperty","exports","value","normalizeVisitors","visitorsConfig","types","normalizedVisitors","any","enter","leave","typeName","keys","ref","ruleId","severity","visitor","normalizeVisitorLevel","v","sort","a","b","depth","addWeakNodes","ruleConf","from","to","parentContext","stack","includes","possibleChildren","Set","type","values","properties","addWeakFromStack","name","add","additionalProperties","undefined","items","fromType","Array","interType","slice","push","assign","visit","context","isSkippedLevel","seen","parent","visitorKeys","Error","typeVisitor","normalizedTypeVisitor","visitorEnter","visitorLeave","visitorSkip","isObjectVisitor","skip","activatedOn"],"sources":["C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@redocly/openapi-core/lib/visitors.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.normalizeVisitors = void 0;\nfunction normalizeVisitors(visitorsConfig, types) {\n    const normalizedVisitors = {};\n    normalizedVisitors.any = {\n        enter: [],\n        leave: [],\n    };\n    for (const typeName of Object.keys(types)) {\n        normalizedVisitors[typeName] = {\n            enter: [],\n            leave: [],\n        };\n    }\n    normalizedVisitors.ref = {\n        enter: [],\n        leave: [],\n    };\n    for (const { ruleId, severity, visitor } of visitorsConfig) {\n        normalizeVisitorLevel({ ruleId, severity }, visitor, null);\n    }\n    for (const v of Object.keys(normalizedVisitors)) {\n        normalizedVisitors[v].enter.sort((a, b) => b.depth - a.depth);\n        normalizedVisitors[v].leave.sort((a, b) => a.depth - b.depth);\n    }\n    return normalizedVisitors;\n    function addWeakNodes(ruleConf, from, to, parentContext, stack = []) {\n        if (stack.includes(from))\n            return;\n        stack = [...stack, from];\n        const possibleChildren = new Set();\n        for (let type of Object.values(from.properties)) {\n            if (type === to) {\n                addWeakFromStack(ruleConf, stack);\n                continue;\n            }\n            if (typeof type === 'object' && type !== null && type.name) {\n                possibleChildren.add(type);\n            }\n        }\n        if (from.additionalProperties && typeof from.additionalProperties !== 'function') {\n            if (from.additionalProperties === to) {\n                addWeakFromStack(ruleConf, stack);\n            }\n            else if (from.additionalProperties.name !== undefined) {\n                possibleChildren.add(from.additionalProperties);\n            }\n        }\n        if (from.items) {\n            if (from.items === to) {\n                addWeakFromStack(ruleConf, stack);\n            }\n            else if (from.items.name !== undefined) {\n                possibleChildren.add(from.items);\n            }\n        }\n        for (let fromType of Array.from(possibleChildren.values())) {\n            addWeakNodes(ruleConf, fromType, to, parentContext, stack);\n        }\n        function addWeakFromStack(ruleConf, stack) {\n            for (const interType of stack.slice(1)) {\n                normalizedVisitors[interType.name] =\n                    normalizedVisitors[interType.name] ||\n                        {\n                            enter: [],\n                            leave: [],\n                        };\n                normalizedVisitors[interType.name].enter.push(Object.assign(Object.assign({}, ruleConf), { visit: () => undefined, depth: 0, context: {\n                        isSkippedLevel: true,\n                        seen: new Set(),\n                        parent: parentContext,\n                    } }));\n            }\n        }\n    }\n    function normalizeVisitorLevel(ruleConf, visitor, parentContext, depth = 0) {\n        const visitorKeys = Object.keys(types);\n        if (depth === 0) {\n            visitorKeys.push('any');\n            visitorKeys.push('ref');\n        }\n        else {\n            if (visitor.any) {\n                throw new Error('any() is allowed only on top level');\n            }\n            if (visitor.ref) {\n                throw new Error('ref() is allowed only on top level');\n            }\n        }\n        for (const typeName of visitorKeys) {\n            const typeVisitor = visitor[typeName];\n            const normalizedTypeVisitor = normalizedVisitors[typeName];\n            if (!typeVisitor)\n                continue;\n            let visitorEnter;\n            let visitorLeave;\n            let visitorSkip;\n            const isObjectVisitor = typeof typeVisitor === 'object';\n            if (typeName === 'ref' && isObjectVisitor && typeVisitor.skip) {\n                throw new Error('ref() visitor does not support skip');\n            }\n            if (typeof typeVisitor === 'function') {\n                visitorEnter = typeVisitor;\n            }\n            else if (isObjectVisitor) {\n                visitorEnter = typeVisitor.enter;\n                visitorLeave = typeVisitor.leave;\n                visitorSkip = typeVisitor.skip;\n            }\n            const context = {\n                activatedOn: null,\n                type: types[typeName],\n                parent: parentContext,\n                isSkippedLevel: false,\n            };\n            if (typeof typeVisitor === 'object') {\n                normalizeVisitorLevel(ruleConf, typeVisitor, context, depth + 1);\n            }\n            if (parentContext) {\n                addWeakNodes(ruleConf, parentContext.type, types[typeName], parentContext);\n            }\n            if (visitorEnter || isObjectVisitor) {\n                if (visitorEnter && typeof visitorEnter !== 'function') {\n                    throw new Error('DEV: should be function');\n                }\n                normalizedTypeVisitor.enter.push(Object.assign(Object.assign({}, ruleConf), { visit: visitorEnter || (() => undefined), skip: visitorSkip, depth,\n                    context }));\n            }\n            if (visitorLeave) {\n                if (typeof visitorLeave !== 'function') {\n                    throw new Error('DEV: should be function');\n                }\n                normalizedTypeVisitor.leave.push(Object.assign(Object.assign({}, ruleConf), { visit: visitorLeave, depth,\n                    context }));\n            }\n        }\n    }\n}\nexports.normalizeVisitors = normalizeVisitors;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}