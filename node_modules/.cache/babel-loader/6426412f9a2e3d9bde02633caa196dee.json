{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\n\nconst codegen_1 = require(\"../compile/codegen\");\n\nconst util_1 = require(\"../compile/util\");\n\nconst names_1 = require(\"../compile/names\");\n\nfunction checkReportMissingProp(cxt, prop) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({\n      missingProperty: codegen_1._`${prop}`\n    }, true);\n    cxt.error();\n  });\n}\n\nexports.checkReportMissingProp = checkReportMissingProp;\n\nfunction checkMissingProp(_ref, properties, missing) {\n  let {\n    gen,\n    data,\n    it: {\n      opts\n    }\n  } = _ref;\n  return codegen_1.or(...properties.map(prop => codegen_1.and(noPropertyInData(gen, data, prop, opts.ownProperties), codegen_1._`${missing} = ${prop}`)));\n}\n\nexports.checkMissingProp = checkMissingProp;\n\nfunction reportMissingProp(cxt, missing) {\n  cxt.setParams({\n    missingProperty: missing\n  }, true);\n  cxt.error();\n}\n\nexports.reportMissingProp = reportMissingProp;\n\nfunction hasPropFunc(gen) {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: codegen_1._`Object.prototype.hasOwnProperty`\n  });\n}\n\nexports.hasPropFunc = hasPropFunc;\n\nfunction isOwnProperty(gen, data, property) {\n  return codegen_1._`${hasPropFunc(gen)}.call(${data}, ${property})`;\n}\n\nexports.isOwnProperty = isOwnProperty;\n\nfunction propertyInData(gen, data, property, ownProperties) {\n  const cond = codegen_1._`${data}${codegen_1.getProperty(property)} !== undefined`;\n  return ownProperties ? codegen_1._`${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n}\n\nexports.propertyInData = propertyInData;\n\nfunction noPropertyInData(gen, data, property, ownProperties) {\n  const cond = codegen_1._`${data}${codegen_1.getProperty(property)} === undefined`;\n  return ownProperties ? codegen_1.or(cond, codegen_1.not(isOwnProperty(gen, data, property))) : cond;\n}\n\nexports.noPropertyInData = noPropertyInData;\n\nfunction allSchemaProperties(schemaMap) {\n  return schemaMap ? Object.keys(schemaMap).filter(p => p !== \"__proto__\") : [];\n}\n\nexports.allSchemaProperties = allSchemaProperties;\n\nfunction schemaProperties(it, schemaMap) {\n  return allSchemaProperties(schemaMap).filter(p => !util_1.alwaysValidSchema(it, schemaMap[p]));\n}\n\nexports.schemaProperties = schemaProperties;\n\nfunction callValidateCode(_ref2, func, context, passSchema) {\n  let {\n    schemaCode,\n    data,\n    it: {\n      gen,\n      topSchemaRef,\n      schemaPath,\n      errorPath\n    },\n    it\n  } = _ref2;\n  const dataAndSchema = passSchema ? codegen_1._`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n  const valCxt = [[names_1.default.instancePath, codegen_1.strConcat(names_1.default.instancePath, errorPath)], [names_1.default.parentData, it.parentData], [names_1.default.parentDataProperty, it.parentDataProperty], [names_1.default.rootData, names_1.default.rootData]];\n  if (it.opts.dynamicRef) valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n  const args = codegen_1._`${dataAndSchema}, ${gen.object(...valCxt)}`;\n  return context !== codegen_1.nil ? codegen_1._`${func}.call(${context}, ${args})` : codegen_1._`${func}(${args})`;\n}\n\nexports.callValidateCode = callValidateCode;\n\nfunction usePattern(_ref3, pattern) {\n  let {\n    gen,\n    it: {\n      opts\n    }\n  } = _ref3;\n  const u = opts.unicodeRegExp ? \"u\" : \"\";\n  return gen.scopeValue(\"pattern\", {\n    key: pattern,\n    ref: new RegExp(pattern, u),\n    code: codegen_1._`new RegExp(${pattern}, ${u})`\n  });\n}\n\nexports.usePattern = usePattern;\n\nfunction validateArray(cxt) {\n  const {\n    gen,\n    data,\n    keyword,\n    it\n  } = cxt;\n  const valid = gen.name(\"valid\");\n\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true);\n    validateItems(() => gen.assign(validArr, false));\n    return validArr;\n  }\n\n  gen.var(valid, true);\n  validateItems(() => gen.break());\n  return valid;\n\n  function validateItems(notValid) {\n    const len = gen.const(\"len\", codegen_1._`${data}.length`);\n    gen.forRange(\"i\", 0, len, i => {\n      cxt.subschema({\n        keyword,\n        dataProp: i,\n        dataPropType: util_1.Type.Num\n      }, valid);\n      gen.if(codegen_1.not(valid), notValid);\n    });\n  }\n}\n\nexports.validateArray = validateArray;\n\nfunction validateUnion(cxt) {\n  const {\n    gen,\n    schema,\n    keyword,\n    it\n  } = cxt;\n  /* istanbul ignore if */\n\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n  const alwaysValid = schema.some(sch => util_1.alwaysValidSchema(it, sch));\n  if (alwaysValid && !it.opts.unevaluated) return;\n  const valid = gen.let(\"valid\", false);\n  const schValid = gen.name(\"_valid\");\n  gen.block(() => schema.forEach((_sch, i) => {\n    const schCxt = cxt.subschema({\n      keyword,\n      schemaProp: i,\n      compositeRule: true\n    }, schValid);\n    gen.assign(valid, codegen_1._`${valid} || ${schValid}`);\n    const merged = cxt.mergeValidEvaluated(schCxt, schValid); // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n    // or if all properties and items were evaluated (it.props === true && it.items === true)\n\n    if (!merged) gen.if(codegen_1.not(valid));\n  }));\n  cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\n\nexports.validateUnion = validateUnion;","map":{"version":3,"mappings":"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","names":["checkReportMissingProp","cxt","prop","gen","data","it","if","noPropertyInData","opts","ownProperties","setParams","missingProperty","codegen_1","error","exports","checkMissingProp","properties","missing","map","reportMissingProp","hasPropFunc","scopeValue","ref","Object","prototype","hasOwnProperty","code","isOwnProperty","property","propertyInData","cond","allSchemaProperties","schemaMap","keys","filter","p","schemaProperties","util_1","callValidateCode","func","context","passSchema","schemaCode","topSchemaRef","schemaPath","errorPath","dataAndSchema","valCxt","names_1","instancePath","parentData","parentDataProperty","rootData","dynamicRef","push","dynamicAnchors","args","object","usePattern","pattern","u","unicodeRegExp","key","RegExp","validateArray","keyword","valid","name","allErrors","validArr","let","validateItems","assign","var","break","notValid","len","const","forRange","i","subschema","dataProp","dataPropType","Num","validateUnion","schema","Array","isArray","Error","alwaysValid","some","sch","unevaluated","schValid","block","forEach","_sch","schCxt","schemaProp","compositeRule","merged","mergeValidEvaluated","result","reset"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\vocabularies\\code.ts"],"sourcesContent":["import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\n\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  return gen.scopeValue(\"pattern\", {\n    key: pattern,\n    ref: new RegExp(pattern, u),\n    code: _`new RegExp(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n"]},"metadata":{},"sourceType":"script"}