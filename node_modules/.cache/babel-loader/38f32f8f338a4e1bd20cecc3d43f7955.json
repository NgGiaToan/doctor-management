{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _defineProperty = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isOrdered = exports.getIntersectionLength = exports.buildSubjectVisitor = exports.buildVisitorObject = void 0;\n\nvar ref_utils_1 = require(\"../../../ref-utils\");\n\nvar asserts_1 = require(\"./asserts\");\n\nfunction buildVisitorObject(subject, context, subjectVisitor) {\n  if (!context) {\n    return _defineProperty({}, subject, subjectVisitor);\n  }\n\n  var currentVisitorLevel = {};\n  var visitor = currentVisitorLevel;\n\n  var _loop = function _loop(index) {\n    var node = context[index];\n\n    if (context.length === index + 1 && node.type === subject) {\n      // Visitors don't work properly for the same type nested nodes, so\n      // as a workaround for that we don't create separate visitor for the last element\n      // which is the same as subject;\n      // we will check includes/excludes it in the last visitor.\n      return \"continue\";\n    }\n\n    var matchParentKeys = node.matchParentKeys;\n    var excludeParentKeys = node.excludeParentKeys;\n\n    if (matchParentKeys && excludeParentKeys) {\n      throw new Error(\"Both 'matchParentKeys' and 'excludeParentKeys' can't be under one context item\");\n    }\n\n    if (matchParentKeys || excludeParentKeys) {\n      currentVisitorLevel[node.type] = {\n        skip: function skip(_value, key) {\n          if (matchParentKeys) {\n            return !matchParentKeys.includes(key);\n          }\n\n          if (excludeParentKeys) {\n            return excludeParentKeys.includes(key);\n          }\n        }\n      };\n    } else {\n      currentVisitorLevel[node.type] = {};\n    }\n\n    currentVisitorLevel = currentVisitorLevel[node.type];\n  };\n\n  for (var index = 0; index < context.length; index++) {\n    var _ret = _loop(index);\n\n    if (_ret === \"continue\") continue;\n  }\n\n  currentVisitorLevel[subject] = subjectVisitor;\n  return visitor;\n}\n\nexports.buildVisitorObject = buildVisitorObject;\n\nfunction buildSubjectVisitor(properties, asserts, context) {\n  return function (node, _ref2) {\n    var report = _ref2.report,\n        location = _ref2.location,\n        key = _ref2.key,\n        type = _ref2.type,\n        resolve = _ref2.resolve;\n\n    var _a; // We need to check context's last node if it has the same type as subject node;\n    // if yes - that means we didn't create context's last node visitor,\n    // so we need to handle 'matchParentKeys' and 'excludeParentKeys' conditions here;\n\n\n    if (context) {\n      var lastContextNode = context[context.length - 1];\n\n      if (lastContextNode.type === type.name) {\n        var matchParentKeys = lastContextNode.matchParentKeys;\n        var excludeParentKeys = lastContextNode.excludeParentKeys;\n\n        if (matchParentKeys && !matchParentKeys.includes(key)) {\n          return;\n        }\n\n        if (excludeParentKeys && excludeParentKeys.includes(key)) {\n          return;\n        }\n      }\n    }\n\n    if (properties) {\n      properties = Array.isArray(properties) ? properties : [properties];\n    }\n\n    var _iterator = _createForOfIteratorHelper(asserts),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var assert = _step.value;\n\n        if (properties) {\n          var _iterator2 = _createForOfIteratorHelper(properties),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var property = _step2.value;\n              // we can have resolvable scalar so need to resolve value here.\n              var value = ref_utils_1.isRef(node[property]) ? (_a = resolve(node[property])) === null || _a === void 0 ? void 0 : _a.node : node[property];\n              runAssertion(value, assert, location.child(property), report);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        } else {\n          runAssertion(Object.keys(node), assert, location.key(), report);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  };\n}\n\nexports.buildSubjectVisitor = buildSubjectVisitor;\n\nfunction getIntersectionLength(keys, properties) {\n  var props = new Set(properties);\n  var count = 0;\n\n  var _iterator3 = _createForOfIteratorHelper(keys),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var key = _step3.value;\n\n      if (props.has(key)) {\n        count++;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return count;\n}\n\nexports.getIntersectionLength = getIntersectionLength;\n\nfunction isOrdered(value, options) {\n  var direction = options.direction || options;\n  var property = options.property;\n\n  for (var i = 1; i < value.length; i++) {\n    var currValue = value[i];\n    var prevVal = value[i - 1];\n\n    if (property) {\n      if (!value[i][property] || !value[i - 1][property]) {\n        return false; // property doesn't exist, so collection is not ordered\n      }\n\n      currValue = value[i][property];\n      prevVal = value[i - 1][property];\n    }\n\n    var result = direction === 'asc' ? currValue >= prevVal : currValue <= prevVal;\n\n    if (!result) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isOrdered = isOrdered;\n\nfunction runAssertion(values, assert, location, report) {\n  var lintResult = asserts_1.asserts[assert.name](values, assert.conditions);\n\n  if (!lintResult) {\n    report({\n      message: assert.message || \"The \".concat(assert.assertId, \" doesn't meet required conditions\"),\n      location: location,\n      forceSeverity: assert.severity,\n      suggest: assert.suggest,\n      ruleId: assert.assertId\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"script"}