{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst error = {\n  message: _ref => {\n    let {\n      schemaCode\n    } = _ref;\n    return codegen_1.str`must match format \"${schemaCode}\"`;\n  },\n  params: _ref2 => {\n    let {\n      schemaCode\n    } = _ref2;\n    return codegen_1._`{format: ${schemaCode}}`;\n  }\n};\nconst def = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n\n  code(cxt, ruleType) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    const {\n      opts,\n      errSchemaPath,\n      schemaEnv,\n      self\n    } = it;\n    if (!opts.validateFormats) return;\n    if ($data) validate$DataFormat();else validateFormat();\n\n    function validate$DataFormat() {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      const fDef = gen.const(\"fDef\", codegen_1._`${fmts}[${schemaCode}]`);\n      const fType = gen.let(\"fType\");\n      const format = gen.let(\"format\"); // TODO simplify\n\n      gen.if(codegen_1._`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, codegen_1._`${fDef}.type || \"string\"`).assign(format, codegen_1._`${fDef}.validate`), () => gen.assign(fType, codegen_1._`\"string\"`).assign(format, fDef));\n      cxt.fail$data(codegen_1.or(unknownFmt(), invalidFmt()));\n\n      function unknownFmt() {\n        if (opts.strictSchema === false) return codegen_1.nil;\n        return codegen_1._`${schemaCode} && !${format}`;\n      }\n\n      function invalidFmt() {\n        const callFormat = schemaEnv.$async ? codegen_1._`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : codegen_1._`${format}(${data})`;\n        const validData = codegen_1._`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n        return codegen_1._`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n      }\n    }\n\n    function validateFormat() {\n      const formatDef = self.formats[schema];\n\n      if (!formatDef) {\n        unknownFormat();\n        return;\n      }\n\n      if (formatDef === true) return;\n      const [fmtType, format, fmtRef] = getFormat(formatDef);\n      if (fmtType === ruleType) cxt.pass(validCondition());\n\n      function unknownFormat() {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg());\n          return;\n        }\n\n        throw new Error(unknownMsg());\n\n        function unknownMsg() {\n          return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n        }\n      }\n\n      function getFormat(fmtDef) {\n        const code = fmtDef instanceof RegExp ? codegen_1.regexpCode(fmtDef) : opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(schema)}` : undefined;\n        const fmt = gen.scopeValue(\"formats\", {\n          key: schema,\n          ref: fmtDef,\n          code\n        });\n\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, codegen_1._`${fmt}.validate`];\n        }\n\n        return [\"string\", fmtDef, fmt];\n      }\n\n      function validCondition() {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\");\n          return codegen_1._`await ${fmtRef}(${data})`;\n        }\n\n        return typeof format == \"function\" ? codegen_1._`${fmtRef}(${data})` : codegen_1._`${fmtRef}.test(${data})`;\n      }\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","schemaCode","codegen_1","params","def","keyword","type","schemaType","$data","code","cxt","ruleType","gen","data","schema","it","opts","errSchemaPath","schemaEnv","self","validateFormats","validate$DataFormat","validateFormat","fmts","scopeValue","ref","formats","fDef","const","fType","let","format","if","assign","fail$data","unknownFmt","invalidFmt","strictSchema","callFormat","$async","validData","formatDef","unknownFormat","fmtType","fmtRef","getFormat","pass","validCondition","logger","warn","unknownMsg","Error","fmtDef","RegExp","undefined","fmt","key","validate","async","exports"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\vocabularies\\format\\format.ts"],"sourcesContent":["import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}