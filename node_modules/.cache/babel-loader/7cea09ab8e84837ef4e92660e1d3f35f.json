{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useRef } from 'react';\n/**\r\n * https://usehooks.com/useEventListener/\r\n */\n\nfunction useEventListener(eventName, handler) {\n  _s();\n\n  let element = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;\n  // Create a ref that stores handler\n  const savedHandler = useRef(); // Update ref.current value if handler changes.\n  // This allows our effect below to always get latest handler ...\n  // ... without us needing to pass it in effect deps array ...\n  // ... and potentially cause effect to re-run every render.\n\n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n  useEffect(() => {\n    // Make sure element supports addEventListener\n    // On\n    const isSupported = element && element.addEventListener;\n\n    if (!isSupported) {\n      return false;\n    } // Create event listener that calls handler function stored in ref\n\n\n    const eventListener = event => savedHandler.current(event); // Add event listener\n\n\n    element.addEventListener(eventName, eventListener); // Remove event listener on cleanup\n\n    return () => {\n      element.removeEventListener(eventName, eventListener);\n    };\n  }, [eventName, element] // Re-run if eventName or element changes\n  );\n}\n\n_s(useEventListener, \"XoZIjRFu3rOkeAcYGIxrbqMN+XY=\");\n\nexport default useEventListener;","map":{"version":3,"names":["useEffect","useRef","useEventListener","eventName","handler","element","window","savedHandler","current","isSupported","addEventListener","eventListener","event","removeEventListener"],"sources":["C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/src/@fuse/hooks/useEventListener.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\r\n\r\n/**\r\n * https://usehooks.com/useEventListener/\r\n */\r\nfunction useEventListener(eventName, handler, element = window) {\r\n  // Create a ref that stores handler\r\n  const savedHandler = useRef();\r\n\r\n  // Update ref.current value if handler changes.\r\n  // This allows our effect below to always get latest handler ...\r\n  // ... without us needing to pass it in effect deps array ...\r\n  // ... and potentially cause effect to re-run every render.\r\n  useEffect(() => {\r\n    savedHandler.current = handler;\r\n  }, [handler]);\r\n\r\n  useEffect(\r\n    () => {\r\n      // Make sure element supports addEventListener\r\n      // On\r\n      const isSupported = element && element.addEventListener;\r\n      if (!isSupported) {\r\n        return false;\r\n      }\r\n\r\n      // Create event listener that calls handler function stored in ref\r\n      const eventListener = (event) => savedHandler.current(event);\r\n\r\n      // Add event listener\r\n      element.addEventListener(eventName, eventListener);\r\n\r\n      // Remove event listener on cleanup\r\n      return () => {\r\n        element.removeEventListener(eventName, eventListener);\r\n      };\r\n    },\r\n    [eventName, element] // Re-run if eventName or element changes\r\n  );\r\n}\r\n\r\nexport default useEventListener;\r\n"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,OAAlC;AAEA;AACA;AACA;;AACA,SAASC,gBAAT,CAA0BC,SAA1B,EAAqCC,OAArC,EAAgE;EAAA;;EAAA,IAAlBC,OAAkB,uEAARC,MAAQ;EAC9D;EACA,MAAMC,YAAY,GAAGN,MAAM,EAA3B,CAF8D,CAI9D;EACA;EACA;EACA;;EACAD,SAAS,CAAC,MAAM;IACdO,YAAY,CAACC,OAAb,GAAuBJ,OAAvB;EACD,CAFQ,EAEN,CAACA,OAAD,CAFM,CAAT;EAIAJ,SAAS,CACP,MAAM;IACJ;IACA;IACA,MAAMS,WAAW,GAAGJ,OAAO,IAAIA,OAAO,CAACK,gBAAvC;;IACA,IAAI,CAACD,WAAL,EAAkB;MAChB,OAAO,KAAP;IACD,CANG,CAQJ;;;IACA,MAAME,aAAa,GAAIC,KAAD,IAAWL,YAAY,CAACC,OAAb,CAAqBI,KAArB,CAAjC,CATI,CAWJ;;;IACAP,OAAO,CAACK,gBAAR,CAAyBP,SAAzB,EAAoCQ,aAApC,EAZI,CAcJ;;IACA,OAAO,MAAM;MACXN,OAAO,CAACQ,mBAAR,CAA4BV,SAA5B,EAAuCQ,aAAvC;IACD,CAFD;EAGD,CAnBM,EAoBP,CAACR,SAAD,EAAYE,OAAZ,CApBO,CAoBc;EApBd,CAAT;AAsBD;;GAlCQH,gB;;AAoCT,eAAeA,gBAAf"},"metadata":{},"sourceType":"module"}