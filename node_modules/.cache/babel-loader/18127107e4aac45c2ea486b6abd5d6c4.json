{"ast":null,"code":"import { _samplers } from './openapi-sampler';\nimport { allOfSample } from './allOf';\nimport { inferType } from './infer';\nimport { getResultForCircular, mergeDeep, popSchemaStack } from './utils';\nimport JsonPointer from 'json-pointer';\nlet $refCache = {}; // for circular JS references we use additional array and not object as we need to compare entire schemas and not strings\n\nlet seenSchemasStack = [];\nexport function clearCache() {\n  $refCache = {};\n  seenSchemasStack = [];\n}\n\nfunction inferExample(schema) {\n  let example;\n\n  if (schema.const !== undefined) {\n    example = schema.const;\n  } else if (schema.examples !== undefined && schema.examples.length) {\n    example = schema.examples[0];\n  } else if (schema.enum !== undefined && schema.enum.length) {\n    example = schema.enum[0];\n  } else if (schema.default !== undefined) {\n    example = schema.default;\n  }\n\n  return example;\n}\n\nfunction tryInferExample(schema) {\n  const example = inferExample(schema); // case when we don't infer example from schema but take from `const`, `examples`, `default` or `enum` keywords\n\n  if (example !== undefined) {\n    return {\n      value: example,\n      readOnly: schema.readOnly,\n      writeOnly: schema.writeOnly,\n      type: null\n    };\n  }\n\n  return;\n}\n\nexport function traverse(schema, options, spec, context) {\n  // checking circular JS references by checking context\n  // because context is passed only when traversing through nested objects happens\n  if (context) {\n    if (seenSchemasStack.includes(schema)) return getResultForCircular(inferType(schema));\n    seenSchemasStack.push(schema);\n  }\n\n  if (context && context.depth > options.maxSampleDepth) {\n    popSchemaStack(seenSchemasStack, context);\n    return getResultForCircular(inferType(schema));\n  }\n\n  if (schema.$ref) {\n    if (!spec) {\n      throw new Error('Your schema contains $ref. You must provide full specification in the third parameter.');\n    }\n\n    let ref = decodeURIComponent(schema.$ref);\n\n    if (ref.startsWith('#')) {\n      ref = ref.substring(1);\n    }\n\n    const referenced = JsonPointer.get(spec, ref);\n    let result;\n\n    if ($refCache[ref] !== true) {\n      $refCache[ref] = true;\n      result = traverse(referenced, options, spec, context);\n      $refCache[ref] = false;\n    } else {\n      const referencedType = inferType(referenced);\n      result = getResultForCircular(referencedType);\n    }\n\n    popSchemaStack(seenSchemasStack, context);\n    return result;\n  }\n\n  if (schema.example !== undefined) {\n    popSchemaStack(seenSchemasStack, context);\n    return {\n      value: schema.example,\n      readOnly: schema.readOnly,\n      writeOnly: schema.writeOnly,\n      type: schema.type\n    };\n  }\n\n  if (schema.allOf !== undefined) {\n    popSchemaStack(seenSchemasStack, context);\n    return tryInferExample(schema) || allOfSample({ ...schema,\n      allOf: undefined\n    }, schema.allOf, options, spec, context);\n  }\n\n  if (schema.oneOf && schema.oneOf.length) {\n    if (schema.anyOf) {\n      if (!options.quiet) console.warn('oneOf and anyOf are not supported on the same level. Skipping anyOf');\n    }\n\n    popSchemaStack(seenSchemasStack, context); // Make sure to pass down readOnly and writeOnly annotations from the parent\n\n    const firstOneOf = Object.assign({\n      readOnly: schema.readOnly,\n      writeOnly: schema.writeOnly\n    }, schema.oneOf[0]);\n    return traverseOneOrAnyOf(schema, firstOneOf);\n  }\n\n  if (schema.anyOf && schema.anyOf.length) {\n    popSchemaStack(seenSchemasStack, context); // Make sure to pass down readOnly and writeOnly annotations from the parent\n\n    const firstAnyOf = Object.assign({\n      readOnly: schema.readOnly,\n      writeOnly: schema.writeOnly\n    }, schema.anyOf[0]);\n    return traverseOneOrAnyOf(schema, firstAnyOf);\n  }\n\n  if (schema.if && schema.then) {\n    popSchemaStack(seenSchemasStack, context);\n    return tryInferExample(schema) || traverse(mergeDeep(schema.if, schema.then), options, spec, context);\n  }\n\n  let example = inferExample(schema);\n  let type = null;\n\n  if (example === undefined) {\n    example = null;\n    type = schema.type;\n\n    if (Array.isArray(type) && schema.type.length > 0) {\n      type = schema.type[0];\n    }\n\n    if (!type) {\n      type = inferType(schema);\n    }\n\n    let sampler = _samplers[type];\n\n    if (sampler) {\n      example = sampler(schema, options, spec, context);\n    }\n  }\n\n  popSchemaStack(seenSchemasStack, context);\n  return {\n    value: example,\n    readOnly: schema.readOnly,\n    writeOnly: schema.writeOnly,\n    type: type\n  };\n\n  function traverseOneOrAnyOf(schema, selectedSubSchema) {\n    const inferred = tryInferExample(schema);\n\n    if (inferred !== undefined) {\n      return inferred;\n    }\n\n    const localExample = traverse({ ...schema,\n      oneOf: undefined,\n      anyOf: undefined\n    }, options, spec, context);\n    const subSchemaExample = traverse(selectedSubSchema, options, spec, context);\n\n    if (typeof localExample.value === 'object' && typeof subSchemaExample.value === 'object') {\n      const mergedExample = mergeDeep(localExample.value, subSchemaExample.value);\n      return { ...subSchemaExample,\n        value: mergedExample\n      };\n    }\n\n    return subSchemaExample;\n  }\n}","map":{"version":3,"names":["_samplers","allOfSample","inferType","getResultForCircular","mergeDeep","popSchemaStack","JsonPointer","$refCache","seenSchemasStack","clearCache","inferExample","schema","example","const","undefined","examples","length","enum","default","tryInferExample","value","readOnly","writeOnly","type","traverse","options","spec","context","includes","push","depth","maxSampleDepth","$ref","Error","ref","decodeURIComponent","startsWith","substring","referenced","get","result","referencedType","allOf","oneOf","anyOf","quiet","console","warn","firstOneOf","Object","assign","traverseOneOrAnyOf","firstAnyOf","if","then","Array","isArray","sampler","selectedSubSchema","inferred","localExample","subSchemaExample","mergedExample"],"sources":["C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/openapi-sampler/src/traverse.js"],"sourcesContent":["import { _samplers } from './openapi-sampler';\nimport { allOfSample } from './allOf';\nimport { inferType } from './infer';\nimport { getResultForCircular, mergeDeep, popSchemaStack } from './utils';\nimport JsonPointer from 'json-pointer';\n\nlet $refCache = {};\n// for circular JS references we use additional array and not object as we need to compare entire schemas and not strings\nlet seenSchemasStack = [];\n\nexport function clearCache() {\n  $refCache = {};\n  seenSchemasStack = [];\n}\n\nfunction inferExample(schema) {\n  let example;\n  if (schema.const !== undefined) {\n    example = schema.const;\n  } else if (schema.examples !== undefined && schema.examples.length) {\n    example = schema.examples[0];\n  } else if (schema.enum !== undefined && schema.enum.length) {\n    example = schema.enum[0];\n  } else if (schema.default !== undefined) {\n    example = schema.default;\n  }\n  return example;\n}\n\nfunction tryInferExample(schema) {\n  const example = inferExample(schema);\n  // case when we don't infer example from schema but take from `const`, `examples`, `default` or `enum` keywords\n  if (example !== undefined) {\n    return {\n      value: example,\n      readOnly: schema.readOnly,\n      writeOnly: schema.writeOnly,\n      type: null,\n    };\n  }\n  return;\n}\n\nexport function traverse(schema, options, spec, context) {\n  // checking circular JS references by checking context\n  // because context is passed only when traversing through nested objects happens\n  if (context) {\n    if (seenSchemasStack.includes(schema)) return getResultForCircular(inferType(schema));\n    seenSchemasStack.push(schema);\n  }\n\n\n  if (context && context.depth > options.maxSampleDepth) {\n    popSchemaStack(seenSchemasStack, context);\n    return getResultForCircular(inferType(schema));\n  }\n\n  if (schema.$ref) {\n    if (!spec) {\n      throw new Error('Your schema contains $ref. You must provide full specification in the third parameter.');\n    }\n    let ref = decodeURIComponent(schema.$ref);\n    if (ref.startsWith('#')) {\n      ref = ref.substring(1);\n    }\n\n    const referenced = JsonPointer.get(spec, ref);\n    let result;\n\n    if ($refCache[ref] !== true) {\n      $refCache[ref] = true;\n      result = traverse(referenced, options, spec, context);\n      $refCache[ref] = false;\n    } else {\n      const referencedType = inferType(referenced);\n      result = getResultForCircular(referencedType);\n    }\n    popSchemaStack(seenSchemasStack, context);\n    return result;\n  }\n\n  if (schema.example !== undefined) {\n    popSchemaStack(seenSchemasStack, context);\n    return {\n      value: schema.example,\n      readOnly: schema.readOnly,\n      writeOnly: schema.writeOnly,\n      type: schema.type,\n    };\n  }\n\n  if (schema.allOf !== undefined) {\n    popSchemaStack(seenSchemasStack, context);\n    return tryInferExample(schema) || allOfSample(\n      { ...schema, allOf: undefined },\n      schema.allOf,\n      options,\n      spec,\n      context,\n    );\n  }\n\n  if (schema.oneOf && schema.oneOf.length) {\n    if (schema.anyOf) {\n      if (!options.quiet) console.warn('oneOf and anyOf are not supported on the same level. Skipping anyOf');\n    }\n    popSchemaStack(seenSchemasStack, context);\n\n    // Make sure to pass down readOnly and writeOnly annotations from the parent\n    const firstOneOf = Object.assign({\n      readOnly: schema.readOnly,\n      writeOnly: schema.writeOnly\n    }, schema.oneOf[0]);\n\n    return traverseOneOrAnyOf(schema, firstOneOf)\n  }\n\n  if (schema.anyOf && schema.anyOf.length) {\n    popSchemaStack(seenSchemasStack, context);\n\n    // Make sure to pass down readOnly and writeOnly annotations from the parent\n    const firstAnyOf = Object.assign({\n      readOnly: schema.readOnly,\n      writeOnly: schema.writeOnly\n    }, schema.anyOf[0]);\n\n    return traverseOneOrAnyOf(schema, firstAnyOf)\n  }\n\n  if (schema.if && schema.then) {\n    popSchemaStack(seenSchemasStack, context);\n    return tryInferExample(schema) || traverse(mergeDeep(schema.if, schema.then), options, spec, context);\n  }\n\n  let example = inferExample(schema);\n  let type = null;\n  if (example === undefined) {\n    example = null;\n    type = schema.type;\n    if (Array.isArray(type) && schema.type.length > 0) {\n      type = schema.type[0];\n    }\n    if (!type) {\n      type = inferType(schema);\n    }\n    let sampler = _samplers[type];\n    if (sampler) {\n      example = sampler(schema, options, spec, context);\n    }\n  }\n\n  popSchemaStack(seenSchemasStack, context);\n  return {\n    value: example,\n    readOnly: schema.readOnly,\n    writeOnly: schema.writeOnly,\n    type: type\n  };\n\n  function traverseOneOrAnyOf(schema, selectedSubSchema) {\n    const inferred = tryInferExample(schema);\n    if (inferred !== undefined) {\n      return inferred;\n    }\n\n    const localExample = traverse({...schema, oneOf: undefined, anyOf: undefined }, options, spec, context);\n    const subSchemaExample = traverse(selectedSubSchema, options, spec, context);\n\n    if (typeof localExample.value === 'object' && typeof subSchemaExample.value === 'object') {\n      const mergedExample = mergeDeep(localExample.value, subSchemaExample.value);\n      return {...subSchemaExample, value: mergedExample };\n    }\n\n    return subSchemaExample;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}