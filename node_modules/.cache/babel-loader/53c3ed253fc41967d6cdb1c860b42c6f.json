{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\n\nconst codegen_1 = require(\"./codegen\");\n\nconst validation_error_1 = require(\"../runtime/validation_error\");\n\nconst names_1 = require(\"./names\");\n\nconst resolve_1 = require(\"./resolve\");\n\nconst util_1 = require(\"./util\");\n\nconst validate_1 = require(\"./validate\");\n\nconst URI = require(\"uri-js\");\n\nclass SchemaEnv {\n  constructor(env) {\n    var _a;\n\n    this.refs = {};\n    this.dynamicAnchors = {};\n    let schema;\n    if (typeof env.schema == \"object\") schema = env.schema;\n    this.schema = env.schema;\n    this.schemaId = env.schemaId;\n    this.root = env.root || this;\n    this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : resolve_1.normalizeId(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n    this.schemaPath = env.schemaPath;\n    this.localRefs = env.localRefs;\n    this.meta = env.meta;\n    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n    this.refs = {};\n  }\n\n}\n\nexports.SchemaEnv = SchemaEnv; // let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\n\nfunction compileSchema(sch) {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch);\n\n  if (_sch) return _sch;\n  const rootId = resolve_1.getFullPath(sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n\n  const {\n    es5,\n    lines\n  } = this.opts.code;\n  const {\n    ownProperties\n  } = this.opts;\n  const gen = new codegen_1.CodeGen(this.scope, {\n    es5,\n    lines,\n    ownProperties\n  });\n\n  let _ValidationError;\n\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: validation_error_1.default,\n      code: codegen_1._`require(\"ajv/dist/runtime/validation_error\").default`\n    });\n  }\n\n  const validateName = gen.scopeName(\"validate\");\n  sch.validateName = validateName;\n  const schemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: names_1.default.data,\n    parentData: names_1.default.parentData,\n    parentDataProperty: names_1.default.parentDataProperty,\n    dataNames: [names_1.default.data],\n    dataPathArr: [codegen_1.nil],\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set(),\n    topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true ? {\n      ref: sch.schema,\n      code: codegen_1.stringify(sch.schema)\n    } : {\n      ref: sch.schema\n    }),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: codegen_1._`\"\"`,\n    opts: this.opts,\n    self: this\n  };\n  let sourceCode;\n\n  try {\n    this._compilations.add(sch);\n\n    validate_1.validateFunctionCode(schemaCxt);\n    gen.optimize(this.opts.code.optimize); // gen.optimize(1)\n\n    const validateCode = gen.toString();\n    sourceCode = `const visitedNodesForRef = new WeakMap(); ${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`; // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch); // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n\n    const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n    const validate = makeValidate(this, this.scope.get());\n    this.scope.value(validateName, {\n      ref: validate\n    });\n    validate.errors = null;\n    validate.schema = sch.schema;\n    validate.schemaEnv = sch;\n    if (sch.$async) validate.$async = true;\n\n    if (this.opts.code.source === true) {\n      validate.source = {\n        validateName,\n        validateCode,\n        scopeValues: gen._values\n      };\n    }\n\n    if (this.opts.unevaluated) {\n      const {\n        props,\n        items\n      } = schemaCxt;\n      validate.evaluated = {\n        props: props instanceof codegen_1.Name ? undefined : props,\n        items: items instanceof codegen_1.Name ? undefined : items,\n        dynamicProps: props instanceof codegen_1.Name,\n        dynamicItems: items instanceof codegen_1.Name\n      };\n      if (validate.source) validate.source.evaluated = codegen_1.stringify(validate.evaluated);\n    }\n\n    sch.validate = validate;\n    return sch;\n  } catch (e) {\n    delete sch.validate;\n    delete sch.validateName;\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode); // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n\n    throw e;\n  } finally {\n    this._compilations.delete(sch);\n  }\n}\n\nexports.compileSchema = compileSchema;\n\nfunction resolveRef(root, baseId, origRef) {\n  var _a;\n\n  const ref = resolve_1.resolveUrl(baseId, origRef);\n  const schOrFunc = root.refs[ref];\n  if (schOrFunc) return schOrFunc;\n\n  let _sch = resolve.call(this, root, ref);\n\n  if (_sch === undefined) {\n    const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n\n    const {\n      schemaId\n    } = this.opts;\n    if (schema) _sch = new SchemaEnv({\n      schema,\n      schemaId,\n      root,\n      baseId\n    });\n  }\n\n  if (_sch === undefined && this.opts.loadSchemaSync) {\n    const remoteSchema = this.opts.loadSchemaSync(baseId, origRef, ref);\n\n    if (remoteSchema && !(this.refs[ref] || this.schemas[ref])) {\n      this.addSchema(remoteSchema, ref, undefined);\n      _sch = resolve.call(this, root, ref);\n    }\n  }\n\n  if (_sch === undefined) return;\n  return root.refs[ref] = inlineOrCompile.call(this, _sch);\n}\n\nexports.resolveRef = resolveRef;\n\nfunction inlineOrCompile(sch) {\n  if (resolve_1.inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema;\n  return sch.validate ? sch : compileSchema.call(this, sch);\n} // Index of schema compilation in the currently compiled list\n\n\nfunction getCompilingSchema(schEnv) {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch;\n  }\n}\n\nexports.getCompilingSchema = getCompilingSchema;\n\nfunction sameSchemaEnv(s1, s2) {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n} // resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\n\n\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n  let sch;\n\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch;\n\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n} // Resolve schema, its root and baseId\n\n\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n  const p = URI.parse(ref);\n\n  const refPath = resolve_1._getFullPath(p);\n\n  let baseId = resolve_1.getFullPath(root.baseId); // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root);\n  }\n\n  const id = resolve_1.normalizeId(refPath);\n  const schOrRef = this.refs[id] || this.schemas[id];\n\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef);\n    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\") return;\n    return getJsonPointer.call(this, p, sch);\n  }\n\n  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\") return;\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef);\n\n  if (id === resolve_1.normalizeId(ref)) {\n    const {\n      schema\n    } = schOrRef;\n    const {\n      schemaId\n    } = this.opts;\n    const schId = schema[schemaId];\n    if (schId) baseId = resolve_1.resolveUrl(baseId, schId);\n    return new SchemaEnv({\n      schema,\n      schemaId,\n      root,\n      baseId\n    });\n  }\n\n  return getJsonPointer.call(this, p, schOrRef);\n}\n\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\"properties\", \"patternProperties\", \"enum\", \"dependencies\", \"definitions\"]);\n\nfunction getJsonPointer(parsedRef, _ref) {\n  let {\n    baseId,\n    schema,\n    root\n  } = _ref;\n\n  var _a;\n\n  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\") return;\n\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema == \"boolean\") return;\n    schema = schema[util_1.unescapeFragment(part)];\n    if (schema === undefined) return; // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n\n    const schId = typeof schema == \"object\" && schema[this.opts.schemaId];\n\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolve_1.resolveUrl(baseId, schId);\n    }\n  }\n\n  let env;\n\n  if (typeof schema != \"boolean\" && schema.$ref && !util_1.schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolve_1.resolveUrl(baseId, schema.$ref);\n    env = resolveSchema.call(this, root, $ref);\n  } // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n\n\n  const {\n    schemaId\n  } = this.opts;\n  env = env || new SchemaEnv({\n    schema,\n    schemaId,\n    root,\n    baseId\n  });\n  if (env.schema !== env.root.schema) return env;\n  return undefined;\n}","map":{"version":3,"mappings":"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","names":["SchemaEnv","constructor","env","schema","schemaId","root","baseId","_a","resolve_1","schemaPath","localRefs","meta","$async","refs","exports","compileSchema","sch","_sch","getCompilingSchema","call","rootId","es5","lines","opts","code","ownProperties","gen","codegen_1","scope","_ValidationError","scopeValue","ref","validation_error_1","validateName","scopeName","schemaCxt","allErrors","data","names_1","parentData","parentDataProperty","dataNames","dataPathArr","dataLevel","dataTypes","definedProperties","Set","topSchemaRef","source","ValidationError","schemaEnv","errSchemaPath","jtd","errorPath","self","sourceCode","_compilations","add","validate_1","optimize","validateCode","toString","scopeRefs","process","makeValidate","Function","validate","get","value","errors","scopeValues","_values","unevaluated","props","items","evaluated","undefined","dynamicProps","dynamicItems","e","logger","error","delete","resolveRef","origRef","schOrFunc","resolve","loadSchemaSync","remoteSchema","schemas","addSchema","inlineOrCompile","inlineRefs","schEnv","sameSchemaEnv","s1","s2","resolveSchema","p","URI","parse","refPath","Object","keys","length","getJsonPointer","id","schOrRef","schId","PREVENT_SCOPE_CHANGE","parsedRef","fragment","part","slice","split","util_1","has","$ref","RULES"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\compile\\index.ts"],"sourcesContent":["import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport * as URI from \"uri-js\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `const visitedNodesForRef = new WeakMap(); ${gen.scopeRefs(N.scope)}return ${validateCode}`;\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  origRef: string\n): AnySchema | SchemaEnv | undefined {\n  const ref = resolveUrl(baseId, origRef)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined && this.opts.loadSchemaSync) {\n    const remoteSchema = this.opts.loadSchemaSync(baseId, origRef, ref)\n\n    if (remoteSchema && !(this.refs[ref] || this.schemas[ref])) {\n      this.addSchema(remoteSchema, ref, undefined)\n      _sch = resolve.call(this, root, ref)\n    }\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = URI.parse(ref)\n  const refPath = _getFullPath(p)\n  let baseId = getFullPath(root.baseId)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URI.URIComponents,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema == \"boolean\") return\n    schema = schema[unescapeFragment(part)]\n    if (schema === undefined) return\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema == \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n"]},"metadata":{},"sourceType":"script"}