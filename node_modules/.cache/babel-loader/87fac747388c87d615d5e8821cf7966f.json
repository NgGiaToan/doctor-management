{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst dataType_1 = require(\"../../compile/validate/dataType\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst equal_1 = require(\"../../runtime/equal\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        i,\n        j\n      }\n    } = _ref;\n    return codegen_1.str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        i,\n        j\n      }\n    } = _ref2;\n    return codegen_1._`{i: ${i}, j: ${j}}`;\n  }\n};\nconst def = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      parentSchema,\n      schemaCode,\n      it\n    } = cxt;\n    if (!$data && !schema) return;\n    const valid = gen.let(\"valid\");\n    const itemTypes = parentSchema.items ? dataType_1.getSchemaTypes(parentSchema.items) : [];\n    cxt.block$data(valid, validateUniqueItems, codegen_1._`${schemaCode} === false`);\n    cxt.ok(valid);\n\n    function validateUniqueItems() {\n      const i = gen.let(\"i\", codegen_1._`${data}.length`);\n      const j = gen.let(\"j\");\n      cxt.setParams({\n        i,\n        j\n      });\n      gen.assign(valid, true);\n      gen.if(codegen_1._`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n    }\n\n    function canOptimize() {\n      return itemTypes.length > 0 && !itemTypes.some(t => t === \"object\" || t === \"array\");\n    }\n\n    function loopN(i, j) {\n      const item = gen.name(\"item\");\n      const wrongType = dataType_1.checkDataTypes(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n      const indices = gen.const(\"indices\", codegen_1._`{}`);\n      gen.for(codegen_1._`;${i}--;`, () => {\n        gen.let(item, codegen_1._`${data}[${i}]`);\n        gen.if(wrongType, codegen_1._`continue`);\n        if (itemTypes.length > 1) gen.if(codegen_1._`typeof ${item} == \"string\"`, codegen_1._`${item} += \"_\"`);\n        gen.if(codegen_1._`typeof ${indices}[${item}] == \"number\"`, () => {\n          gen.assign(j, codegen_1._`${indices}[${item}]`);\n          cxt.error();\n          gen.assign(valid, false).break();\n        }).code(codegen_1._`${indices}[${item}] = ${i}`);\n      });\n    }\n\n    function loopN2(i, j) {\n      const eql = util_1.useFunc(gen, equal_1.default);\n      const outer = gen.name(\"outer\");\n      gen.label(outer).for(codegen_1._`;${i}--;`, () => gen.for(codegen_1._`${j} = ${i}; ${j}--;`, () => gen.if(codegen_1._`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n        cxt.error();\n        gen.assign(valid, false).break(outer);\n      })));\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","i","j","codegen_1","def","keyword","type","schemaType","$data","code","cxt","gen","data","schema","parentSchema","schemaCode","it","valid","let","itemTypes","items","dataType_1","block$data","validateUniqueItems","ok","setParams","assign","if","canOptimize","loopN","loopN2","length","some","t","item","name","wrongType","opts","strictNumbers","Wrong","indices","const","for","break","eql","util_1","equal_1","outer","label","exports"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\vocabularies\\validation\\uniqueItems.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}