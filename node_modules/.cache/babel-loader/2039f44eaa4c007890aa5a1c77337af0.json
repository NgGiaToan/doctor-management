{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveDocument = exports.BaseResolver = exports.makeDocumentFromString = exports.makeRefId = exports.YamlParseError = exports.ResolveError = exports.Source = void 0;\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst ref_utils_1 = require(\"./ref-utils\");\n\nconst types_1 = require(\"./types\");\n\nconst utils_1 = require(\"./utils\");\n\nclass Source {\n  constructor(absoluteRef, body, mimeType) {\n    this.absoluteRef = absoluteRef;\n    this.body = body;\n    this.mimeType = mimeType;\n  } // pass safeLoad as argument to separate it from browser bundle\n\n\n  getAst(safeLoad) {\n    var _a;\n\n    if (this._ast === undefined) {\n      this._ast = (_a = safeLoad(this.body, {\n        filename: this.absoluteRef\n      })) !== null && _a !== void 0 ? _a : undefined; // fix ast representation of file with newlines only\n\n      if (this._ast && this._ast.kind === 0 && // KIND.scalar = 0\n      this._ast.value === '' && this._ast.startPosition !== 1) {\n        this._ast.startPosition = 1;\n        this._ast.endPosition = 1;\n      }\n    }\n\n    return this._ast;\n  }\n\n  getLines() {\n    if (this._lines === undefined) {\n      this._lines = this.body.split(/\\r\\n|[\\n\\r]/g);\n    }\n\n    return this._lines;\n  }\n\n}\n\nexports.Source = Source;\n\nclass ResolveError extends Error {\n  constructor(originalError) {\n    super(originalError.message);\n    this.originalError = originalError; // Set the prototype explicitly.\n\n    Object.setPrototypeOf(this, ResolveError.prototype);\n  }\n\n}\n\nexports.ResolveError = ResolveError;\nconst jsYamlErrorLineColRegexp = /\\((\\d+):(\\d+)\\)$/;\n\nclass YamlParseError extends Error {\n  constructor(originalError, source) {\n    super(originalError.message.split('\\n')[0]);\n    this.originalError = originalError;\n    this.source = source; // Set the prototype explicitly.\n\n    Object.setPrototypeOf(this, YamlParseError.prototype);\n    const [, line, col] = this.message.match(jsYamlErrorLineColRegexp) || [];\n    this.line = parseInt(line, 10);\n    this.col = parseInt(col, 10);\n  }\n\n}\n\nexports.YamlParseError = YamlParseError;\n\nfunction makeRefId(absoluteRef, pointer) {\n  return absoluteRef + '::' + pointer;\n}\n\nexports.makeRefId = makeRefId;\n\nfunction makeDocumentFromString(sourceString, absoluteRef) {\n  const source = new Source(absoluteRef, sourceString);\n\n  try {\n    return {\n      source,\n      parsed: utils_1.parseYaml(sourceString, {\n        filename: absoluteRef\n      })\n    };\n  } catch (e) {\n    throw new YamlParseError(e, source);\n  }\n}\n\nexports.makeDocumentFromString = makeDocumentFromString;\n\nclass BaseResolver {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      http: {\n        headers: []\n      }\n    };\n    this.config = config;\n    this.cache = new Map();\n  }\n\n  getFiles() {\n    return new Set(Array.from(this.cache.keys()));\n  }\n\n  resolveExternalRef(base, ref) {\n    if (ref_utils_1.isAbsoluteUrl(ref)) {\n      return ref;\n    }\n\n    if (base && ref_utils_1.isAbsoluteUrl(base)) {\n      return new URL(ref, base).href;\n    }\n\n    return path.resolve(base ? path.dirname(base) : process.cwd(), ref);\n  }\n\n  loadExternalRef(absoluteRef) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (ref_utils_1.isAbsoluteUrl(absoluteRef)) {\n          const {\n            body,\n            mimeType\n          } = yield utils_1.readFileFromUrl(absoluteRef, this.config.http);\n          return new Source(absoluteRef, body, mimeType);\n        } else {\n          return new Source(absoluteRef, yield fs.promises.readFile(absoluteRef, 'utf-8'));\n        }\n      } catch (error) {\n        throw new ResolveError(error);\n      }\n    });\n  }\n\n  parseDocument(source) {\n    let isRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    var _a;\n\n    const ext = source.absoluteRef.substr(source.absoluteRef.lastIndexOf('.'));\n\n    if (!['.json', '.json', '.yml', '.yaml'].includes(ext) && !((_a = source.mimeType) === null || _a === void 0 ? void 0 : _a.match(/(json|yaml|openapi)/)) && !isRoot // always parse root\n    ) {\n      return {\n        source,\n        parsed: source.body\n      };\n    }\n\n    try {\n      return {\n        source,\n        parsed: utils_1.parseYaml(source.body, {\n          filename: source.absoluteRef\n        })\n      };\n    } catch (e) {\n      throw new YamlParseError(e, source);\n    }\n  }\n\n  resolveDocument(base, ref) {\n    let isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      const absoluteRef = this.resolveExternalRef(base, ref);\n      const cachedDocument = this.cache.get(absoluteRef);\n\n      if (cachedDocument) {\n        return cachedDocument;\n      }\n\n      const doc = this.loadExternalRef(absoluteRef).then(source => {\n        return this.parseDocument(source, isRoot);\n      });\n      this.cache.set(absoluteRef, doc);\n      return doc;\n    });\n  }\n\n}\n\nexports.BaseResolver = BaseResolver;\n\nfunction pushRef(head, node) {\n  return {\n    prev: head,\n    node\n  };\n}\n\nfunction hasRef(head, node) {\n  while (head) {\n    if (head.node === node) {\n      return true;\n    }\n\n    head = head.prev;\n  }\n\n  return false;\n}\n\nconst unknownType = {\n  name: 'unknown',\n  properties: {}\n};\nconst resolvableScalarType = {\n  name: 'scalar',\n  properties: {}\n};\n\nfunction resolveDocument(opts) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      rootDocument,\n      externalRefResolver,\n      rootType\n    } = opts;\n    const resolvedRefMap = new Map();\n    const seedNodes = new Set(); // format \"${type}::${absoluteRef}${pointer}\"\n\n    const resolvePromises = [];\n    resolveRefsInParallel(rootDocument.parsed, rootDocument, '#/', rootType);\n    let resolved;\n\n    do {\n      resolved = yield Promise.all(resolvePromises);\n    } while (resolvePromises.length !== resolved.length);\n\n    return resolvedRefMap;\n\n    function resolveRefsInParallel(rootNode, rootNodeDocument, rootNodePointer, type) {\n      const rootNodeDocAbsoluteRef = rootNodeDocument.source.absoluteRef;\n      walk(rootNode, type, rootNodeDocAbsoluteRef + rootNodePointer);\n\n      function walk(node, type, nodeAbsoluteRef) {\n        if (typeof node !== 'object' || node === null) {\n          return;\n        }\n\n        const nodeId = `${type.name}::${nodeAbsoluteRef}`;\n\n        if (seedNodes.has(nodeId)) {\n          return;\n        }\n\n        seedNodes.add(nodeId);\n\n        if (Array.isArray(node)) {\n          const itemsType = type.items; // we continue resolving unknown types, but stop early on known scalars\n\n          if (type !== unknownType && itemsType === undefined) {\n            return;\n          }\n\n          for (let i = 0; i < node.length; i++) {\n            walk(node[i], itemsType || unknownType, ref_utils_1.joinPointer(nodeAbsoluteRef, i));\n          }\n\n          return;\n        }\n\n        for (const propName of Object.keys(node)) {\n          let propValue = node[propName];\n          let propType = type.properties[propName];\n          if (propType === undefined) propType = type.additionalProperties;\n          if (typeof propType === 'function') propType = propType(propValue, propName);\n          if (propType === undefined) propType = unknownType;\n\n          if (!types_1.isNamedType(propType) && (propType === null || propType === void 0 ? void 0 : propType.directResolveAs)) {\n            propType = propType.directResolveAs;\n            propValue = {\n              $ref: propValue\n            };\n          }\n\n          if (propType && propType.name === undefined && propType.resolvable !== false) {\n            propType = resolvableScalarType;\n          }\n\n          if (!types_1.isNamedType(propType) || typeof propValue !== 'object') {\n            continue;\n          }\n\n          walk(propValue, propType, ref_utils_1.joinPointer(nodeAbsoluteRef, ref_utils_1.escapePointer(propName)));\n        }\n\n        if (ref_utils_1.isRef(node)) {\n          const promise = followRef(rootNodeDocument, node, {\n            prev: null,\n            node\n          }).then(resolvedRef => {\n            if (resolvedRef.resolved) {\n              resolveRefsInParallel(resolvedRef.node, resolvedRef.document, resolvedRef.nodePointer, type);\n            }\n          });\n          resolvePromises.push(promise);\n        }\n      }\n\n      function followRef(document, ref, refStack) {\n        return __awaiter(this, void 0, void 0, function* () {\n          if (hasRef(refStack.prev, ref)) {\n            throw new Error('Self-referencing circular pointer');\n          }\n\n          const {\n            uri,\n            pointer\n          } = ref_utils_1.parseRef(ref.$ref);\n          const isRemote = uri !== null;\n          let targetDoc;\n\n          try {\n            targetDoc = isRemote ? yield externalRefResolver.resolveDocument(document.source.absoluteRef, uri) : document;\n          } catch (error) {\n            const resolvedRef = {\n              resolved: false,\n              isRemote,\n              document: undefined,\n              error: error\n            };\n            const refId = makeRefId(document.source.absoluteRef, ref.$ref);\n            resolvedRefMap.set(refId, resolvedRef);\n            return resolvedRef;\n          }\n\n          let resolvedRef = {\n            resolved: true,\n            document: targetDoc,\n            isRemote,\n            node: document.parsed,\n            nodePointer: '#/'\n          };\n          let target = targetDoc.parsed;\n          const segments = pointer;\n\n          for (let segment of segments) {\n            if (typeof target !== 'object') {\n              target = undefined;\n              break;\n            } else if (target[segment] !== undefined) {\n              target = target[segment];\n              resolvedRef.nodePointer = ref_utils_1.joinPointer(resolvedRef.nodePointer, ref_utils_1.escapePointer(segment));\n            } else if (ref_utils_1.isRef(target)) {\n              resolvedRef = yield followRef(targetDoc, target, pushRef(refStack, target));\n              targetDoc = resolvedRef.document || targetDoc;\n\n              if (typeof resolvedRef.node !== 'object') {\n                target = undefined;\n                break;\n              }\n\n              target = resolvedRef.node[segment];\n              resolvedRef.nodePointer = ref_utils_1.joinPointer(resolvedRef.nodePointer, ref_utils_1.escapePointer(segment));\n            } else {\n              target = undefined;\n              break;\n            }\n          }\n\n          resolvedRef.node = target;\n          resolvedRef.document = targetDoc;\n          const refId = makeRefId(document.source.absoluteRef, ref.$ref);\n\n          if (resolvedRef.document && ref_utils_1.isRef(target)) {\n            resolvedRef = yield followRef(resolvedRef.document, target, pushRef(refStack, target));\n          }\n\n          resolvedRefMap.set(refId, resolvedRef);\n          return Object.assign({}, resolvedRef);\n        });\n      }\n    }\n  });\n}\n\nexports.resolveDocument = resolveDocument;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","resolveDocument","BaseResolver","makeDocumentFromString","makeRefId","YamlParseError","ResolveError","Source","fs","require","path","ref_utils_1","types_1","utils_1","constructor","absoluteRef","body","mimeType","getAst","safeLoad","_a","_ast","undefined","filename","kind","startPosition","endPosition","getLines","_lines","split","Error","originalError","message","setPrototypeOf","prototype","jsYamlErrorLineColRegexp","source","line","col","match","parseInt","pointer","sourceString","parsed","parseYaml","config","http","headers","cache","Map","getFiles","Set","Array","from","keys","resolveExternalRef","base","ref","isAbsoluteUrl","URL","href","dirname","process","cwd","loadExternalRef","readFileFromUrl","promises","readFile","error","parseDocument","isRoot","ext","substr","lastIndexOf","includes","cachedDocument","get","doc","set","pushRef","head","node","prev","hasRef","unknownType","name","properties","resolvableScalarType","opts","rootDocument","externalRefResolver","rootType","resolvedRefMap","seedNodes","resolvePromises","resolveRefsInParallel","resolved","all","length","rootNode","rootNodeDocument","rootNodePointer","type","rootNodeDocAbsoluteRef","walk","nodeAbsoluteRef","nodeId","has","add","isArray","itemsType","items","i","joinPointer","propName","propValue","propType","additionalProperties","isNamedType","directResolveAs","$ref","resolvable","escapePointer","isRef","promise","followRef","resolvedRef","document","nodePointer","push","refStack","uri","parseRef","isRemote","targetDoc","refId","target","segments","segment","assign"],"sources":["C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@redocly/openapi-core/lib/resolve.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveDocument = exports.BaseResolver = exports.makeDocumentFromString = exports.makeRefId = exports.YamlParseError = exports.ResolveError = exports.Source = void 0;\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst ref_utils_1 = require(\"./ref-utils\");\nconst types_1 = require(\"./types\");\nconst utils_1 = require(\"./utils\");\nclass Source {\n    constructor(absoluteRef, body, mimeType) {\n        this.absoluteRef = absoluteRef;\n        this.body = body;\n        this.mimeType = mimeType;\n    }\n    // pass safeLoad as argument to separate it from browser bundle\n    getAst(safeLoad) {\n        var _a;\n        if (this._ast === undefined) {\n            this._ast = (_a = safeLoad(this.body, { filename: this.absoluteRef })) !== null && _a !== void 0 ? _a : undefined;\n            // fix ast representation of file with newlines only\n            if (this._ast &&\n                this._ast.kind === 0 && // KIND.scalar = 0\n                this._ast.value === '' &&\n                this._ast.startPosition !== 1) {\n                this._ast.startPosition = 1;\n                this._ast.endPosition = 1;\n            }\n        }\n        return this._ast;\n    }\n    getLines() {\n        if (this._lines === undefined) {\n            this._lines = this.body.split(/\\r\\n|[\\n\\r]/g);\n        }\n        return this._lines;\n    }\n}\nexports.Source = Source;\nclass ResolveError extends Error {\n    constructor(originalError) {\n        super(originalError.message);\n        this.originalError = originalError;\n        // Set the prototype explicitly.\n        Object.setPrototypeOf(this, ResolveError.prototype);\n    }\n}\nexports.ResolveError = ResolveError;\nconst jsYamlErrorLineColRegexp = /\\((\\d+):(\\d+)\\)$/;\nclass YamlParseError extends Error {\n    constructor(originalError, source) {\n        super(originalError.message.split('\\n')[0]);\n        this.originalError = originalError;\n        this.source = source;\n        // Set the prototype explicitly.\n        Object.setPrototypeOf(this, YamlParseError.prototype);\n        const [, line, col] = this.message.match(jsYamlErrorLineColRegexp) || [];\n        this.line = parseInt(line, 10);\n        this.col = parseInt(col, 10);\n    }\n}\nexports.YamlParseError = YamlParseError;\nfunction makeRefId(absoluteRef, pointer) {\n    return absoluteRef + '::' + pointer;\n}\nexports.makeRefId = makeRefId;\nfunction makeDocumentFromString(sourceString, absoluteRef) {\n    const source = new Source(absoluteRef, sourceString);\n    try {\n        return {\n            source,\n            parsed: utils_1.parseYaml(sourceString, { filename: absoluteRef }),\n        };\n    }\n    catch (e) {\n        throw new YamlParseError(e, source);\n    }\n}\nexports.makeDocumentFromString = makeDocumentFromString;\nclass BaseResolver {\n    constructor(config = { http: { headers: [] } }) {\n        this.config = config;\n        this.cache = new Map();\n    }\n    getFiles() {\n        return new Set(Array.from(this.cache.keys()));\n    }\n    resolveExternalRef(base, ref) {\n        if (ref_utils_1.isAbsoluteUrl(ref)) {\n            return ref;\n        }\n        if (base && ref_utils_1.isAbsoluteUrl(base)) {\n            return new URL(ref, base).href;\n        }\n        return path.resolve(base ? path.dirname(base) : process.cwd(), ref);\n    }\n    loadExternalRef(absoluteRef) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (ref_utils_1.isAbsoluteUrl(absoluteRef)) {\n                    const { body, mimeType } = yield utils_1.readFileFromUrl(absoluteRef, this.config.http);\n                    return new Source(absoluteRef, body, mimeType);\n                }\n                else {\n                    return new Source(absoluteRef, yield fs.promises.readFile(absoluteRef, 'utf-8'));\n                }\n            }\n            catch (error) {\n                throw new ResolveError(error);\n            }\n        });\n    }\n    parseDocument(source, isRoot = false) {\n        var _a;\n        const ext = source.absoluteRef.substr(source.absoluteRef.lastIndexOf('.'));\n        if (!['.json', '.json', '.yml', '.yaml'].includes(ext) &&\n            !((_a = source.mimeType) === null || _a === void 0 ? void 0 : _a.match(/(json|yaml|openapi)/)) &&\n            !isRoot // always parse root\n        ) {\n            return { source, parsed: source.body };\n        }\n        try {\n            return {\n                source,\n                parsed: utils_1.parseYaml(source.body, { filename: source.absoluteRef }),\n            };\n        }\n        catch (e) {\n            throw new YamlParseError(e, source);\n        }\n    }\n    resolveDocument(base, ref, isRoot = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const absoluteRef = this.resolveExternalRef(base, ref);\n            const cachedDocument = this.cache.get(absoluteRef);\n            if (cachedDocument) {\n                return cachedDocument;\n            }\n            const doc = this.loadExternalRef(absoluteRef).then((source) => {\n                return this.parseDocument(source, isRoot);\n            });\n            this.cache.set(absoluteRef, doc);\n            return doc;\n        });\n    }\n}\nexports.BaseResolver = BaseResolver;\nfunction pushRef(head, node) {\n    return {\n        prev: head,\n        node,\n    };\n}\nfunction hasRef(head, node) {\n    while (head) {\n        if (head.node === node) {\n            return true;\n        }\n        head = head.prev;\n    }\n    return false;\n}\nconst unknownType = { name: 'unknown', properties: {} };\nconst resolvableScalarType = { name: 'scalar', properties: {} };\nfunction resolveDocument(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { rootDocument, externalRefResolver, rootType } = opts;\n        const resolvedRefMap = new Map();\n        const seedNodes = new Set(); // format \"${type}::${absoluteRef}${pointer}\"\n        const resolvePromises = [];\n        resolveRefsInParallel(rootDocument.parsed, rootDocument, '#/', rootType);\n        let resolved;\n        do {\n            resolved = yield Promise.all(resolvePromises);\n        } while (resolvePromises.length !== resolved.length);\n        return resolvedRefMap;\n        function resolveRefsInParallel(rootNode, rootNodeDocument, rootNodePointer, type) {\n            const rootNodeDocAbsoluteRef = rootNodeDocument.source.absoluteRef;\n            walk(rootNode, type, rootNodeDocAbsoluteRef + rootNodePointer);\n            function walk(node, type, nodeAbsoluteRef) {\n                if (typeof node !== 'object' || node === null) {\n                    return;\n                }\n                const nodeId = `${type.name}::${nodeAbsoluteRef}`;\n                if (seedNodes.has(nodeId)) {\n                    return;\n                }\n                seedNodes.add(nodeId);\n                if (Array.isArray(node)) {\n                    const itemsType = type.items;\n                    // we continue resolving unknown types, but stop early on known scalars\n                    if (type !== unknownType && itemsType === undefined) {\n                        return;\n                    }\n                    for (let i = 0; i < node.length; i++) {\n                        walk(node[i], itemsType || unknownType, ref_utils_1.joinPointer(nodeAbsoluteRef, i));\n                    }\n                    return;\n                }\n                for (const propName of Object.keys(node)) {\n                    let propValue = node[propName];\n                    let propType = type.properties[propName];\n                    if (propType === undefined)\n                        propType = type.additionalProperties;\n                    if (typeof propType === 'function')\n                        propType = propType(propValue, propName);\n                    if (propType === undefined)\n                        propType = unknownType;\n                    if (!types_1.isNamedType(propType) && (propType === null || propType === void 0 ? void 0 : propType.directResolveAs)) {\n                        propType = propType.directResolveAs;\n                        propValue = { $ref: propValue };\n                    }\n                    if (propType && propType.name === undefined && propType.resolvable !== false) {\n                        propType = resolvableScalarType;\n                    }\n                    if (!types_1.isNamedType(propType) || typeof propValue !== 'object') {\n                        continue;\n                    }\n                    walk(propValue, propType, ref_utils_1.joinPointer(nodeAbsoluteRef, ref_utils_1.escapePointer(propName)));\n                }\n                if (ref_utils_1.isRef(node)) {\n                    const promise = followRef(rootNodeDocument, node, {\n                        prev: null,\n                        node,\n                    }).then((resolvedRef) => {\n                        if (resolvedRef.resolved) {\n                            resolveRefsInParallel(resolvedRef.node, resolvedRef.document, resolvedRef.nodePointer, type);\n                        }\n                    });\n                    resolvePromises.push(promise);\n                }\n            }\n            function followRef(document, ref, refStack) {\n                return __awaiter(this, void 0, void 0, function* () {\n                    if (hasRef(refStack.prev, ref)) {\n                        throw new Error('Self-referencing circular pointer');\n                    }\n                    const { uri, pointer } = ref_utils_1.parseRef(ref.$ref);\n                    const isRemote = uri !== null;\n                    let targetDoc;\n                    try {\n                        targetDoc = isRemote\n                            ? (yield externalRefResolver.resolveDocument(document.source.absoluteRef, uri))\n                            : document;\n                    }\n                    catch (error) {\n                        const resolvedRef = {\n                            resolved: false,\n                            isRemote,\n                            document: undefined,\n                            error: error,\n                        };\n                        const refId = makeRefId(document.source.absoluteRef, ref.$ref);\n                        resolvedRefMap.set(refId, resolvedRef);\n                        return resolvedRef;\n                    }\n                    let resolvedRef = {\n                        resolved: true,\n                        document: targetDoc,\n                        isRemote,\n                        node: document.parsed,\n                        nodePointer: '#/',\n                    };\n                    let target = targetDoc.parsed;\n                    const segments = pointer;\n                    for (let segment of segments) {\n                        if (typeof target !== 'object') {\n                            target = undefined;\n                            break;\n                        }\n                        else if (target[segment] !== undefined) {\n                            target = target[segment];\n                            resolvedRef.nodePointer = ref_utils_1.joinPointer(resolvedRef.nodePointer, ref_utils_1.escapePointer(segment));\n                        }\n                        else if (ref_utils_1.isRef(target)) {\n                            resolvedRef = yield followRef(targetDoc, target, pushRef(refStack, target));\n                            targetDoc = resolvedRef.document || targetDoc;\n                            if (typeof resolvedRef.node !== 'object') {\n                                target = undefined;\n                                break;\n                            }\n                            target = resolvedRef.node[segment];\n                            resolvedRef.nodePointer = ref_utils_1.joinPointer(resolvedRef.nodePointer, ref_utils_1.escapePointer(segment));\n                        }\n                        else {\n                            target = undefined;\n                            break;\n                        }\n                    }\n                    resolvedRef.node = target;\n                    resolvedRef.document = targetDoc;\n                    const refId = makeRefId(document.source.absoluteRef, ref.$ref);\n                    if (resolvedRef.document && ref_utils_1.isRef(target)) {\n                        resolvedRef = yield followRef(resolvedRef.document, target, pushRef(refStack, target));\n                    }\n                    resolvedRefMap.set(refId, resolvedRef);\n                    return Object.assign({}, resolvedRef);\n                });\n            }\n        }\n    });\n}\nexports.resolveDocument = resolveDocument;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}