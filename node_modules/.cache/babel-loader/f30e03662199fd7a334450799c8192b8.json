{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.walkDocument = void 0;\n\nvar ref_utils_1 = require(\"./ref-utils\");\n\nvar resolve_1 = require(\"./resolve\");\n\nvar utils_1 = require(\"./utils\");\n\nvar types_1 = require(\"./types\");\n\nfunction collectParents(ctx) {\n  var _a;\n\n  var parents = {};\n\n  while (ctx.parent) {\n    parents[ctx.parent.type.name] = (_a = ctx.parent.activatedOn) === null || _a === void 0 ? void 0 : _a.value.node;\n    ctx = ctx.parent;\n  }\n\n  return parents;\n}\n\nfunction collectParentsLocations(ctx) {\n  var _a, _b;\n\n  var locations = {};\n\n  while (ctx.parent) {\n    if ((_a = ctx.parent.activatedOn) === null || _a === void 0 ? void 0 : _a.value.location) {\n      locations[ctx.parent.type.name] = (_b = ctx.parent.activatedOn) === null || _b === void 0 ? void 0 : _b.value.location;\n    }\n\n    ctx = ctx.parent;\n  }\n\n  return locations;\n}\n\nfunction walkDocument(opts) {\n  var document = opts.document,\n      rootType = opts.rootType,\n      normalizedVisitors = opts.normalizedVisitors,\n      resolvedRefMap = opts.resolvedRefMap,\n      ctx = opts.ctx;\n  var seenNodesPerType = {};\n  var seenRefs = new Set();\n  walkNode(document.parsed, rootType, new ref_utils_1.Location(document.source, '#/'), undefined, '');\n\n  function walkNode(node, type, location, parent, key) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\n    var currentLocation = location;\n\n    var _resolve = resolve(node),\n        resolvedNode = _resolve.node,\n        resolvedLocation = _resolve.location,\n        error = _resolve.error;\n\n    var enteredContexts = new Set();\n\n    if (ref_utils_1.isRef(node)) {\n      var refEnterVisitors = normalizedVisitors.ref.enter;\n\n      var _iterator = _createForOfIteratorHelper(refEnterVisitors),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _step.value,\n              visitor = _step$value.visit,\n              ruleId = _step$value.ruleId,\n              severity = _step$value.severity,\n              context = _step$value.context;\n\n          if (!seenRefs.has(node)) {\n            enteredContexts.add(context);\n            var report = reportFn.bind(undefined, ruleId, severity);\n            visitor(node, {\n              report: report,\n              resolve: resolve,\n              location: location,\n              type: type,\n              parent: parent,\n              key: key,\n              parentLocations: {},\n              oasVersion: ctx.oasVersion,\n              getVisitorData: getVisitorDataFn.bind(undefined, ruleId)\n            }, {\n              node: resolvedNode,\n              location: resolvedLocation,\n              error: error\n            });\n\n            if ((resolvedLocation === null || resolvedLocation === void 0 ? void 0 : resolvedLocation.source.absoluteRef) && ctx.refTypes) {\n              ctx.refTypes.set(resolvedLocation === null || resolvedLocation === void 0 ? void 0 : resolvedLocation.source.absoluteRef, type);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    if (resolvedNode !== undefined && resolvedLocation && type.name !== 'scalar') {\n      currentLocation = resolvedLocation;\n      var isNodeSeen = (_b = (_a = seenNodesPerType[type.name]) === null || _a === void 0 ? void 0 : _a.has) === null || _b === void 0 ? void 0 : _b.call(_a, resolvedNode);\n      var visitedBySome = false;\n      var anyEnterVisitors = normalizedVisitors.any.enter;\n      var currentEnterVisitors = anyEnterVisitors.concat(((_c = normalizedVisitors[type.name]) === null || _c === void 0 ? void 0 : _c.enter) || []);\n      var activatedContexts = [];\n\n      var _iterator2 = _createForOfIteratorHelper(currentEnterVisitors),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _step2.value,\n              _context = _step2$value.context,\n              visit = _step2$value.visit,\n              skip = _step2$value.skip,\n              _ruleId = _step2$value.ruleId,\n              _severity = _step2$value.severity;\n\n          if (_context.isSkippedLevel) {\n            if (_context.parent.activatedOn && !_context.parent.activatedOn.value.nextLevelTypeActivated && !_context.seen.has(node)) {\n              // TODO: test for walk through duplicated $ref-ed node\n              _context.seen.add(node);\n\n              visitedBySome = true;\n              activatedContexts.push(_context);\n            }\n          } else {\n            if (_context.parent && // if nested\n            _context.parent.activatedOn && ((_d = _context.activatedOn) === null || _d === void 0 ? void 0 : _d.value.withParentNode) !== _context.parent.activatedOn.value.node && // do not enter if visited by parent children (it works thanks because deeper visitors are sorted before)\n            ((_e = _context.parent.activatedOn.value.nextLevelTypeActivated) === null || _e === void 0 ? void 0 : _e.value) !== type || !_context.parent && !isNodeSeen // if top-level visit each node just once\n            ) {\n              activatedContexts.push(_context);\n              var activatedOn = {\n                node: resolvedNode,\n                location: resolvedLocation,\n                nextLevelTypeActivated: null,\n                withParentNode: (_g = (_f = _context.parent) === null || _f === void 0 ? void 0 : _f.activatedOn) === null || _g === void 0 ? void 0 : _g.value.node,\n                skipped: (_k = ((_j = (_h = _context.parent) === null || _h === void 0 ? void 0 : _h.activatedOn) === null || _j === void 0 ? void 0 : _j.value.skipped) || (skip === null || skip === void 0 ? void 0 : skip(resolvedNode, key))) !== null && _k !== void 0 ? _k : false\n              };\n              _context.activatedOn = utils_1.pushStack(_context.activatedOn, activatedOn);\n              var _ctx = _context.parent;\n\n              while (_ctx) {\n                _ctx.activatedOn.value.nextLevelTypeActivated = utils_1.pushStack(_ctx.activatedOn.value.nextLevelTypeActivated, type);\n                _ctx = _ctx.parent;\n              }\n\n              if (!activatedOn.skipped) {\n                visitedBySome = true;\n                enteredContexts.add(_context);\n\n                var _visitWithContext = visitWithContext(visit, resolvedNode, _context, _ruleId, _severity),\n                    ignoreNextVisitorsOnNode = _visitWithContext.ignoreNextVisitorsOnNode;\n\n                if (ignoreNextVisitorsOnNode) break;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (visitedBySome || !isNodeSeen) {\n        seenNodesPerType[type.name] = seenNodesPerType[type.name] || new Set();\n        seenNodesPerType[type.name].add(resolvedNode);\n\n        if (Array.isArray(resolvedNode)) {\n          var itemsType = type.items;\n\n          if (itemsType !== undefined) {\n            for (var i = 0; i < resolvedNode.length; i++) {\n              walkNode(resolvedNode[i], itemsType, resolvedLocation.child([i]), resolvedNode, i);\n            }\n          }\n        } else if (typeof resolvedNode === 'object' && resolvedNode !== null) {\n          // visit in order from type-tree first\n          var props = Object.keys(type.properties);\n\n          if (type.additionalProperties) {\n            props.push.apply(props, _toConsumableArray(Object.keys(resolvedNode).filter(function (k) {\n              return !props.includes(k);\n            })));\n          }\n\n          if (ref_utils_1.isRef(node)) {\n            props.push.apply(props, _toConsumableArray(Object.keys(node).filter(function (k) {\n              return k !== '$ref' && !props.includes(k);\n            }))); // properties on the same level as $ref\n          }\n\n          for (var _i = 0, _props = props; _i < _props.length; _i++) {\n            var propName = _props[_i];\n            var value = resolvedNode[propName];\n            var loc = resolvedLocation;\n\n            if (value === undefined) {\n              value = node[propName];\n              loc = location; // properties on the same level as $ref should resolve against original location, not target\n            }\n\n            var propType = type.properties[propName];\n            if (propType === undefined) propType = type.additionalProperties;\n            if (typeof propType === 'function') propType = propType(value, propName);\n\n            if (!types_1.isNamedType(propType) && (propType === null || propType === void 0 ? void 0 : propType.directResolveAs)) {\n              propType = propType.directResolveAs;\n              value = {\n                $ref: value\n              };\n            }\n\n            if (propType && propType.name === undefined && propType.resolvable !== false) {\n              propType = {\n                name: 'scalar',\n                properties: {}\n              };\n            }\n\n            if (!types_1.isNamedType(propType) || propType.name === 'scalar' && !ref_utils_1.isRef(value)) {\n              continue;\n            }\n\n            walkNode(value, propType, loc.child([propName]), resolvedNode, propName);\n          }\n        }\n      }\n\n      var anyLeaveVisitors = normalizedVisitors.any.leave;\n      var currentLeaveVisitors = (((_l = normalizedVisitors[type.name]) === null || _l === void 0 ? void 0 : _l.leave) || []).concat(anyLeaveVisitors);\n\n      var _iterator3 = _createForOfIteratorHelper(activatedContexts.reverse()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _context2 = _step3.value;\n\n          if (_context2.isSkippedLevel) {\n            _context2.seen.delete(resolvedNode);\n          } else {\n            _context2.activatedOn = utils_1.popStack(_context2.activatedOn);\n\n            if (_context2.parent) {\n              var _ctx2 = _context2.parent;\n\n              while (_ctx2) {\n                _ctx2.activatedOn.value.nextLevelTypeActivated = utils_1.popStack(_ctx2.activatedOn.value.nextLevelTypeActivated);\n                _ctx2 = _ctx2.parent;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(currentLeaveVisitors),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _step4.value,\n              _context3 = _step4$value.context,\n              _visit = _step4$value.visit,\n              _ruleId2 = _step4$value.ruleId,\n              _severity2 = _step4$value.severity;\n\n          if (!_context3.isSkippedLevel && enteredContexts.has(_context3)) {\n            visitWithContext(_visit, resolvedNode, _context3, _ruleId2, _severity2);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n\n    currentLocation = location;\n\n    if (ref_utils_1.isRef(node)) {\n      var refLeaveVisitors = normalizedVisitors.ref.leave;\n\n      var _iterator5 = _createForOfIteratorHelper(refLeaveVisitors),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _step5.value,\n              _visitor = _step5$value.visit,\n              _ruleId3 = _step5$value.ruleId,\n              _severity3 = _step5$value.severity,\n              _context4 = _step5$value.context;\n\n          if (enteredContexts.has(_context4)) {\n            var _report = reportFn.bind(undefined, _ruleId3, _severity3);\n\n            _visitor(node, {\n              report: _report,\n              resolve: resolve,\n              location: location,\n              type: type,\n              parent: parent,\n              key: key,\n              parentLocations: {},\n              oasVersion: ctx.oasVersion,\n              getVisitorData: getVisitorDataFn.bind(undefined, _ruleId3)\n            }, {\n              node: resolvedNode,\n              location: resolvedLocation,\n              error: error\n            });\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    } // returns true ignores all the next visitors on the specific node\n\n\n    function visitWithContext(visit, node, context, ruleId, severity) {\n      var report = reportFn.bind(undefined, ruleId, severity);\n      var _ignoreNextVisitorsOnNode = false;\n      visit(node, {\n        report: report,\n        resolve: resolve,\n        location: currentLocation,\n        type: type,\n        parent: parent,\n        key: key,\n        parentLocations: collectParentsLocations(context),\n        oasVersion: ctx.oasVersion,\n        ignoreNextVisitorsOnNode: function ignoreNextVisitorsOnNode() {\n          _ignoreNextVisitorsOnNode = true;\n        },\n        getVisitorData: getVisitorDataFn.bind(undefined, ruleId)\n      }, collectParents(context), context);\n      return {\n        ignoreNextVisitorsOnNode: _ignoreNextVisitorsOnNode\n      };\n    }\n\n    function resolve(ref) {\n      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentLocation.source.absoluteRef;\n      if (!ref_utils_1.isRef(ref)) return {\n        location: location,\n        node: ref\n      };\n      var refId = resolve_1.makeRefId(from, ref.$ref);\n      var resolvedRef = resolvedRefMap.get(refId);\n\n      if (!resolvedRef) {\n        return {\n          location: undefined,\n          node: undefined\n        };\n      }\n\n      var resolved = resolvedRef.resolved,\n          node = resolvedRef.node,\n          document = resolvedRef.document,\n          nodePointer = resolvedRef.nodePointer,\n          error = resolvedRef.error;\n      var newLocation = resolved ? new ref_utils_1.Location(document.source, nodePointer) : error instanceof resolve_1.YamlParseError ? new ref_utils_1.Location(error.source, '') : undefined;\n      return {\n        location: newLocation,\n        node: node,\n        error: error\n      };\n    }\n\n    function reportFn(ruleId, severity, opts) {\n      var loc = opts.location ? Array.isArray(opts.location) ? opts.location : [opts.location] : [Object.assign(Object.assign({}, currentLocation), {\n        reportOnKey: false\n      })];\n      ctx.problems.push(Object.assign(Object.assign({\n        ruleId: opts.ruleId || ruleId,\n        severity: opts.forceSeverity || severity\n      }, opts), {\n        suggest: opts.suggest || [],\n        location: loc.map(function (loc) {\n          return Object.assign(Object.assign(Object.assign({}, currentLocation), {\n            reportOnKey: false\n          }), loc);\n        })\n      }));\n    }\n\n    function getVisitorDataFn(ruleId) {\n      ctx.visitorsData[ruleId] = ctx.visitorsData[ruleId] || {};\n      return ctx.visitorsData[ruleId];\n    }\n  }\n}\n\nexports.walkDocument = walkDocument;","map":null,"metadata":{},"sourceType":"script"}