{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.callRef = exports.getValidate = void 0;\n\nconst ref_error_1 = require(\"../../compile/ref_error\");\n\nconst code_1 = require(\"../code\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst names_1 = require(\"../../compile/names\");\n\nconst compile_1 = require(\"../../compile\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst def = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n\n  code(cxt) {\n    const {\n      gen,\n      schema: $ref,\n      it\n    } = cxt;\n    const {\n      baseId,\n      schemaEnv: env,\n      validateName,\n      opts,\n      self\n    } = it;\n    const {\n      root\n    } = env;\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef();\n    const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n    if (schOrEnv === undefined) throw new ref_error_1.default(baseId, $ref);\n    if (schOrEnv instanceof compile_1.SchemaEnv) return callValidate(schOrEnv);\n    return inlineRefSchema(schOrEnv);\n\n    function callRootRef() {\n      if (env === root) return callRef(cxt, validateName, env, env.$async);\n      const rootName = gen.scopeValue(\"root\", {\n        ref: root\n      });\n      return callRef(cxt, codegen_1._`${rootName}.validate`, root, root.$async);\n    }\n\n    function callValidate(sch) {\n      const v = getValidate(cxt, sch);\n      callRef(cxt, v, sch, sch.$async);\n    }\n\n    function inlineRefSchema(sch) {\n      const schName = gen.scopeValue(\"schema\", opts.code.source === true ? {\n        ref: sch,\n        code: codegen_1.stringify(sch)\n      } : {\n        ref: sch\n      });\n      const valid = gen.name(\"valid\");\n      const schCxt = cxt.subschema({\n        schema: sch,\n        dataTypes: [],\n        schemaPath: codegen_1.nil,\n        topSchemaRef: schName,\n        errSchemaPath: $ref\n      }, valid);\n      cxt.mergeEvaluated(schCxt);\n      cxt.ok(valid);\n    }\n  }\n\n};\n\nfunction getValidate(cxt, sch) {\n  const {\n    gen\n  } = cxt;\n  return sch.validate ? gen.scopeValue(\"validate\", {\n    ref: sch.validate\n  }) : codegen_1._`${gen.scopeValue(\"wrapper\", {\n    ref: sch\n  })}.validate`;\n}\n\nexports.getValidate = getValidate;\n\nfunction callRef(cxt, v, sch, $async) {\n  const {\n    gen,\n    it\n  } = cxt;\n  const {\n    allErrors,\n    schemaEnv: env,\n    opts\n  } = it;\n  const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n  if ($async) callAsyncRef();else callSyncRef();\n\n  function callAsyncRef() {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\");\n    const valid = gen.let(\"valid\");\n    gen.try(() => {\n      gen.code(codegen_1._`await ${code_1.callValidateCode(cxt, v, passCxt)}`);\n      addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n\n      if (!allErrors) gen.assign(valid, true);\n    }, e => {\n      gen.if(codegen_1._`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n      addErrorsFrom(e);\n      if (!allErrors) gen.assign(valid, false);\n    });\n    cxt.ok(valid);\n  }\n\n  function callSyncRef() {\n    const visitedNodes = gen.name(\"visitedNodes\");\n    gen.code(codegen_1._`const ${visitedNodes} = visitedNodesForRef.get(${v}) || new Set()`);\n    gen.if(codegen_1._`!${visitedNodes}.has(${cxt.data})`, () => {\n      gen.code(codegen_1._`visitedNodesForRef.set(${v}, ${visitedNodes})`);\n      gen.code(codegen_1._`const dataNode = ${cxt.data}`);\n      gen.code(codegen_1._`${visitedNodes}.add(dataNode)`);\n      const res = cxt.result(code_1.callValidateCode(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n      gen.code(codegen_1._`${visitedNodes}.delete(dataNode)`);\n      return res;\n    });\n  }\n\n  function addErrorsFrom(source) {\n    const errs = codegen_1._`${source}.errors`;\n    gen.assign(names_1.default.vErrors, codegen_1._`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n\n    gen.assign(names_1.default.errors, codegen_1._`${names_1.default.vErrors}.length`);\n  }\n\n  function addEvaluatedFrom(source) {\n    var _a;\n\n    if (!it.opts.unevaluated) return;\n    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated; // TODO refactor\n\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n        }\n      } else {\n        const props = gen.var(\"props\", codegen_1._`${source}.evaluated.props`);\n        it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n      }\n    }\n\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n        }\n      } else {\n        const items = gen.var(\"items\", codegen_1._`${source}.evaluated.items`);\n        it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n      }\n    }\n  }\n}\n\nexports.callRef = callRef;\nexports.default = def;","map":{"version":3,"mappings":";;;;;;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA,MAAMA,GAAG,GAA0B;EACjCC,OAAO,EAAE,MADwB;EAEjCC,UAAU,EAAE,QAFqB;;EAGjCC,IAAI,CAACC,GAAD,EAAgB;IAClB,MAAM;MAACC,GAAD;MAAMC,MAAM,EAAEC,IAAd;MAAoBC;IAApB,IAA0BJ,GAAhC;IACA,MAAM;MAACK,MAAD;MAASC,SAAS,EAAEC,GAApB;MAAyBC,YAAzB;MAAuCC,IAAvC;MAA6CC;IAA7C,IAAqDN,EAA3D;IACA,MAAM;MAACO;IAAD,IAASJ,GAAf;IACA,IAAI,CAACJ,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,IAA1B,KAAmCE,MAAM,KAAKM,IAAI,CAACN,MAAvD,EAA+D,OAAOO,WAAW,EAAlB;IAC/D,MAAMC,QAAQ,GAAGC,qBAAWC,IAAX,CAAgBL,IAAhB,EAAsBC,IAAtB,EAA4BN,MAA5B,EAAoCF,IAApC,CAAjB;IACA,IAAIU,QAAQ,KAAKG,SAAjB,EAA4B,MAAM,IAAIC,mBAAJ,CAAoBZ,MAApB,EAA4BF,IAA5B,CAAN;IAC5B,IAAIU,QAAQ,YAAYC,mBAAxB,EAAmC,OAAOI,YAAY,CAACL,QAAD,CAAnB;IACnC,OAAOM,eAAe,CAACN,QAAD,CAAtB;;IAEA,SAASD,WAAT,GAAoB;MAClB,IAAIL,GAAG,KAAKI,IAAZ,EAAkB,OAAOS,OAAO,CAACpB,GAAD,EAAMQ,YAAN,EAAoBD,GAApB,EAAyBA,GAAG,CAACc,MAA7B,CAAd;MAClB,MAAMC,QAAQ,GAAGrB,GAAG,CAACsB,UAAJ,CAAe,MAAf,EAAuB;QAACC,GAAG,EAAEb;MAAN,CAAvB,CAAjB;MACA,OAAOS,OAAO,CAACpB,GAAD,EAAMyB,WAAC,GAAGH,QAAQ,WAAlB,EAA+BX,IAA/B,EAAqCA,IAAI,CAACU,MAA1C,CAAd;IACD;;IAED,SAASH,YAAT,CAAsBQ,GAAtB,EAAoC;MAClC,MAAMC,CAAC,GAAGC,WAAW,CAAC5B,GAAD,EAAM0B,GAAN,CAArB;MACAN,OAAO,CAACpB,GAAD,EAAM2B,CAAN,EAASD,GAAT,EAAcA,GAAG,CAACL,MAAlB,CAAP;IACD;;IAED,SAASF,eAAT,CAAyBO,GAAzB,EAAuC;MACrC,MAAMG,OAAO,GAAG5B,GAAG,CAACsB,UAAJ,CACd,QADc,EAEdd,IAAI,CAACV,IAAL,CAAU+B,MAAV,KAAqB,IAArB,GAA4B;QAACN,GAAG,EAAEE,GAAN;QAAW3B,IAAI,EAAE0B,oBAAUC,GAAV;MAAjB,CAA5B,GAA+D;QAACF,GAAG,EAAEE;MAAN,CAFjD,CAAhB;MAIA,MAAMK,KAAK,GAAG9B,GAAG,CAAC+B,IAAJ,CAAS,OAAT,CAAd;MACA,MAAMC,MAAM,GAAGjC,GAAG,CAACkC,SAAJ,CACb;QACEhC,MAAM,EAAEwB,GADV;QAEES,SAAS,EAAE,EAFb;QAGEC,UAAU,EAAEX,aAHd;QAIEY,YAAY,EAAER,OAJhB;QAKES,aAAa,EAAEnC;MALjB,CADa,EAQb4B,KARa,CAAf;MAUA/B,GAAG,CAACuC,cAAJ,CAAmBN,MAAnB;MACAjC,GAAG,CAACwC,EAAJ,CAAOT,KAAP;IACD;EACF;;AA3CgC,CAAnC;;AA8CA,SAAgBH,WAAhB,CAA4B5B,GAA5B,EAA6C0B,GAA7C,EAA2D;EACzD,MAAM;IAACzB;EAAD,IAAQD,GAAd;EACA,OAAO0B,GAAG,CAACe,QAAJ,GACHxC,GAAG,CAACsB,UAAJ,CAAe,UAAf,EAA2B;IAACC,GAAG,EAAEE,GAAG,CAACe;EAAV,CAA3B,CADG,GAEHhB,WAAC,GAAGxB,GAAG,CAACsB,UAAJ,CAAe,SAAf,EAA0B;IAACC,GAAG,EAAEE;EAAN,CAA1B,CAAqC,WAF7C;AAGD;;AALDgB;;AAOA,SAAgBtB,OAAhB,CAAwBpB,GAAxB,EAAyC2B,CAAzC,EAAkDD,GAAlD,EAAmEL,MAAnE,EAAmF;EACjF,MAAM;IAACpB,GAAD;IAAMG;EAAN,IAAYJ,GAAlB;EACA,MAAM;IAAC2C,SAAD;IAAYrC,SAAS,EAAEC,GAAvB;IAA4BE;EAA5B,IAAoCL,EAA1C;EACA,MAAMwC,OAAO,GAAGnC,IAAI,CAACoC,WAAL,GAAmBC,gBAAEC,IAArB,GAA4BtB,aAA5C;EACA,IAAIJ,MAAJ,EAAY2B,YAAY,GAAxB,KACKC,WAAW;;EAEhB,SAASD,YAAT,GAAqB;IACnB,IAAI,CAACzC,GAAG,CAACc,MAAT,EAAiB,MAAM,IAAI6B,KAAJ,CAAU,wCAAV,CAAN;IACjB,MAAMnB,KAAK,GAAG9B,GAAG,CAACkD,GAAJ,CAAQ,OAAR,CAAd;IACAlD,GAAG,CAACmD,GAAJ,CACE,MAAK;MACHnD,GAAG,CAACF,IAAJ,CAAS0B,WAAC,SAAS4B,wBAAiBrD,GAAjB,EAAsB2B,CAAtB,EAAyBiB,OAAzB,CAAiC,EAApD;MACAU,gBAAgB,CAAC3B,CAAD,CAAhB,CAFG,CAEiB;;MACpB,IAAI,CAACgB,SAAL,EAAgB1C,GAAG,CAACsD,MAAJ,CAAWxB,KAAX,EAAkB,IAAlB;IACjB,CALH,EAMGyB,CAAD,IAAM;MACJvD,GAAG,CAACwD,EAAJ,CAAOhC,WAAC,KAAK+B,CAAC,eAAepD,EAAE,CAACsD,eAAuB,GAAvD,EAA4D,MAAMzD,GAAG,CAAC0D,KAAJ,CAAUH,CAAV,CAAlE;MACAI,aAAa,CAACJ,CAAD,CAAb;MACA,IAAI,CAACb,SAAL,EAAgB1C,GAAG,CAACsD,MAAJ,CAAWxB,KAAX,EAAkB,KAAlB;IACjB,CAVH;IAYA/B,GAAG,CAACwC,EAAJ,CAAOT,KAAP;EACD;;EAED,SAASkB,WAAT,GAAoB;IAClB,MAAMY,YAAY,GAAS5D,GAAG,CAAC+B,IAAJ,CAAS,cAAT,CAA3B;IACA/B,GAAG,CAACF,IAAJ,CAAS0B,WAAC,SAASoC,YAAY,6BAA6BlC,CAAC,gBAA7D;IACA1B,GAAG,CAACwD,EAAJ,CAAOhC,WAAC,IAAIoC,YAAY,QAAQ7D,GAAG,CAAC8D,IAAI,GAAxC,EAA6C,MAAK;MAChD7D,GAAG,CAACF,IAAJ,CAAS0B,WAAC,0BAA0BE,CAAC,KAAKkC,YAAY,GAAtD;MACA5D,GAAG,CAACF,IAAJ,CAAS0B,WAAC,oBAAoBzB,GAAG,CAAC8D,IAAI,EAAtC;MACA7D,GAAG,CAACF,IAAJ,CAAS0B,WAAC,GAAGoC,YAAY,gBAAzB;MACA,MAAME,GAAG,GAAG/D,GAAG,CAACgE,MAAJ,CACVX,wBAAiBrD,GAAjB,EAAsB2B,CAAtB,EAAyBiB,OAAzB,CADU,EAEV,MAAMU,gBAAgB,CAAC3B,CAAD,CAFZ,EAGV,MAAMiC,aAAa,CAACjC,CAAD,CAHT,CAAZ;MAKA1B,GAAG,CAACF,IAAJ,CAAS0B,WAAC,GAAGoC,YAAY,mBAAzB;MACA,OAAOE,GAAP;IACD,CAXD;EAYD;;EAED,SAASH,aAAT,CAAuB9B,MAAvB,EAAmC;IACjC,MAAMmC,IAAI,GAAGxC,WAAC,GAAGK,MAAM,SAAvB;IACA7B,GAAG,CAACsD,MAAJ,CAAWT,gBAAEoB,OAAb,EAAsBzC,WAAC,GAAGqB,gBAAEoB,OAAO,eAAeD,IAAI,MAAMnB,gBAAEoB,OAAO,WAAWD,IAAI,GAApF,EAFiC,CAEwD;;IACzFhE,GAAG,CAACsD,MAAJ,CAAWT,gBAAEqB,MAAb,EAAqB1C,WAAC,GAAGqB,gBAAEoB,OAAO,SAAlC;EACD;;EAED,SAASZ,gBAAT,CAA0BxB,MAA1B,EAAsC;;;IACpC,IAAI,CAAC1B,EAAE,CAACK,IAAH,CAAQ2D,WAAb,EAA0B;IAC1B,MAAMC,YAAY,GAAG,SAAG,SAAH,OAAG,WAAH,GAAG,MAAH,MAAG,CAAE5B,QAAL,MAAa,IAAb,IAAa6B,aAAb,GAAa,MAAb,GAAaA,GAAEC,SAApC,CAFoC,CAGpC;;IACA,IAAInE,EAAE,CAACoE,KAAH,KAAa,IAAjB,EAAuB;MACrB,IAAIH,YAAY,IAAI,CAACA,YAAY,CAACI,YAAlC,EAAgD;QAC9C,IAAIJ,YAAY,CAACG,KAAb,KAAuBxD,SAA3B,EAAsC;UACpCZ,EAAE,CAACoE,KAAH,GAAWE,sBAAeF,KAAf,CAAqBvE,GAArB,EAA0BoE,YAAY,CAACG,KAAvC,EAA8CpE,EAAE,CAACoE,KAAjD,CAAX;QACD;MACF,CAJD,MAIO;QACL,MAAMA,KAAK,GAAGvE,GAAG,CAAC0E,GAAJ,CAAQ,OAAR,EAAiBlD,WAAC,GAAGK,MAAM,kBAA3B,CAAd;QACA1B,EAAE,CAACoE,KAAH,GAAWE,sBAAeF,KAAf,CAAqBvE,GAArB,EAA0BuE,KAA1B,EAAiCpE,EAAE,CAACoE,KAApC,EAA2C/C,cAA3C,CAAX;MACD;IACF;;IACD,IAAIrB,EAAE,CAACwE,KAAH,KAAa,IAAjB,EAAuB;MACrB,IAAIP,YAAY,IAAI,CAACA,YAAY,CAACQ,YAAlC,EAAgD;QAC9C,IAAIR,YAAY,CAACO,KAAb,KAAuB5D,SAA3B,EAAsC;UACpCZ,EAAE,CAACwE,KAAH,GAAWF,sBAAeE,KAAf,CAAqB3E,GAArB,EAA0BoE,YAAY,CAACO,KAAvC,EAA8CxE,EAAE,CAACwE,KAAjD,CAAX;QACD;MACF,CAJD,MAIO;QACL,MAAMA,KAAK,GAAG3E,GAAG,CAAC0E,GAAJ,CAAQ,OAAR,EAAiBlD,WAAC,GAAGK,MAAM,kBAA3B,CAAd;QACA1B,EAAE,CAACwE,KAAH,GAAWF,sBAAeE,KAAf,CAAqB3E,GAArB,EAA0B2E,KAA1B,EAAiCxE,EAAE,CAACwE,KAApC,EAA2CnD,cAA3C,CAAX;MACD;IACF;EACF;AACF;;AAzEDiB;AA2EAA,kBAAe9C,GAAf","names":["def","keyword","schemaType","code","cxt","gen","schema","$ref","it","baseId","schemaEnv","env","validateName","opts","self","root","callRootRef","schOrEnv","compile_1","call","undefined","ref_error_1","callValidate","inlineRefSchema","callRef","$async","rootName","scopeValue","ref","codegen_1","sch","v","getValidate","schName","source","valid","name","schCxt","subschema","dataTypes","schemaPath","topSchemaRef","errSchemaPath","mergeEvaluated","ok","validate","exports","allErrors","passCxt","passContext","names_1","this","callAsyncRef","callSyncRef","Error","let","try","code_1","addEvaluatedFrom","assign","e","if","ValidationError","throw","addErrorsFrom","visitedNodes","data","res","result","errs","vErrors","errors","unevaluated","schEvaluated","_a","evaluated","props","dynamicProps","util_1","var","items","dynamicItems"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\vocabularies\\core\\ref.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    const visitedNodes: Name = gen.name(\"visitedNodes\")\n    gen.code(_`const ${visitedNodes} = visitedNodesForRef.get(${v}) || new Set()`)\n    gen.if(_`!${visitedNodes}.has(${cxt.data})`, () => {\n      gen.code(_`visitedNodesForRef.set(${v}, ${visitedNodes})`)\n      gen.code(_`const dataNode = ${cxt.data}`)\n      gen.code(_`${visitedNodes}.add(dataNode)`)\n      const res = cxt.result(\n        callValidateCode(cxt, v, passCxt),\n        () => addEvaluatedFrom(v),\n        () => addErrorsFrom(v),\n      )\n      gen.code(_`${visitedNodes}.delete(dataNode)`)\n      return res;\n    });\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}