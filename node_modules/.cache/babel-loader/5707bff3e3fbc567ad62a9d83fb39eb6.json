{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateTuple = void 0;\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst code_1 = require(\"../code\");\n\nconst def = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n\n  code(cxt) {\n    const {\n      schema,\n      it\n    } = cxt;\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema);\n    it.items = true;\n    if (util_1.alwaysValidSchema(it, schema)) return;\n    cxt.ok(code_1.validateArray(cxt));\n  }\n\n};\n\nfunction validateTuple(cxt, extraItems) {\n  let schArr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : cxt.schema;\n  const {\n    gen,\n    parentSchema,\n    data,\n    keyword,\n    it\n  } = cxt;\n  checkStrictTuple(parentSchema);\n\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n  }\n\n  const valid = gen.name(\"valid\");\n  const len = gen.const(\"len\", codegen_1._`${data}.length`);\n  schArr.forEach((sch, i) => {\n    if (util_1.alwaysValidSchema(it, sch)) return;\n    gen.if(codegen_1._`${len} > ${i}`, () => cxt.subschema({\n      keyword,\n      schemaProp: i,\n      dataProp: i\n    }, valid));\n    cxt.ok(valid);\n  });\n\n  function checkStrictTuple(sch) {\n    const {\n      opts,\n      errSchemaPath\n    } = it;\n    const l = schArr.length;\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n      util_1.checkStrictMode(it, msg, opts.strictTuples);\n    }\n  }\n}\n\nexports.validateTuple = validateTuple;\nexports.default = def;","map":{"version":3,"mappings":";;;;;;;AAEA;;AACA;;AACA;;AAEA,MAAMA,GAAG,GAA0B;EACjCC,OAAO,EAAE,OADwB;EAEjCC,IAAI,EAAE,OAF2B;EAGjCC,UAAU,EAAE,CAAC,QAAD,EAAW,OAAX,EAAoB,SAApB,CAHqB;EAIjCC,MAAM,EAAE,aAJyB;;EAKjCC,IAAI,CAACC,GAAD,EAAgB;IAClB,MAAM;MAACC,MAAD;MAASC;IAAT,IAAeF,GAArB;IACA,IAAIG,KAAK,CAACC,OAAN,CAAcH,MAAd,CAAJ,EAA2B,OAAOI,aAAa,CAACL,GAAD,EAAM,iBAAN,EAAyBC,MAAzB,CAApB;IAC3BC,EAAE,CAACI,KAAH,GAAW,IAAX;IACA,IAAIC,yBAAkBL,EAAlB,EAAsBD,MAAtB,CAAJ,EAAmC;IACnCD,GAAG,CAACQ,EAAJ,CAAOC,qBAAcT,GAAd,CAAP;EACD;;AAXgC,CAAnC;;AAcA,SAAgBK,aAAhB,CACEL,GADF,EAEEU,UAFF,EAGkC;EAAA,IAAhCC,MAAgC,uEAAVX,GAAG,CAACC,MAAM;EAEhC,MAAM;IAACW,GAAD;IAAMC,YAAN;IAAoBC,IAApB;IAA0BnB,OAA1B;IAAmCO;EAAnC,IAAyCF,GAA/C;EACAe,gBAAgB,CAACF,YAAD,CAAhB;;EACA,IAAIX,EAAE,CAACc,IAAH,CAAQC,WAAR,IAAuBN,MAAM,CAACO,MAA9B,IAAwChB,EAAE,CAACI,KAAH,KAAa,IAAzD,EAA+D;IAC7DJ,EAAE,CAACI,KAAH,GAAWC,sBAAeD,KAAf,CAAqBM,GAArB,EAA0BD,MAAM,CAACO,MAAjC,EAAyChB,EAAE,CAACI,KAA5C,CAAX;EACD;;EACD,MAAMa,KAAK,GAAGP,GAAG,CAACQ,IAAJ,CAAS,OAAT,CAAd;EACA,MAAMC,GAAG,GAAGT,GAAG,CAACU,KAAJ,CAAU,KAAV,EAAiBC,WAAC,GAAGT,IAAI,SAAzB,CAAZ;EACAH,MAAM,CAACa,OAAP,CAAe,CAACC,GAAD,EAAiBC,CAAjB,KAA8B;IAC3C,IAAInB,yBAAkBL,EAAlB,EAAsBuB,GAAtB,CAAJ,EAAgC;IAChCb,GAAG,CAACe,EAAJ,CAAOJ,WAAC,GAAGF,GAAG,MAAMK,CAAC,EAArB,EAAyB,MACvB1B,GAAG,CAAC4B,SAAJ,CACE;MACEjC,OADF;MAEEkC,UAAU,EAAEH,CAFd;MAGEI,QAAQ,EAAEJ;IAHZ,CADF,EAMEP,KANF,CADF;IAUAnB,GAAG,CAACQ,EAAJ,CAAOW,KAAP;EACD,CAbD;;EAeA,SAASJ,gBAAT,CAA0BU,GAA1B,EAA8C;IAC5C,MAAM;MAACT,IAAD;MAAOe;IAAP,IAAwB7B,EAA9B;IACA,MAAM8B,CAAC,GAAGrB,MAAM,CAACO,MAAjB;IACA,MAAMe,SAAS,GAAGD,CAAC,KAAKP,GAAG,CAACS,QAAV,KAAuBF,CAAC,KAAKP,GAAG,CAACU,QAAV,IAAsBV,GAAG,CAACf,UAAD,CAAH,KAAoB,KAAjE,CAAlB;;IACA,IAAIM,IAAI,CAACoB,YAAL,IAAqB,CAACH,SAA1B,EAAqC;MACnC,MAAMI,GAAG,GAAG,IAAI1C,OAAO,QAAQqC,CAAC,oCAAoCtB,UAAU,4CAA4CqB,aAAa,GAAvI;MACAxB,uBAAgBL,EAAhB,EAAoBmC,GAApB,EAAyBrB,IAAI,CAACoB,YAA9B;IACD;EACF;AACF;;AApCDE;AAsCAA,kBAAe5C,GAAf","names":["def","keyword","type","schemaType","before","code","cxt","schema","it","Array","isArray","validateTuple","items","util_1","ok","code_1","extraItems","schArr","gen","parentSchema","data","checkStrictTuple","opts","unevaluated","length","valid","name","len","const","codegen_1","forEach","sch","i","if","subschema","schemaProp","dataProp","errSchemaPath","l","fullTuple","minItems","maxItems","strictTuples","msg","exports"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\vocabularies\\applicator\\items.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}