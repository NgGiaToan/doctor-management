{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NoEnumTypeMismatch = void 0;\n\nvar utils_1 = require(\"../utils\");\n\nvar NoEnumTypeMismatch = function NoEnumTypeMismatch() {\n  return {\n    Schema: function Schema(schema, _ref) {\n      var report = _ref.report,\n          location = _ref.location;\n      if (schema.enum && !Array.isArray(schema.enum)) return;\n\n      if (schema.enum && schema.type && !Array.isArray(schema.type)) {\n        var typeMismatchedValues = schema.enum.filter(function (item) {\n          return !utils_1.matchesJsonSchemaType(item, schema.type, schema.nullable);\n        });\n\n        var _iterator = _createForOfIteratorHelper(typeMismatchedValues),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var mismatchedValue = _step.value;\n            report({\n              message: \"All values of `enum` field must be of the same type as the `type` field: expected \\\"\".concat(schema.type, \"\\\" but received \\\"\").concat(utils_1.oasTypeOf(mismatchedValue), \"\\\".\"),\n              location: location.child(['enum', schema.enum.indexOf(mismatchedValue)])\n            });\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      if (schema.enum && schema.type && Array.isArray(schema.type)) {\n        var mismatchedResults = {};\n\n        var _iterator2 = _createForOfIteratorHelper(schema.enum),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var enumValue = _step2.value;\n            mismatchedResults[enumValue] = [];\n\n            var _iterator3 = _createForOfIteratorHelper(schema.type),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var type = _step3.value;\n                var valid = utils_1.matchesJsonSchemaType(enumValue, type, schema.nullable);\n                if (!valid) mismatchedResults[enumValue].push(type);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n\n            if (mismatchedResults[enumValue].length !== schema.type.length) delete mismatchedResults[enumValue];\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        ;\n\n        for (var _i = 0, _Object$keys = Object.keys(mismatchedResults); _i < _Object$keys.length; _i++) {\n          var mismatchedKey = _Object$keys[_i];\n          report({\n            message: \"Enum value `\".concat(mismatchedKey, \"` must be of one type. Allowed types: `\").concat(schema.type, \"`.\"),\n            location: location.child(['enum', schema.enum.indexOf(mismatchedKey)])\n          });\n        }\n\n        ;\n      }\n    }\n  };\n};\n\nexports.NoEnumTypeMismatch = NoEnumTypeMismatch;","map":null,"metadata":{},"sourceType":"script"}