{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst types_1 = require(\"../discriminator/types\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        discrError,\n        tagName\n      }\n    } = _ref;\n    return discrError === types_1.DiscrError.Tag ? `tag \"${tagName}\" must be string` : `value of tag \"${tagName}\" must be in oneOf`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        discrError,\n        tag,\n        tagName\n      }\n    } = _ref2;\n    return codegen_1._`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`;\n  }\n};\nconst def = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      schema,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      oneOf\n    } = parentSchema;\n\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\");\n    }\n\n    const tagName = schema.propertyName;\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\");\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\");\n    const valid = gen.let(\"valid\", false);\n    const tag = gen.const(\"tag\", codegen_1._`${data}${codegen_1.getProperty(tagName)}`);\n    gen.if(codegen_1._`typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, {\n      discrError: types_1.DiscrError.Tag,\n      tag,\n      tagName\n    }));\n    cxt.ok(valid);\n\n    function validateMapping() {\n      const mapping = getMapping();\n      gen.if(false);\n\n      for (const tagValue in mapping) {\n        gen.elseIf(codegen_1._`${tag} === ${tagValue}`);\n        gen.assign(valid, applyTagSchema(mapping[tagValue]));\n      }\n\n      gen.else();\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Mapping,\n        tag,\n        tagName\n      });\n      gen.endIf();\n    }\n\n    function applyTagSchema(schemaProp) {\n      const _valid = gen.name(\"valid\");\n\n      const schCxt = cxt.subschema({\n        keyword: \"oneOf\",\n        schemaProp\n      }, _valid);\n      cxt.mergeEvaluated(schCxt, codegen_1.Name);\n      return _valid;\n    }\n\n    function isRef(schema) {\n      return schema.hasOwnProperty('$ref');\n    }\n\n    function getMapping() {\n      var _a;\n\n      const oneOfMapping = {};\n      const topRequired = hasRequired(parentSchema);\n      let tagRequired = true;\n\n      for (let i = 0; i < oneOf.length; i++) {\n        const sch = oneOf[i];\n        let propSch;\n\n        if (isRef(sch)) {\n          // compare the ref pointer to the one in mapping\n          if (schema.mapping) {\n            const {\n              mapping\n            } = schema;\n            let matchedKey;\n            Object.keys(mapping).forEach(function (key) {\n              if (mapping[key] === sch['$ref']) {\n                matchedKey = key;\n              }\n            });\n\n            if (matchedKey) {\n              addMapping(matchedKey, i);\n            } else {\n              throw new Error(`${sch['$ref']} should have corresponding entry in mapping`);\n            }\n          }\n\n          continue;\n        } else {\n          // find if raw schema contains tagName\n          propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n        }\n\n        if (typeof propSch != \"object\") {\n          throw new Error(`discriminator: oneOf schemas must have \"properties/${tagName}\"`);\n        }\n\n        tagRequired = tagRequired && (topRequired || hasRequired(sch));\n        addMappings(propSch, i);\n      }\n\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`);\n      return oneOfMapping;\n\n      function hasRequired(_ref3) {\n        let {\n          required\n        } = _ref3;\n        return Array.isArray(required) && required.includes(tagName);\n      }\n\n      function addMappings(sch, i) {\n        if (sch.const) {\n          addMapping(sch.const, i);\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i);\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n        }\n      }\n\n      function addMapping(tagValue, i) {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n        }\n\n        oneOfMapping[tagValue] = i;\n      }\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","discrError","tagName","types_1","Tag","tag","codegen_1","def","keyword","type","schemaType","code","cxt","gen","data","schema","parentSchema","it","oneOf","opts","discriminator","Error","propertyName","valid","let","const","if","validateMapping","ok","mapping","getMapping","tagValue","elseIf","assign","applyTagSchema","else","Mapping","endIf","schemaProp","_valid","name","schCxt","subschema","mergeEvaluated","isRef","hasOwnProperty","oneOfMapping","topRequired","hasRequired","tagRequired","i","length","sch","propSch","matchedKey","Object","keys","forEach","key","addMapping","properties","_a","addMappings","required","Array","isArray","includes","enum","exports"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\vocabularies\\discriminator\\index.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function isRef(schema: AnySchemaObject) {\n      return schema.hasOwnProperty('$ref');\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        const sch = oneOf[i]\n        let propSch;\n        if (isRef(sch)) {\n          // compare the ref pointer to the one in mapping\n          if (schema.mapping) {\n            const { mapping } = schema\n            let matchedKey;\n            Object.keys(mapping).forEach(function(key) {\n              if (mapping[key] === sch['$ref']) {\n                matchedKey = key;\n              }\n            })\n\n            if (matchedKey) {\n              addMapping(matchedKey, i);\n            } else {\n              throw new Error(`${sch['$ref']} should have corresponding entry in mapping`)\n            }\n          }\n          continue;\n        } else {\n          // find if raw schema contains tagName\n          propSch = sch.properties?.[tagName]\n        }\n        if (typeof propSch != \"object\") {\n          throw new Error(`discriminator: oneOf schemas must have \"properties/${tagName}\"`)\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}