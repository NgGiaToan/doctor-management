{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isOrdered = exports.getIntersectionLength = exports.buildSubjectVisitor = exports.buildVisitorObject = void 0;\n\nconst ref_utils_1 = require(\"../../../ref-utils\");\n\nconst asserts_1 = require(\"./asserts\");\n\nfunction buildVisitorObject(subject, context, subjectVisitor) {\n  if (!context) {\n    return {\n      [subject]: subjectVisitor\n    };\n  }\n\n  let currentVisitorLevel = {};\n  const visitor = currentVisitorLevel;\n\n  for (let index = 0; index < context.length; index++) {\n    const node = context[index];\n\n    if (context.length === index + 1 && node.type === subject) {\n      // Visitors don't work properly for the same type nested nodes, so\n      // as a workaround for that we don't create separate visitor for the last element\n      // which is the same as subject;\n      // we will check includes/excludes it in the last visitor.\n      continue;\n    }\n\n    const matchParentKeys = node.matchParentKeys;\n    const excludeParentKeys = node.excludeParentKeys;\n\n    if (matchParentKeys && excludeParentKeys) {\n      throw new Error(`Both 'matchParentKeys' and 'excludeParentKeys' can't be under one context item`);\n    }\n\n    if (matchParentKeys || excludeParentKeys) {\n      currentVisitorLevel[node.type] = {\n        skip: (_value, key) => {\n          if (matchParentKeys) {\n            return !matchParentKeys.includes(key);\n          }\n\n          if (excludeParentKeys) {\n            return excludeParentKeys.includes(key);\n          }\n        }\n      };\n    } else {\n      currentVisitorLevel[node.type] = {};\n    }\n\n    currentVisitorLevel = currentVisitorLevel[node.type];\n  }\n\n  currentVisitorLevel[subject] = subjectVisitor;\n  return visitor;\n}\n\nexports.buildVisitorObject = buildVisitorObject;\n\nfunction buildSubjectVisitor(properties, asserts, context) {\n  return function (node, _ref) {\n    let {\n      report,\n      location,\n      key,\n      type,\n      resolve\n    } = _ref;\n\n    var _a; // We need to check context's last node if it has the same type as subject node;\n    // if yes - that means we didn't create context's last node visitor,\n    // so we need to handle 'matchParentKeys' and 'excludeParentKeys' conditions here;\n\n\n    if (context) {\n      const lastContextNode = context[context.length - 1];\n\n      if (lastContextNode.type === type.name) {\n        const matchParentKeys = lastContextNode.matchParentKeys;\n        const excludeParentKeys = lastContextNode.excludeParentKeys;\n\n        if (matchParentKeys && !matchParentKeys.includes(key)) {\n          return;\n        }\n\n        if (excludeParentKeys && excludeParentKeys.includes(key)) {\n          return;\n        }\n      }\n    }\n\n    if (properties) {\n      properties = Array.isArray(properties) ? properties : [properties];\n    }\n\n    for (const assert of asserts) {\n      if (properties) {\n        for (const property of properties) {\n          // we can have resolvable scalar so need to resolve value here.\n          const value = ref_utils_1.isRef(node[property]) ? (_a = resolve(node[property])) === null || _a === void 0 ? void 0 : _a.node : node[property];\n          runAssertion(value, assert, location.child(property), report);\n        }\n      } else {\n        runAssertion(Object.keys(node), assert, location.key(), report);\n      }\n    }\n  };\n}\n\nexports.buildSubjectVisitor = buildSubjectVisitor;\n\nfunction getIntersectionLength(keys, properties) {\n  const props = new Set(properties);\n  let count = 0;\n\n  for (const key of keys) {\n    if (props.has(key)) {\n      count++;\n    }\n  }\n\n  return count;\n}\n\nexports.getIntersectionLength = getIntersectionLength;\n\nfunction isOrdered(value, options) {\n  const direction = options.direction || options;\n  const property = options.property;\n\n  for (let i = 1; i < value.length; i++) {\n    let currValue = value[i];\n    let prevVal = value[i - 1];\n\n    if (property) {\n      if (!value[i][property] || !value[i - 1][property]) {\n        return false; // property doesn't exist, so collection is not ordered\n      }\n\n      currValue = value[i][property];\n      prevVal = value[i - 1][property];\n    }\n\n    const result = direction === 'asc' ? currValue >= prevVal : currValue <= prevVal;\n\n    if (!result) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isOrdered = isOrdered;\n\nfunction runAssertion(values, assert, location, report) {\n  const lintResult = asserts_1.asserts[assert.name](values, assert.conditions);\n\n  if (!lintResult) {\n    report({\n      message: assert.message || `The ${assert.assertId} doesn't meet required conditions`,\n      location,\n      forceSeverity: assert.severity,\n      suggest: assert.suggest,\n      ruleId: assert.assertId\n    });\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","isOrdered","getIntersectionLength","buildSubjectVisitor","buildVisitorObject","ref_utils_1","require","asserts_1","subject","context","subjectVisitor","currentVisitorLevel","visitor","index","length","node","type","matchParentKeys","excludeParentKeys","Error","skip","_value","key","includes","properties","asserts","report","location","resolve","_a","lastContextNode","name","Array","isArray","assert","property","isRef","runAssertion","child","keys","props","Set","count","has","options","direction","i","currValue","prevVal","result","values","lintResult","conditions","message","assertId","forceSeverity","severity","suggest","ruleId"],"sources":["C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@redocly/openapi-core/lib/rules/common/assertions/utils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isOrdered = exports.getIntersectionLength = exports.buildSubjectVisitor = exports.buildVisitorObject = void 0;\nconst ref_utils_1 = require(\"../../../ref-utils\");\nconst asserts_1 = require(\"./asserts\");\nfunction buildVisitorObject(subject, context, subjectVisitor) {\n    if (!context) {\n        return { [subject]: subjectVisitor };\n    }\n    let currentVisitorLevel = {};\n    const visitor = currentVisitorLevel;\n    for (let index = 0; index < context.length; index++) {\n        const node = context[index];\n        if (context.length === index + 1 && node.type === subject) {\n            // Visitors don't work properly for the same type nested nodes, so\n            // as a workaround for that we don't create separate visitor for the last element\n            // which is the same as subject;\n            // we will check includes/excludes it in the last visitor.\n            continue;\n        }\n        const matchParentKeys = node.matchParentKeys;\n        const excludeParentKeys = node.excludeParentKeys;\n        if (matchParentKeys && excludeParentKeys) {\n            throw new Error(`Both 'matchParentKeys' and 'excludeParentKeys' can't be under one context item`);\n        }\n        if (matchParentKeys || excludeParentKeys) {\n            currentVisitorLevel[node.type] = {\n                skip: (_value, key) => {\n                    if (matchParentKeys) {\n                        return !matchParentKeys.includes(key);\n                    }\n                    if (excludeParentKeys) {\n                        return excludeParentKeys.includes(key);\n                    }\n                },\n            };\n        }\n        else {\n            currentVisitorLevel[node.type] = {};\n        }\n        currentVisitorLevel = currentVisitorLevel[node.type];\n    }\n    currentVisitorLevel[subject] = subjectVisitor;\n    return visitor;\n}\nexports.buildVisitorObject = buildVisitorObject;\nfunction buildSubjectVisitor(properties, asserts, context) {\n    return function (node, { report, location, key, type, resolve }) {\n        var _a;\n        // We need to check context's last node if it has the same type as subject node;\n        // if yes - that means we didn't create context's last node visitor,\n        // so we need to handle 'matchParentKeys' and 'excludeParentKeys' conditions here;\n        if (context) {\n            const lastContextNode = context[context.length - 1];\n            if (lastContextNode.type === type.name) {\n                const matchParentKeys = lastContextNode.matchParentKeys;\n                const excludeParentKeys = lastContextNode.excludeParentKeys;\n                if (matchParentKeys && !matchParentKeys.includes(key)) {\n                    return;\n                }\n                if (excludeParentKeys && excludeParentKeys.includes(key)) {\n                    return;\n                }\n            }\n        }\n        if (properties) {\n            properties = Array.isArray(properties) ? properties : [properties];\n        }\n        for (const assert of asserts) {\n            if (properties) {\n                for (const property of properties) {\n                    // we can have resolvable scalar so need to resolve value here.\n                    const value = ref_utils_1.isRef(node[property]) ? (_a = resolve(node[property])) === null || _a === void 0 ? void 0 : _a.node : node[property];\n                    runAssertion(value, assert, location.child(property), report);\n                }\n            }\n            else {\n                runAssertion(Object.keys(node), assert, location.key(), report);\n            }\n        }\n    };\n}\nexports.buildSubjectVisitor = buildSubjectVisitor;\nfunction getIntersectionLength(keys, properties) {\n    const props = new Set(properties);\n    let count = 0;\n    for (const key of keys) {\n        if (props.has(key)) {\n            count++;\n        }\n    }\n    return count;\n}\nexports.getIntersectionLength = getIntersectionLength;\nfunction isOrdered(value, options) {\n    const direction = options.direction || options;\n    const property = options.property;\n    for (let i = 1; i < value.length; i++) {\n        let currValue = value[i];\n        let prevVal = value[i - 1];\n        if (property) {\n            if (!value[i][property] || !value[i - 1][property]) {\n                return false; // property doesn't exist, so collection is not ordered\n            }\n            currValue = value[i][property];\n            prevVal = value[i - 1][property];\n        }\n        const result = direction === 'asc' ? currValue >= prevVal : currValue <= prevVal;\n        if (!result) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isOrdered = isOrdered;\nfunction runAssertion(values, assert, location, report) {\n    const lintResult = asserts_1.asserts[assert.name](values, assert.conditions);\n    if (!lintResult) {\n        report({\n            message: assert.message || `The ${assert.assertId} doesn't meet required conditions`,\n            location,\n            forceSeverity: assert.severity,\n            suggest: assert.suggest,\n            ruleId: assert.assertId,\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}