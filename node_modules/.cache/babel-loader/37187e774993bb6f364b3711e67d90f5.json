{"ast":null,"code":"import _slicedToArray from \"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as React from 'react';\nvar LEFT = \"Left\";\nvar RIGHT = \"Right\";\nvar UP = \"Up\";\nvar DOWN = \"Down\";\n/* global document */\n\nvar defaultProps = {\n  delta: 10,\n  preventScrollOnSwipe: false,\n  rotationAngle: 0,\n  trackMouse: false,\n  trackTouch: true,\n  swipeDuration: Infinity,\n  touchEventOptions: {\n    passive: true\n  }\n};\nvar initialState = {\n  first: true,\n  initial: [0, 0],\n  start: 0,\n  swiping: false,\n  xy: [0, 0]\n};\nvar mouseMove = \"mousemove\";\nvar mouseUp = \"mouseup\";\nvar touchEnd = \"touchend\";\nvar touchMove = \"touchmove\";\nvar touchStart = \"touchstart\";\n\nfunction getDirection(absX, absY, deltaX, deltaY) {\n  if (absX > absY) {\n    if (deltaX > 0) {\n      return RIGHT;\n    }\n\n    return LEFT;\n  } else if (deltaY > 0) {\n    return DOWN;\n  }\n\n  return UP;\n}\n\nfunction rotateXYByAngle(pos, angle) {\n  if (angle === 0) return pos;\n  var angleInRadians = Math.PI / 180 * angle;\n  var x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n  var y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n  return [x, y];\n}\n\nfunction getHandlers(set, handlerProps) {\n  var onStart = function onStart(event) {\n    var isTouch = (\"touches\" in event); // if more than a single touch don't track, for now...\n\n    if (isTouch && event.touches.length > 1) return;\n    set(function (state, props) {\n      // setup mouse listeners on document to track swipe since swipe can leave container\n      if (props.trackMouse && !isTouch) {\n        document.addEventListener(mouseMove, onMove);\n        document.addEventListener(mouseUp, onUp);\n      }\n\n      var _ref = isTouch ? event.touches[0] : event,\n          clientX = _ref.clientX,\n          clientY = _ref.clientY;\n\n      var xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      props.onTouchStartOrOnMouseDown && props.onTouchStartOrOnMouseDown({\n        event: event\n      });\n      return Object.assign(Object.assign(Object.assign({}, state), initialState), {\n        initial: xy.slice(),\n        xy: xy,\n        start: event.timeStamp || 0\n      });\n    });\n  };\n\n  var onMove = function onMove(event) {\n    set(function (state, props) {\n      var isTouch = (\"touches\" in event); // Discount a swipe if additional touches are present after\n      // a swipe has started.\n\n      if (isTouch && event.touches.length > 1) {\n        return state;\n      } // if swipe has exceeded duration stop tracking\n\n\n      if (event.timeStamp - state.start > props.swipeDuration) {\n        return state.swiping ? Object.assign(Object.assign({}, state), {\n          swiping: false\n        }) : state;\n      }\n\n      var _ref2 = isTouch ? event.touches[0] : event,\n          clientX = _ref2.clientX,\n          clientY = _ref2.clientY;\n\n      var _rotateXYByAngle = rotateXYByAngle([clientX, clientY], props.rotationAngle),\n          _rotateXYByAngle2 = _slicedToArray(_rotateXYByAngle, 2),\n          x = _rotateXYByAngle2[0],\n          y = _rotateXYByAngle2[1];\n\n      var deltaX = x - state.xy[0];\n      var deltaY = y - state.xy[1];\n      var absX = Math.abs(deltaX);\n      var absY = Math.abs(deltaY);\n      var time = (event.timeStamp || 0) - state.start;\n      var velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n      var vxvy = [deltaX / (time || 1), deltaY / (time || 1)];\n      var dir = getDirection(absX, absY, deltaX, deltaY); // if swipe is under delta and we have not started to track a swipe: skip update\n\n      var delta = typeof props.delta === \"number\" ? props.delta : props.delta[dir.toLowerCase()] || defaultProps.delta;\n      if (absX < delta && absY < delta && !state.swiping) return state;\n      var eventData = {\n        absX: absX,\n        absY: absY,\n        deltaX: deltaX,\n        deltaY: deltaY,\n        dir: dir,\n        event: event,\n        first: state.first,\n        initial: state.initial,\n        velocity: velocity,\n        vxvy: vxvy\n      }; // call onSwipeStart if present and is first swipe event\n\n      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData); // call onSwiping if present\n\n      props.onSwiping && props.onSwiping(eventData); // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n      // so we can call preventDefault if needed\n\n      var cancelablePageSwipe = false;\n\n      if (props.onSwiping || props.onSwiped || props[\"onSwiped\".concat(dir)]) {\n        cancelablePageSwipe = true;\n      }\n\n      if (cancelablePageSwipe && props.preventScrollOnSwipe && props.trackTouch && event.cancelable) {\n        event.preventDefault();\n      }\n\n      return Object.assign(Object.assign({}, state), {\n        // first is now always false\n        first: false,\n        eventData: eventData,\n        swiping: true\n      });\n    });\n  };\n\n  var onEnd = function onEnd(event) {\n    set(function (state, props) {\n      var eventData;\n\n      if (state.swiping && state.eventData) {\n        // if swipe is less than duration fire swiped callbacks\n        if (event.timeStamp - state.start < props.swipeDuration) {\n          eventData = Object.assign(Object.assign({}, state.eventData), {\n            event: event\n          });\n          props.onSwiped && props.onSwiped(eventData);\n          var onSwipedDir = props[\"onSwiped\".concat(eventData.dir)];\n          onSwipedDir && onSwipedDir(eventData);\n        }\n      } else {\n        props.onTap && props.onTap({\n          event: event\n        });\n      }\n\n      props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({\n        event: event\n      });\n      return Object.assign(Object.assign(Object.assign({}, state), initialState), {\n        eventData: eventData\n      });\n    });\n  };\n\n  var cleanUpMouse = function cleanUpMouse() {\n    // safe to just call removeEventListener\n    document.removeEventListener(mouseMove, onMove);\n    document.removeEventListener(mouseUp, onUp);\n  };\n\n  var onUp = function onUp(e) {\n    cleanUpMouse();\n    onEnd(e);\n  };\n  /**\n   * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n   * - true => { passive: false }\n   * - false => { passive: true } // Default\n   *\n   * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n   *\n   * props.touchEventOptions can also be set for all touch event listeners,\n   * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n   * supersede and force passive to false.\n   *\n   */\n\n\n  var attachTouch = function attachTouch(el, props) {\n    var cleanup = function cleanup() {};\n\n    if (el && el.addEventListener) {\n      var baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions); // attach touch event listeners and handlers\n\n      var tls = [[touchStart, onStart, baseOptions], // preventScrollOnSwipe option supersedes touchEventOptions.passive\n      [touchMove, onMove, Object.assign(Object.assign({}, baseOptions), props.preventScrollOnSwipe ? {\n        passive: false\n      } : {})], [touchEnd, onEnd, baseOptions]];\n      tls.forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 3),\n            e = _ref4[0],\n            h = _ref4[1],\n            o = _ref4[2];\n\n        return el.addEventListener(e, h, o);\n      }); // return properly scoped cleanup method for removing listeners, options not required\n\n      cleanup = function cleanup() {\n        return tls.forEach(function (_ref5) {\n          var _ref6 = _slicedToArray(_ref5, 2),\n              e = _ref6[0],\n              h = _ref6[1];\n\n          return el.removeEventListener(e, h);\n        });\n      };\n    }\n\n    return cleanup;\n  };\n\n  var onRef = function onRef(el) {\n    // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n    // ignore null here\n    if (el === null) return;\n    set(function (state, props) {\n      // if the same DOM el as previous just return state\n      if (state.el === el) return state;\n      var addState = {}; // if new DOM el clean up old DOM and reset cleanUpTouch\n\n      if (state.el && state.el !== el && state.cleanUpTouch) {\n        state.cleanUpTouch();\n        addState.cleanUpTouch = void 0;\n      } // only attach if we want to track touch\n\n\n      if (props.trackTouch && el) {\n        addState.cleanUpTouch = attachTouch(el, props);\n      } // store event attached DOM el for comparison, clean up, and re-attachment\n\n\n      return Object.assign(Object.assign(Object.assign({}, state), {\n        el: el\n      }), addState);\n    });\n  }; // set ref callback to attach touch event listeners\n\n\n  var output = {\n    ref: onRef\n  }; // if track mouse attach mouse down listener\n\n  if (handlerProps.trackMouse) {\n    output.onMouseDown = onStart;\n  }\n\n  return [output, attachTouch];\n}\n\nfunction updateTransientState(state, props, previousProps, attachTouch) {\n  // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n  if (!props.trackTouch || !state.el) {\n    if (state.cleanUpTouch) {\n      state.cleanUpTouch();\n    }\n\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: undefined\n    });\n  } // trackTouch is on, so if there are no handlers attached, attach them and exit\n\n\n  if (!state.cleanUpTouch) {\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: attachTouch(state.el, props)\n    });\n  } // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n  // remove and reattach handlers (this is required to update the passive option when attaching\n  // the handlers)\n\n\n  if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe || props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {\n    state.cleanUpTouch();\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: attachTouch(state.el, props)\n    });\n  }\n\n  return state;\n}\n\nfunction useSwipeable(options) {\n  var trackMouse = options.trackMouse;\n  var transientState = React.useRef(Object.assign({}, initialState));\n  var transientProps = React.useRef(Object.assign({}, defaultProps)); // track previous rendered props\n\n  var previousProps = React.useRef(Object.assign({}, transientProps.current));\n  previousProps.current = Object.assign({}, transientProps.current); // update current render props & defaults\n\n  transientProps.current = Object.assign(Object.assign({}, defaultProps), options); // Force defaults for config properties\n\n  var defaultKey;\n\n  for (defaultKey in defaultProps) {\n    if (transientProps.current[defaultKey] === void 0) {\n      transientProps.current[defaultKey] = defaultProps[defaultKey];\n    }\n  }\n\n  var _React$useMemo = React.useMemo(function () {\n    return getHandlers(function (stateSetter) {\n      return transientState.current = stateSetter(transientState.current, transientProps.current);\n    }, {\n      trackMouse: trackMouse\n    });\n  }, [trackMouse]),\n      _React$useMemo2 = _slicedToArray(_React$useMemo, 2),\n      handlers = _React$useMemo2[0],\n      attachTouch = _React$useMemo2[1];\n\n  transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);\n  return handlers;\n}\n\nexport { DOWN, LEFT, RIGHT, UP, useSwipeable }; //# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module"}