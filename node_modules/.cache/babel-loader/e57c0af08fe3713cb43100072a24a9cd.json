{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst code_1 = require(\"../code\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst names_1 = require(\"../../compile/names\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: \"must NOT have additional properties\",\n  params: _ref => {\n    let {\n      params\n    } = _ref;\n    return codegen_1._`{additionalProperty: ${params.additionalProperty}}`;\n  }\n};\nconst def = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      parentSchema,\n      data,\n      errsCount,\n      it\n    } = cxt;\n    const {\n      schema = it.opts.defaultAdditionalProperties\n    } = cxt;\n    /* istanbul ignore if */\n\n    if (!errsCount) throw new Error(\"ajv implementation error\");\n    const {\n      allErrors,\n      opts\n    } = it;\n    it.props = true;\n    if (opts.removeAdditional !== \"all\" && util_1.alwaysValidSchema(it, schema)) return;\n    const props = code_1.allSchemaProperties(parentSchema.properties);\n    const patProps = code_1.allSchemaProperties(parentSchema.patternProperties);\n    checkAdditionalProperties();\n    cxt.ok(codegen_1._`${errsCount} === ${names_1.default.errors}`);\n\n    function checkAdditionalProperties() {\n      gen.forIn(\"key\", data, key => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key);else gen.if(isAdditional(key), () => additionalPropertyCode(key));\n      });\n    }\n\n    function isAdditional(key) {\n      let definedProp;\n\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = util_1.schemaRefOrVal(it, parentSchema.properties, \"properties\");\n        definedProp = code_1.isOwnProperty(gen, propsSchema, key);\n      } else if (props.length) {\n        definedProp = codegen_1.or(...props.map(p => codegen_1._`${key} === ${p}`));\n      } else {\n        definedProp = codegen_1.nil;\n      }\n\n      if (patProps.length) {\n        definedProp = codegen_1.or(definedProp, ...patProps.map(p => codegen_1._`${code_1.usePattern(cxt, p)}.test(${key})`));\n      }\n\n      return codegen_1.not(definedProp);\n    }\n\n    function deleteAdditional(key) {\n      gen.code(codegen_1._`delete ${data}[${key}]`);\n    }\n\n    function additionalPropertyCode(key) {\n      if (opts.removeAdditional === \"all\" || opts.removeAdditional && schema === false) {\n        deleteAdditional(key);\n        return;\n      }\n\n      if (schema === false) {\n        cxt.setParams({\n          additionalProperty: key\n        });\n        cxt.error();\n        if (!allErrors) gen.break();\n        return;\n      }\n\n      if (typeof schema == \"object\" && !util_1.alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\");\n\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false);\n          gen.if(codegen_1.not(valid), () => {\n            cxt.reset();\n            deleteAdditional(key);\n          });\n        } else {\n          applyAdditionalSchema(key, valid);\n          if (!allErrors) gen.if(codegen_1.not(valid), () => gen.break());\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key, valid, errors) {\n      const subschema = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: util_1.Type.Str\n      };\n\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false\n        });\n      }\n\n      cxt.subschema(subschema, valid);\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","codegen_1","additionalProperty","def","keyword","type","schemaType","allowUndefined","trackErrors","code","cxt","gen","parentSchema","data","errsCount","it","schema","opts","defaultAdditionalProperties","Error","allErrors","props","removeAdditional","util_1","code_1","properties","patProps","patternProperties","checkAdditionalProperties","ok","names_1","errors","forIn","key","length","additionalPropertyCode","if","isAdditional","definedProp","propsSchema","map","p","deleteAdditional","setParams","break","valid","name","applyAdditionalSchema","reset","subschema","dataProp","dataPropType","Str","Object","assign","compositeRule","createErrors","exports"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\vocabularies\\applicator\\additionalProperties.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, parentSchema, data, errsCount, it} = cxt\n    const { schema = it.opts.defaultAdditionalProperties } = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}