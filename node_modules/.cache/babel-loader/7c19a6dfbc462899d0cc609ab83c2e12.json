{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asserts = exports.runOnValuesSet = exports.runOnKeysSet = void 0;\n\nvar utils_1 = require(\"./utils\");\n\nexports.runOnKeysSet = new Set(['mutuallyExclusive', 'mutuallyRequired', 'enum', 'pattern', 'minLength', 'maxLength', 'casing', 'sortOrder', 'disallowed', 'required']);\nexports.runOnValuesSet = new Set(['pattern', 'enum', 'defined', 'undefined', 'nonEmpty', 'minLength', 'maxLength', 'casing', 'sortOrder']);\nexports.asserts = {\n  pattern: function pattern(value, condition) {\n    if (typeof value === 'undefined') return true; // property doesn't exist, no need to lint it with this assert\n\n    var values = typeof value === 'string' ? [value] : value;\n    var regexOptions = condition.match(/(\\b\\/\\b)(.+)/g) || ['/'];\n    condition = condition.slice(1).replace(regexOptions[0], '');\n    var regx = new RegExp(condition, regexOptions[0].slice(1));\n\n    var _iterator = _createForOfIteratorHelper(values),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _val = _step.value;\n\n        if (!_val.match(regx)) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return true;\n  },\n  enum: function _enum(value, condition) {\n    if (typeof value === 'undefined') return true; // property doesn't exist, no need to lint it with this assert\n\n    var values = typeof value === 'string' ? [value] : value;\n\n    var _iterator2 = _createForOfIteratorHelper(values),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _val = _step2.value;\n\n        if (!condition.includes(_val)) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return true;\n  },\n  defined: function defined(value) {\n    var condition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var isDefined = typeof value !== 'undefined';\n    return condition ? isDefined : !isDefined;\n  },\n  required: function required(value, keys) {\n    var _iterator3 = _createForOfIteratorHelper(keys),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var requiredKey = _step3.value;\n\n        if (!value.includes(requiredKey)) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return true;\n  },\n  disallowed: function disallowed(value, condition) {\n    if (typeof value === 'undefined') return true; // property doesn't exist, no need to lint it with this assert\n\n    var values = typeof value === 'string' ? [value] : value;\n\n    var _iterator4 = _createForOfIteratorHelper(values),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _val = _step4.value;\n\n        if (condition.includes(_val)) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    return true;\n  },\n  undefined: function undefined(value) {\n    var condition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var isUndefined = typeof value === 'undefined';\n    return condition ? isUndefined : !isUndefined;\n  },\n  nonEmpty: function nonEmpty(value) {\n    var condition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var isEmpty = typeof value === 'undefined' || value === null || value === '';\n    return condition ? !isEmpty : isEmpty;\n  },\n  minLength: function minLength(value, condition) {\n    if (typeof value === 'undefined') return true; // property doesn't exist, no need to lint it with this assert\n\n    return value.length >= condition;\n  },\n  maxLength: function maxLength(value, condition) {\n    if (typeof value === 'undefined') return true; // property doesn't exist, no need to lint it with this assert\n\n    return value.length <= condition;\n  },\n  casing: function casing(value, condition) {\n    if (typeof value === 'undefined') return true; // property doesn't exist, no need to lint it with this assert\n\n    var values = typeof value === 'string' ? [value] : value;\n\n    var _iterator5 = _createForOfIteratorHelper(values),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var _val = _step5.value;\n        var matchCase = false;\n\n        switch (condition) {\n          case 'camelCase':\n            matchCase = !!_val.match(/^[a-z][a-zA-Z0-9]+$/g);\n            break;\n\n          case 'kebab-case':\n            matchCase = !!_val.match(/^([a-z][a-z0-9]*)(-[a-z0-9]+)*$/g);\n            break;\n\n          case 'snake_case':\n            matchCase = !!_val.match(/^([a-z][a-z0-9]*)(_[a-z0-9]+)*$/g);\n            break;\n\n          case 'PascalCase':\n            matchCase = !!_val.match(/^[A-Z][a-zA-Z0-9]+$/g);\n            break;\n\n          case 'MACRO_CASE':\n            matchCase = !!_val.match(/^([A-Z][A-Z0-9]*)(_[A-Z0-9]+)*$/g);\n            break;\n\n          case 'COBOL-CASE':\n            matchCase = !!_val.match(/^([A-Z][A-Z0-9]*)(-[A-Z0-9]+)*$/g);\n            break;\n\n          case 'flatcase':\n            matchCase = !!_val.match(/^[a-z][a-z0-9]+$/g);\n            break;\n        }\n\n        if (!matchCase) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    return true;\n  },\n  sortOrder: function sortOrder(value, condition) {\n    if (typeof value === 'undefined') return true;\n    return utils_1.isOrdered(value, condition);\n  },\n  mutuallyExclusive: function mutuallyExclusive(value, condition) {\n    return utils_1.getIntersectionLength(value, condition) < 2;\n  },\n  mutuallyRequired: function mutuallyRequired(value, condition) {\n    return utils_1.getIntersectionLength(value, condition) > 0 ? utils_1.getIntersectionLength(value, condition) === condition.length : true;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}