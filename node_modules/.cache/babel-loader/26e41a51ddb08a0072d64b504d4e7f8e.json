{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\n\nconst codegen_1 = require(\"./codegen\");\n\nconst code_1 = require(\"./codegen/code\"); // TODO refactor to use Set\n\n\nfunction toHash(arr) {\n  const hash = {};\n\n  for (const item of arr) hash[item] = true;\n\n  return hash;\n}\n\nexports.toHash = toHash;\n\nfunction alwaysValidSchema(it, schema) {\n  if (typeof schema == \"boolean\") return schema;\n  if (Object.keys(schema).length === 0) return true;\n  checkUnknownRules(it, schema);\n  return !schemaHasRules(schema, it.self.RULES.all);\n}\n\nexports.alwaysValidSchema = alwaysValidSchema;\n\nfunction checkUnknownRules(it) {\n  let schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : it.schema;\n  const {\n    opts,\n    self\n  } = it;\n  if (!opts.strictSchema) return;\n  if (typeof schema === \"boolean\") return;\n  const rules = self.RULES.keywords;\n\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`);\n  }\n}\n\nexports.checkUnknownRules = checkUnknownRules;\n\nfunction schemaHasRules(schema, rules) {\n  if (typeof schema == \"boolean\") return !schema;\n\n  for (const key in schema) if (rules[key]) return true;\n\n  return false;\n}\n\nexports.schemaHasRules = schemaHasRules;\n\nfunction schemaHasRulesButRef(schema, RULES) {\n  if (typeof schema == \"boolean\") return !schema;\n\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true;\n\n  return false;\n}\n\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\n\nfunction schemaRefOrVal(_ref, schema, keyword, $data) {\n  let {\n    topSchemaRef,\n    schemaPath\n  } = _ref;\n\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema;\n    if (typeof schema == \"string\") return codegen_1._`${schema}`;\n  }\n\n  return codegen_1._`${topSchemaRef}${schemaPath}${codegen_1.getProperty(keyword)}`;\n}\n\nexports.schemaRefOrVal = schemaRefOrVal;\n\nfunction unescapeFragment(str) {\n  return unescapeJsonPointer(decodeURIComponent(str));\n}\n\nexports.unescapeFragment = unescapeFragment;\n\nfunction escapeFragment(str) {\n  return encodeURIComponent(escapeJsonPointer(str));\n}\n\nexports.escapeFragment = escapeFragment;\n\nfunction escapeJsonPointer(str) {\n  if (typeof str == \"number\") return `${str}`;\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n\nexports.escapeJsonPointer = escapeJsonPointer;\n\nfunction unescapeJsonPointer(str) {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n\nexports.unescapeJsonPointer = unescapeJsonPointer;\n\nfunction eachItem(xs, f) {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x);\n  } else {\n    f(xs);\n  }\n}\n\nexports.eachItem = eachItem;\n\nfunction makeMergeEvaluated(_ref2) {\n  let {\n    mergeNames,\n    mergeToName,\n    mergeValues,\n    resultToName\n  } = _ref2;\n  return (gen, from, to, toName) => {\n    const res = to === undefined ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);\n    return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n  };\n}\n\nexports.mergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) => gen.if(codegen_1._`${to} !== true && ${from} !== undefined`, () => {\n      gen.if(codegen_1._`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, codegen_1._`${to} || {}`).code(codegen_1._`Object.assign(${to}, ${from})`));\n    }),\n    mergeToName: (gen, from, to) => gen.if(codegen_1._`${to} !== true`, () => {\n      if (from === true) {\n        gen.assign(to, true);\n      } else {\n        gen.assign(to, codegen_1._`${to} || {}`);\n        setEvaluated(gen, to, from);\n      }\n    }),\n    mergeValues: (from, to) => from === true ? true : { ...from,\n      ...to\n    },\n    resultToName: evaluatedPropsToName\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) => gen.if(codegen_1._`${to} !== true && ${from} !== undefined`, () => gen.assign(to, codegen_1._`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n    mergeToName: (gen, from, to) => gen.if(codegen_1._`${to} !== true`, () => gen.assign(to, from === true ? true : codegen_1._`${to} > ${from} ? ${to} : ${from}`)),\n    mergeValues: (from, to) => from === true ? true : Math.max(from, to),\n    resultToName: (gen, items) => gen.var(\"items\", items)\n  })\n};\n\nfunction evaluatedPropsToName(gen, ps) {\n  if (ps === true) return gen.var(\"props\", true);\n  const props = gen.var(\"props\", codegen_1._`{}`);\n  if (ps !== undefined) setEvaluated(gen, props, ps);\n  return props;\n}\n\nexports.evaluatedPropsToName = evaluatedPropsToName;\n\nfunction setEvaluated(gen, props, ps) {\n  Object.keys(ps).forEach(p => gen.assign(codegen_1._`${props}${codegen_1.getProperty(p)}`, true));\n}\n\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\n\nfunction useFunc(gen, f) {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))\n  });\n}\n\nexports.useFunc = useFunc;\nvar Type;\n\n(function (Type) {\n  Type[Type[\"Num\"] = 0] = \"Num\";\n  Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type = exports.Type || (exports.Type = {}));\n\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n  // let path\n  if (dataProp instanceof codegen_1.Name) {\n    const isNumber = dataPropType === Type.Num;\n    return jsPropertySyntax ? isNumber ? codegen_1._`\"[\" + ${dataProp} + \"]\"` : codegen_1._`\"['\" + ${dataProp} + \"']\"` : isNumber ? codegen_1._`\"/\" + ${dataProp}` : codegen_1._`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n  }\n\n  return jsPropertySyntax ? codegen_1.getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\n\nexports.getErrorPath = getErrorPath;\n\nfunction checkStrictMode(it, msg) {\n  let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : it.opts.strictSchema;\n  if (!mode) return;\n  msg = `strict mode: ${msg}`;\n  if (mode === true) throw new Error(msg);\n  it.self.logger.warn(msg);\n}\n\nexports.checkStrictMode = checkStrictMode;","map":{"version":3,"mappings":"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","names":["toHash","arr","hash","item","exports","alwaysValidSchema","it","schema","Object","keys","length","checkUnknownRules","schemaHasRules","self","RULES","all","opts","strictSchema","rules","keywords","key","checkStrictMode","schemaHasRulesButRef","schemaRefOrVal","keyword","$data","topSchemaRef","schemaPath","codegen_1","unescapeFragment","str","unescapeJsonPointer","decodeURIComponent","escapeFragment","encodeURIComponent","escapeJsonPointer","replace","eachItem","xs","f","Array","isArray","x","makeMergeEvaluated","mergeNames","mergeToName","mergeValues","resultToName","gen","from","to","toName","res","undefined","props","if","assign","code","setEvaluated","evaluatedPropsToName","items","Math","max","var","ps","forEach","p","snippets","useFunc","scopeValue","ref","code_1","Type","getErrorPath","dataProp","dataPropType","jsPropertySyntax","isNumber","Num","toString","msg","mode","Error","logger","warn"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\compile\\util.ts"],"sourcesContent":["import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n"]},"metadata":{},"sourceType":"script"}