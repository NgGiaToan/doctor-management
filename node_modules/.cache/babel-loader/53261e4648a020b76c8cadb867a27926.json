{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Assertions = void 0;\n\nvar asserts_1 = require(\"./asserts\");\n\nvar utils_1 = require(\"./utils\");\n\nvar Assertions = function Assertions(opts) {\n  var visitors = []; // As 'Assertions' has an array of asserts,\n  // that array spreads into an 'opts' object on init rules phase here\n  // https://github.com/Redocly/redocly-cli/blob/master/packages/core/src/config/config.ts#L311\n  // that is why we need to iterate through 'opts' values;\n  // before - filter only object 'opts' values\n\n  var assertions = Object.values(opts).filter(function (opt) {\n    return typeof opt === 'object' && opt !== null;\n  });\n\n  var _iterator = _createForOfIteratorHelper(assertions.entries()),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var _step$value = _slicedToArray(_step.value, 2),\n          index = _step$value[0],\n          assertion = _step$value[1];\n\n      var assertId = assertion.assertionId && \"\".concat(assertion.assertionId, \" assertion\") || \"assertion #\".concat(index + 1);\n\n      if (!assertion.subject) {\n        throw new Error(\"\".concat(assertId, \": 'subject' is required\"));\n      }\n\n      var subjects = Array.isArray(assertion.subject) ? assertion.subject : [assertion.subject];\n      var assertsToApply = Object.keys(asserts_1.asserts).filter(function (assertName) {\n        return assertion[assertName] !== undefined;\n      }).map(function (assertName) {\n        return {\n          assertId: assertId,\n          name: assertName,\n          conditions: assertion[assertName],\n          message: assertion.message,\n          severity: assertion.severity || 'error',\n          suggest: assertion.suggest || [],\n          runsOnKeys: asserts_1.runOnKeysSet.has(assertName),\n          runsOnValues: asserts_1.runOnValuesSet.has(assertName)\n        };\n      });\n      var shouldRunOnKeys = assertsToApply.find(function (assert) {\n        return assert.runsOnKeys && !assert.runsOnValues;\n      });\n      var shouldRunOnValues = assertsToApply.find(function (assert) {\n        return assert.runsOnValues && !assert.runsOnKeys;\n      });\n\n      if (shouldRunOnValues && !assertion.property) {\n        throw new Error(\"\".concat(shouldRunOnValues.name, \" can't be used on all keys. Please provide a single property.\"));\n      }\n\n      if (shouldRunOnKeys && assertion.property) {\n        throw new Error(\"\".concat(shouldRunOnKeys.name, \" can't be used on a single property. Please use 'property'.\"));\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(subjects),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var subject = _step2.value;\n          var subjectVisitor = utils_1.buildSubjectVisitor(assertion.property, assertsToApply, assertion.context);\n          var visitorObject = utils_1.buildVisitorObject(subject, assertion.context, subjectVisitor);\n          visitors.push(visitorObject);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return visitors;\n};\n\nexports.Assertions = Assertions;","map":null,"metadata":{},"sourceType":"script"}