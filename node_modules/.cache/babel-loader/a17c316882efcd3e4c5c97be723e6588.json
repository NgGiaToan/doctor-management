{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\n\nconst codegen_1 = require(\"../codegen\");\n\nconst util_1 = require(\"../util\");\n\nfunction getSubschema(it, _ref) {\n  let {\n    keyword,\n    schemaProp,\n    schema,\n    schemaPath,\n    errSchemaPath,\n    topSchemaRef\n  } = _ref;\n\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword];\n    return schemaProp === undefined ? {\n      schema: sch,\n      schemaPath: codegen_1._`${it.schemaPath}${codegen_1.getProperty(keyword)}`,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`\n    } : {\n      schema: sch[schemaProp],\n      schemaPath: codegen_1._`${it.schemaPath}${codegen_1.getProperty(keyword)}${codegen_1.getProperty(schemaProp)}`,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}/${util_1.escapeFragment(schemaProp)}`\n    };\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n    }\n\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath\n    };\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\n\nexports.getSubschema = getSubschema;\n\nfunction extendSubschemaData(subschema, it, _ref2) {\n  let {\n    dataProp,\n    dataPropType: dpType,\n    data,\n    dataTypes,\n    propertyName\n  } = _ref2;\n\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n  }\n\n  const {\n    gen\n  } = it;\n\n  if (dataProp !== undefined) {\n    const {\n      errorPath,\n      dataPathArr,\n      opts\n    } = it;\n    const nextData = gen.let(\"data\", codegen_1._`${it.data}${codegen_1.getProperty(dataProp)}`, true);\n    dataContextProps(nextData);\n    subschema.errorPath = codegen_1.str`${errorPath}${util_1.getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`;\n    subschema.parentDataProperty = codegen_1._`${dataProp}`;\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n\n    dataContextProps(nextData);\n    if (propertyName !== undefined) subschema.propertyName = propertyName; // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes;\n\n  function dataContextProps(_nextData) {\n    subschema.data = _nextData;\n    subschema.dataLevel = it.dataLevel + 1;\n    subschema.dataTypes = [];\n    it.definedProperties = new Set();\n    subschema.parentData = it.data;\n    subschema.dataNames = [...it.dataNames, _nextData];\n  }\n}\n\nexports.extendSubschemaData = extendSubschemaData;\n\nfunction extendSubschemaMode(subschema, _ref3) {\n  let {\n    jtdDiscriminator,\n    jtdMetadata,\n    compositeRule,\n    createErrors,\n    allErrors\n  } = _ref3;\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule;\n  if (createErrors !== undefined) subschema.createErrors = createErrors;\n  if (allErrors !== undefined) subschema.allErrors = allErrors;\n  subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n\n  subschema.jtdMetadata = jtdMetadata; // not inherited\n}\n\nexports.extendSubschemaMode = extendSubschemaMode;","map":{"version":3,"mappings":"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","names":["getSubschema","it","keyword","schemaProp","schema","schemaPath","errSchemaPath","topSchemaRef","undefined","Error","sch","codegen_1","util_1","exports","extendSubschemaData","subschema","dataProp","dataPropType","dpType","data","dataTypes","propertyName","gen","errorPath","dataPathArr","opts","nextData","let","dataContextProps","jsPropertySyntax","parentDataProperty","_nextData","dataLevel","definedProperties","Set","parentData","dataNames","extendSubschemaMode","jtdDiscriminator","jtdMetadata","compositeRule","createErrors","allErrors"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\compile\\validate\\subschema.ts"],"sourcesContent":["import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n"]},"metadata":{},"sourceType":"script"}