{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\giato\\\\Downloads\\\\Workspace\\\\.Net\\\\api\\\\doctor-management-fe\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapTypeToComponent = exports.bundleDocument = exports.bundle = exports.OasVersion = void 0;\n\nvar isEqual = require(\"lodash.isequal\");\n\nvar resolve_1 = require(\"./resolve\");\n\nvar visitors_1 = require(\"./visitors\");\n\nvar oas3_1 = require(\"./types/oas3\");\n\nvar oas2_1 = require(\"./types/oas2\");\n\nvar oas3_1_1 = require(\"./types/oas3_1\");\n\nvar types_1 = require(\"./types\");\n\nvar walk_1 = require(\"./walk\");\n\nvar oas_types_1 = require(\"./oas-types\");\n\nvar ref_utils_1 = require(\"./ref-utils\");\n\nvar rules_1 = require(\"./config/rules\");\n\nvar no_unresolved_refs_1 = require(\"./rules/no-unresolved-refs\");\n\nvar utils_1 = require(\"./utils\");\n\nvar redocly_1 = require(\"./redocly\");\n\nvar remove_unused_components_1 = require(\"./rules/oas2/remove-unused-components\");\n\nvar remove_unused_components_2 = require(\"./rules/oas3/remove-unused-components\");\n\nvar OasVersion;\n\n(function (OasVersion) {\n  OasVersion[\"Version2\"] = \"oas2\";\n  OasVersion[\"Version3_0\"] = \"oas3_0\";\n  OasVersion[\"Version3_1\"] = \"oas3_1\";\n})(OasVersion = exports.OasVersion || (exports.OasVersion = {}));\n\nfunction bundle(opts) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var ref, doc, _opts$externalRefReso, externalRefResolver, _opts$base, base, document;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            ref = opts.ref, doc = opts.doc, _opts$externalRefReso = opts.externalRefResolver, externalRefResolver = _opts$externalRefReso === void 0 ? new resolve_1.BaseResolver(opts.config.resolve) : _opts$externalRefReso, _opts$base = opts.base, base = _opts$base === void 0 ? null : _opts$base;\n\n            if (ref || doc) {\n              _context.next = 3;\n              break;\n            }\n\n            throw new Error('Document or reference is required.\\n');\n\n          case 3:\n            if (!(doc !== undefined)) {\n              _context.next = 7;\n              break;\n            }\n\n            _context.t0 = doc;\n            _context.next = 10;\n            break;\n\n          case 7:\n            _context.next = 9;\n            return externalRefResolver.resolveDocument(base, ref, true);\n\n          case 9:\n            _context.t0 = _context.sent;\n\n          case 10:\n            document = _context.t0;\n\n            if (!(document instanceof Error)) {\n              _context.next = 13;\n              break;\n            }\n\n            throw document;\n\n          case 13:\n            return _context.abrupt(\"return\", bundleDocument(Object.assign(Object.assign({\n              document: document\n            }, opts), {\n              config: opts.config.lint,\n              externalRefResolver: externalRefResolver\n            })));\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.bundle = bundle;\n\nfunction bundleDocument(opts) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var document, config, customTypes, externalRefResolver, _opts$dereference, dereference, _opts$skipRedoclyRegi, skipRedoclyRegistryRefs, _opts$removeUnusedCom, removeUnusedComponents, oasVersion, oasMajorVersion, rules, types, preprocessors, decorators, ctx, resolvedRefMap, bundleVisitor;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            document = opts.document, config = opts.config, customTypes = opts.customTypes, externalRefResolver = opts.externalRefResolver, _opts$dereference = opts.dereference, dereference = _opts$dereference === void 0 ? false : _opts$dereference, _opts$skipRedoclyRegi = opts.skipRedoclyRegistryRefs, skipRedoclyRegistryRefs = _opts$skipRedoclyRegi === void 0 ? false : _opts$skipRedoclyRegi, _opts$removeUnusedCom = opts.removeUnusedComponents, removeUnusedComponents = _opts$removeUnusedCom === void 0 ? false : _opts$removeUnusedCom;\n            oasVersion = oas_types_1.detectOpenAPI(document.parsed);\n            oasMajorVersion = oas_types_1.openAPIMajor(oasVersion);\n            rules = config.getRulesForOasVersion(oasMajorVersion);\n            types = types_1.normalizeTypes(config.extendTypes((customTypes !== null && customTypes !== void 0 ? customTypes : oasMajorVersion === oas_types_1.OasMajorVersion.Version3) ? oasVersion === OasVersion.Version3_1 ? oas3_1_1.Oas3_1Types : oas3_1.Oas3Types : oas2_1.Oas2Types, oasVersion), config);\n            preprocessors = rules_1.initRules(rules, config, 'preprocessors', oasVersion);\n            decorators = rules_1.initRules(rules, config, 'decorators', oasVersion);\n            ctx = {\n              problems: [],\n              oasVersion: oasVersion,\n              refTypes: new Map(),\n              visitorsData: {}\n            };\n\n            if (removeUnusedComponents) {\n              decorators.push({\n                severity: 'error',\n                ruleId: 'remove-unused-components',\n                visitor: oasMajorVersion === oas_types_1.OasMajorVersion.Version2 ? remove_unused_components_1.RemoveUnusedComponents({}) : remove_unused_components_2.RemoveUnusedComponents({})\n              });\n            }\n\n            _context2.next = 11;\n            return resolve_1.resolveDocument({\n              rootDocument: document,\n              rootType: types.DefinitionRoot,\n              externalRefResolver: externalRefResolver\n            });\n\n          case 11:\n            resolvedRefMap = _context2.sent;\n            bundleVisitor = visitors_1.normalizeVisitors([].concat(_toConsumableArray(preprocessors), [{\n              severity: 'error',\n              ruleId: 'bundler',\n              visitor: makeBundleVisitor(oasMajorVersion, dereference, skipRedoclyRegistryRefs, document, resolvedRefMap)\n            }], _toConsumableArray(decorators)), types);\n            walk_1.walkDocument({\n              document: document,\n              rootType: types.DefinitionRoot,\n              normalizedVisitors: bundleVisitor,\n              resolvedRefMap: resolvedRefMap,\n              ctx: ctx\n            });\n            return _context2.abrupt(\"return\", {\n              bundle: document,\n              problems: ctx.problems.map(function (problem) {\n                return config.addProblemToIgnore(problem);\n              }),\n              fileDependencies: externalRefResolver.getFiles(),\n              rootType: types.DefinitionRoot,\n              refTypes: ctx.refTypes,\n              visitorsData: ctx.visitorsData\n            });\n\n          case 15:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\n\nexports.bundleDocument = bundleDocument;\n\nfunction mapTypeToComponent(typeName, version) {\n  switch (version) {\n    case oas_types_1.OasMajorVersion.Version3:\n      switch (typeName) {\n        case 'Schema':\n          return 'schemas';\n\n        case 'Parameter':\n          return 'parameters';\n\n        case 'Response':\n          return 'responses';\n\n        case 'Example':\n          return 'examples';\n\n        case 'RequestBody':\n          return 'requestBodies';\n\n        case 'Header':\n          return 'headers';\n\n        case 'SecuritySchema':\n          return 'securitySchemes';\n\n        case 'Link':\n          return 'links';\n\n        case 'Callback':\n          return 'callbacks';\n\n        default:\n          return null;\n      }\n\n    case oas_types_1.OasMajorVersion.Version2:\n      switch (typeName) {\n        case 'Schema':\n          return 'definitions';\n\n        case 'Parameter':\n          return 'parameters';\n\n        case 'Response':\n          return 'responses';\n\n        default:\n          return null;\n      }\n\n  }\n}\n\nexports.mapTypeToComponent = mapTypeToComponent; // function oas3Move\n\nfunction makeBundleVisitor(version, dereference, skipRedoclyRegistryRefs, rootDocument, resolvedRefMap) {\n  var components;\n  var visitor = {\n    ref: {\n      leave: function leave(node, ctx, resolved) {\n        if (!resolved.location || resolved.node === undefined) {\n          no_unresolved_refs_1.reportUnresolvedRef(resolved, ctx.report, ctx.location);\n          return;\n        }\n\n        if (resolved.location.source === rootDocument.source && resolved.location.source === ctx.location.source && ctx.type.name !== 'scalar' && !dereference) {\n          return;\n        } // do not bundle registry URL before push, otherwise we can't record dependencies\n\n\n        if (skipRedoclyRegistryRefs && redocly_1.isRedoclyRegistryURL(node.$ref)) {\n          return;\n        }\n\n        var componentType = mapTypeToComponent(ctx.type.name, version);\n\n        if (!componentType) {\n          replaceRef(node, resolved, ctx);\n        } else {\n          if (dereference) {\n            saveComponent(componentType, resolved, ctx);\n            replaceRef(node, resolved, ctx);\n          } else {\n            node.$ref = saveComponent(componentType, resolved, ctx);\n            resolveBundledComponent(node, resolved, ctx);\n          }\n        }\n      }\n    },\n    DefinitionRoot: {\n      enter: function enter(root) {\n        if (version === oas_types_1.OasMajorVersion.Version3) {\n          components = root.components = root.components || {};\n        } else if (version === oas_types_1.OasMajorVersion.Version2) {\n          components = root;\n        }\n      }\n    }\n  };\n\n  if (version === oas_types_1.OasMajorVersion.Version3) {\n    visitor.DiscriminatorMapping = {\n      leave: function leave(mapping, ctx) {\n        for (var _i = 0, _Object$keys = Object.keys(mapping); _i < _Object$keys.length; _i++) {\n          var name = _Object$keys[_i];\n          var $ref = mapping[name];\n          var resolved = ctx.resolve({\n            $ref: $ref\n          });\n\n          if (!resolved.location || resolved.node === undefined) {\n            no_unresolved_refs_1.reportUnresolvedRef(resolved, ctx.report, ctx.location.child(name));\n            return;\n          }\n\n          var componentType = mapTypeToComponent('Schema', version);\n\n          if (dereference) {\n            saveComponent(componentType, resolved, ctx);\n          } else {\n            mapping[name] = saveComponent(componentType, resolved, ctx);\n          }\n        }\n      }\n    };\n  }\n\n  function resolveBundledComponent(node, resolved, ctx) {\n    var newRefId = resolve_1.makeRefId(ctx.location.source.absoluteRef, node.$ref);\n    resolvedRefMap.set(newRefId, {\n      document: rootDocument,\n      isRemote: false,\n      node: resolved.node,\n      nodePointer: node.$ref,\n      resolved: true\n    });\n  }\n\n  function replaceRef(ref, resolved, ctx) {\n    if (!utils_1.isPlainObject(resolved.node)) {\n      ctx.parent[ctx.key] = resolved.node;\n    } else {\n      // @ts-ignore\n      delete ref.$ref;\n      Object.assign(ref, resolved.node);\n    }\n  }\n\n  function saveComponent(componentType, target, ctx) {\n    components[componentType] = components[componentType] || {};\n    var name = getComponentName(target, componentType, ctx);\n    components[componentType][name] = target.node;\n\n    if (version === oas_types_1.OasMajorVersion.Version3) {\n      return \"#/components/\".concat(componentType, \"/\").concat(name);\n    } else {\n      return \"#/\".concat(componentType, \"/\").concat(name);\n    }\n  }\n\n  function isEqualOrEqualRef(node, target, ctx) {\n    var _a;\n\n    if (ref_utils_1.isRef(node) && ((_a = ctx.resolve(node).location) === null || _a === void 0 ? void 0 : _a.absolutePointer) === target.location.absolutePointer) {\n      return true;\n    }\n\n    return isEqual(node, target.node);\n  }\n\n  function getComponentName(target, componentType, ctx) {\n    var _ref = [target.location.source.absoluteRef, target.location.pointer],\n        fileRef = _ref[0],\n        pointer = _ref[1];\n    var componentsGroup = components[componentType];\n    var name = '';\n    var refParts = pointer.slice(2).split('/').filter(Boolean); // slice(2) removes \"#/\"\n\n    while (refParts.length > 0) {\n      name = refParts.pop() + (name ? \"-\".concat(name) : '');\n\n      if (!componentsGroup || !componentsGroup[name] || isEqualOrEqualRef(componentsGroup[name], target, ctx)) {\n        return name;\n      }\n    }\n\n    name = ref_utils_1.refBaseName(fileRef) + (name ? \"_\".concat(name) : '');\n\n    if (!componentsGroup[name] || isEqualOrEqualRef(componentsGroup[name], target, ctx)) {\n      return name;\n    }\n\n    var prevName = name;\n    var serialId = 2;\n\n    while (componentsGroup[name] && !isEqualOrEqualRef(componentsGroup[name], target, ctx)) {\n      name = \"\".concat(prevName, \"-\").concat(serialId);\n      serialId++;\n    }\n\n    if (!componentsGroup[name]) {\n      ctx.report({\n        message: \"Two schemas are referenced with the same name but different content. Renamed \".concat(prevName, \" to \").concat(name, \".\"),\n        location: ctx.location,\n        forceSeverity: 'warn'\n      });\n    }\n\n    return name;\n  }\n\n  return visitor;\n}","map":null,"metadata":{},"sourceType":"script"}