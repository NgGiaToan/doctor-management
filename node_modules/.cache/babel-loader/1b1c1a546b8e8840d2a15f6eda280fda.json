{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asserts = exports.runOnValuesSet = exports.runOnKeysSet = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nexports.runOnKeysSet = new Set(['mutuallyExclusive', 'mutuallyRequired', 'enum', 'pattern', 'minLength', 'maxLength', 'casing', 'sortOrder', 'disallowed', 'required']);\nexports.runOnValuesSet = new Set(['pattern', 'enum', 'defined', 'undefined', 'nonEmpty', 'minLength', 'maxLength', 'casing', 'sortOrder']);\nexports.asserts = {\n  pattern: (value, condition) => {\n    if (typeof value === 'undefined') return true; // property doesn't exist, no need to lint it with this assert\n\n    const values = typeof value === 'string' ? [value] : value;\n    const regexOptions = condition.match(/(\\b\\/\\b)(.+)/g) || ['/'];\n    condition = condition.slice(1).replace(regexOptions[0], '');\n    const regx = new RegExp(condition, regexOptions[0].slice(1));\n\n    for (let _val of values) {\n      if (!_val.match(regx)) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  enum: (value, condition) => {\n    if (typeof value === 'undefined') return true; // property doesn't exist, no need to lint it with this assert\n\n    const values = typeof value === 'string' ? [value] : value;\n\n    for (let _val of values) {\n      if (!condition.includes(_val)) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  defined: function (value) {\n    let condition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const isDefined = typeof value !== 'undefined';\n    return condition ? isDefined : !isDefined;\n  },\n  required: (value, keys) => {\n    for (const requiredKey of keys) {\n      if (!value.includes(requiredKey)) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  disallowed: (value, condition) => {\n    if (typeof value === 'undefined') return true; // property doesn't exist, no need to lint it with this assert\n\n    const values = typeof value === 'string' ? [value] : value;\n\n    for (let _val of values) {\n      if (condition.includes(_val)) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  undefined: function (value) {\n    let condition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const isUndefined = typeof value === 'undefined';\n    return condition ? isUndefined : !isUndefined;\n  },\n  nonEmpty: function (value) {\n    let condition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const isEmpty = typeof value === 'undefined' || value === null || value === '';\n    return condition ? !isEmpty : isEmpty;\n  },\n  minLength: (value, condition) => {\n    if (typeof value === 'undefined') return true; // property doesn't exist, no need to lint it with this assert\n\n    return value.length >= condition;\n  },\n  maxLength: (value, condition) => {\n    if (typeof value === 'undefined') return true; // property doesn't exist, no need to lint it with this assert\n\n    return value.length <= condition;\n  },\n  casing: (value, condition) => {\n    if (typeof value === 'undefined') return true; // property doesn't exist, no need to lint it with this assert\n\n    const values = typeof value === 'string' ? [value] : value;\n\n    for (let _val of values) {\n      let matchCase = false;\n\n      switch (condition) {\n        case 'camelCase':\n          matchCase = !!_val.match(/^[a-z][a-zA-Z0-9]+$/g);\n          break;\n\n        case 'kebab-case':\n          matchCase = !!_val.match(/^([a-z][a-z0-9]*)(-[a-z0-9]+)*$/g);\n          break;\n\n        case 'snake_case':\n          matchCase = !!_val.match(/^([a-z][a-z0-9]*)(_[a-z0-9]+)*$/g);\n          break;\n\n        case 'PascalCase':\n          matchCase = !!_val.match(/^[A-Z][a-zA-Z0-9]+$/g);\n          break;\n\n        case 'MACRO_CASE':\n          matchCase = !!_val.match(/^([A-Z][A-Z0-9]*)(_[A-Z0-9]+)*$/g);\n          break;\n\n        case 'COBOL-CASE':\n          matchCase = !!_val.match(/^([A-Z][A-Z0-9]*)(-[A-Z0-9]+)*$/g);\n          break;\n\n        case 'flatcase':\n          matchCase = !!_val.match(/^[a-z][a-z0-9]+$/g);\n          break;\n      }\n\n      if (!matchCase) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  sortOrder: (value, condition) => {\n    if (typeof value === 'undefined') return true;\n    return utils_1.isOrdered(value, condition);\n  },\n  mutuallyExclusive: (value, condition) => {\n    return utils_1.getIntersectionLength(value, condition) < 2;\n  },\n  mutuallyRequired: (value, condition) => {\n    return utils_1.getIntersectionLength(value, condition) > 0 ? utils_1.getIntersectionLength(value, condition) === condition.length : true;\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","asserts","runOnValuesSet","runOnKeysSet","utils_1","require","Set","pattern","condition","values","regexOptions","match","slice","replace","regx","RegExp","_val","enum","includes","defined","isDefined","required","keys","requiredKey","disallowed","undefined","isUndefined","nonEmpty","isEmpty","minLength","length","maxLength","casing","matchCase","sortOrder","isOrdered","mutuallyExclusive","getIntersectionLength","mutuallyRequired"],"sources":["C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@redocly/openapi-core/lib/rules/common/assertions/asserts.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.asserts = exports.runOnValuesSet = exports.runOnKeysSet = void 0;\nconst utils_1 = require(\"./utils\");\nexports.runOnKeysSet = new Set([\n    'mutuallyExclusive',\n    'mutuallyRequired',\n    'enum',\n    'pattern',\n    'minLength',\n    'maxLength',\n    'casing',\n    'sortOrder',\n    'disallowed',\n    'required',\n]);\nexports.runOnValuesSet = new Set([\n    'pattern',\n    'enum',\n    'defined',\n    'undefined',\n    'nonEmpty',\n    'minLength',\n    'maxLength',\n    'casing',\n    'sortOrder',\n]);\nexports.asserts = {\n    pattern: (value, condition) => {\n        if (typeof value === 'undefined')\n            return true; // property doesn't exist, no need to lint it with this assert\n        const values = typeof value === 'string' ? [value] : value;\n        const regexOptions = condition.match(/(\\b\\/\\b)(.+)/g) || ['/'];\n        condition = condition.slice(1).replace(regexOptions[0], '');\n        const regx = new RegExp(condition, regexOptions[0].slice(1));\n        for (let _val of values) {\n            if (!_val.match(regx)) {\n                return false;\n            }\n        }\n        return true;\n    },\n    enum: (value, condition) => {\n        if (typeof value === 'undefined')\n            return true; // property doesn't exist, no need to lint it with this assert\n        const values = typeof value === 'string' ? [value] : value;\n        for (let _val of values) {\n            if (!condition.includes(_val)) {\n                return false;\n            }\n        }\n        return true;\n    },\n    defined: (value, condition = true) => {\n        const isDefined = typeof value !== 'undefined';\n        return condition ? isDefined : !isDefined;\n    },\n    required: (value, keys) => {\n        for (const requiredKey of keys) {\n            if (!value.includes(requiredKey)) {\n                return false;\n            }\n        }\n        return true;\n    },\n    disallowed: (value, condition) => {\n        if (typeof value === 'undefined')\n            return true; // property doesn't exist, no need to lint it with this assert\n        const values = typeof value === 'string' ? [value] : value;\n        for (let _val of values) {\n            if (condition.includes(_val)) {\n                return false;\n            }\n        }\n        return true;\n    },\n    undefined: (value, condition = true) => {\n        const isUndefined = typeof value === 'undefined';\n        return condition ? isUndefined : !isUndefined;\n    },\n    nonEmpty: (value, condition = true) => {\n        const isEmpty = typeof value === 'undefined' || value === null || value === '';\n        return condition ? !isEmpty : isEmpty;\n    },\n    minLength: (value, condition) => {\n        if (typeof value === 'undefined')\n            return true; // property doesn't exist, no need to lint it with this assert\n        return value.length >= condition;\n    },\n    maxLength: (value, condition) => {\n        if (typeof value === 'undefined')\n            return true; // property doesn't exist, no need to lint it with this assert\n        return value.length <= condition;\n    },\n    casing: (value, condition) => {\n        if (typeof value === 'undefined')\n            return true; // property doesn't exist, no need to lint it with this assert\n        const values = typeof value === 'string' ? [value] : value;\n        for (let _val of values) {\n            let matchCase = false;\n            switch (condition) {\n                case 'camelCase':\n                    matchCase = !!_val.match(/^[a-z][a-zA-Z0-9]+$/g);\n                    break;\n                case 'kebab-case':\n                    matchCase = !!_val.match(/^([a-z][a-z0-9]*)(-[a-z0-9]+)*$/g);\n                    break;\n                case 'snake_case':\n                    matchCase = !!_val.match(/^([a-z][a-z0-9]*)(_[a-z0-9]+)*$/g);\n                    break;\n                case 'PascalCase':\n                    matchCase = !!_val.match(/^[A-Z][a-zA-Z0-9]+$/g);\n                    break;\n                case 'MACRO_CASE':\n                    matchCase = !!_val.match(/^([A-Z][A-Z0-9]*)(_[A-Z0-9]+)*$/g);\n                    break;\n                case 'COBOL-CASE':\n                    matchCase = !!_val.match(/^([A-Z][A-Z0-9]*)(-[A-Z0-9]+)*$/g);\n                    break;\n                case 'flatcase':\n                    matchCase = !!_val.match(/^[a-z][a-z0-9]+$/g);\n                    break;\n            }\n            if (!matchCase) {\n                return false;\n            }\n        }\n        return true;\n    },\n    sortOrder: (value, condition) => {\n        if (typeof value === 'undefined')\n            return true;\n        return utils_1.isOrdered(value, condition);\n    },\n    mutuallyExclusive: (value, condition) => {\n        return utils_1.getIntersectionLength(value, condition) < 2;\n    },\n    mutuallyRequired: (value, condition) => {\n        return utils_1.getIntersectionLength(value, condition) > 0\n            ? utils_1.getIntersectionLength(value, condition) === condition.length\n            : true;\n    },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}