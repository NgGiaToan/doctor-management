{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _templateObject, _templateObject2;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar code_1 = require(\"../code\");\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar util_2 = require(\"../../compile/util\");\n\nvar def = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code: function code(cxt) {\n    var gen = cxt.gen,\n        schema = cxt.schema,\n        data = cxt.data,\n        parentSchema = cxt.parentSchema,\n        it = cxt.it;\n    var opts = it.opts;\n    var patterns = code_1.allSchemaProperties(schema);\n    var alwaysValidPatterns = patterns.filter(function (p) {\n      return util_1.alwaysValidSchema(it, schema[p]);\n    });\n\n    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {\n      return;\n    }\n\n    var checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n    var valid = gen.name(\"valid\");\n\n    if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n      it.props = util_2.evaluatedPropsToName(gen, it.props);\n    }\n\n    var props = it.props;\n    validatePatternProperties();\n\n    function validatePatternProperties() {\n      var _iterator = _createForOfIteratorHelper(patterns),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pat = _step.value;\n          if (checkProperties) checkMatchingProperties(pat);\n\n          if (it.allErrors) {\n            validateProperties(pat);\n          } else {\n            gen.var(valid, true); // TODO var\n\n            validateProperties(pat);\n            gen.if(valid);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    function checkMatchingProperties(pat) {\n      for (var prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          util_1.checkStrictMode(it, \"property \".concat(prop, \" matches pattern \").concat(pat, \" (use allowMatchingProperties)\"));\n        }\n      }\n    }\n\n    function validateProperties(pat) {\n      gen.forIn(\"key\", data, function (key) {\n        gen.if(codegen_1._(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \".test(\", \")\"])), code_1.usePattern(cxt, pat), key), function () {\n          var alwaysValid = alwaysValidPatterns.includes(pat);\n\n          if (!alwaysValid) {\n            cxt.subschema({\n              keyword: \"patternProperties\",\n              schemaProp: pat,\n              dataProp: key,\n              dataPropType: util_2.Type.Str\n            }, valid);\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(codegen_1._(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), props, key), true);\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(codegen_1.not(valid), function () {\n              return gen.break();\n            });\n          }\n        });\n      });\n    }\n  }\n};\nexports.default = def; //# sourceMappingURL=patternProperties.js.map","map":null,"metadata":{},"sourceType":"script"}