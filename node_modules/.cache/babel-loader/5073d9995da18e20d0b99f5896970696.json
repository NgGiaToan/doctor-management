{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst code_1 = require(\"../code\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst util_2 = require(\"../../compile/util\");\n\nconst def = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      data,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      opts\n    } = it;\n    const patterns = code_1.allSchemaProperties(schema);\n    const alwaysValidPatterns = patterns.filter(p => util_1.alwaysValidSchema(it, schema[p]));\n\n    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {\n      return;\n    }\n\n    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n    const valid = gen.name(\"valid\");\n\n    if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n      it.props = util_2.evaluatedPropsToName(gen, it.props);\n    }\n\n    const {\n      props\n    } = it;\n    validatePatternProperties();\n\n    function validatePatternProperties() {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat);\n\n        if (it.allErrors) {\n          validateProperties(pat);\n        } else {\n          gen.var(valid, true); // TODO var\n\n          validateProperties(pat);\n          gen.if(valid);\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat) {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          util_1.checkStrictMode(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n        }\n      }\n    }\n\n    function validateProperties(pat) {\n      gen.forIn(\"key\", data, key => {\n        gen.if(codegen_1._`${code_1.usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat);\n\n          if (!alwaysValid) {\n            cxt.subschema({\n              keyword: \"patternProperties\",\n              schemaProp: pat,\n              dataProp: key,\n              dataPropType: util_2.Type.Str\n            }, valid);\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(codegen_1._`${props}[${key}]`, true);\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(codegen_1.not(valid), () => gen.break());\n          }\n        });\n      });\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["def","keyword","type","schemaType","code","cxt","gen","schema","data","parentSchema","it","opts","patterns","code_1","alwaysValidPatterns","filter","p","util_1","length","unevaluated","props","checkProperties","strictSchema","allowMatchingProperties","properties","valid","name","codegen_1","util_2","validatePatternProperties","pat","checkMatchingProperties","allErrors","validateProperties","var","if","prop","RegExp","test","forIn","key","alwaysValid","includes","subschema","schemaProp","dataProp","dataPropType","Str","assign","break","exports"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\vocabularies\\applicator\\patternProperties.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}