{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OasSpec = void 0;\n\nconst types_1 = require(\"../../types\");\n\nconst utils_1 = require(\"../utils\");\n\nconst ref_utils_1 = require(\"../../ref-utils\");\n\nconst utils_2 = require(\"../../utils\");\n\nconst OasSpec = () => {\n  return {\n    any(node, _ref) {\n      let {\n        report,\n        type,\n        location,\n        key,\n        resolve,\n        ignoreNextVisitorsOnNode\n      } = _ref;\n\n      var _a, _b, _c, _d;\n\n      const nodeType = utils_1.oasTypeOf(node);\n\n      if (type.items) {\n        if (nodeType !== 'array') {\n          report({\n            message: `Expected type \\`${type.name}\\` (array) but got \\`${nodeType}\\``\n          });\n          ignoreNextVisitorsOnNode();\n        }\n\n        return;\n      } else if (nodeType !== 'object') {\n        report({\n          message: `Expected type \\`${type.name}\\` (object) but got \\`${nodeType}\\``\n        });\n        ignoreNextVisitorsOnNode();\n        return;\n      }\n\n      const required = typeof type.required === 'function' ? type.required(node, key) : type.required;\n\n      for (let propName of required || []) {\n        if (!node.hasOwnProperty(propName)) {\n          report({\n            message: `The field \\`${propName}\\` must be present on this level.`,\n            location: [{\n              reportOnKey: true\n            }]\n          });\n        }\n      }\n\n      const allowed = (_a = type.allowed) === null || _a === void 0 ? void 0 : _a.call(type, node);\n\n      if (allowed && utils_2.isPlainObject(node)) {\n        for (const propName in node) {\n          if (allowed.includes(propName) || type.extensionsPrefix && propName.startsWith(type.extensionsPrefix) || !Object.keys(type.properties).includes(propName)) {\n            continue;\n          }\n\n          report({\n            message: `The field \\`${propName}\\` is not allowed here.`,\n            location: location.child([propName]).key()\n          });\n        }\n      }\n\n      const requiredOneOf = type.requiredOneOf || null;\n\n      if (requiredOneOf) {\n        let hasProperty = false;\n\n        for (let propName of requiredOneOf || []) {\n          if (node.hasOwnProperty(propName)) {\n            hasProperty = true;\n          }\n        }\n\n        if (!hasProperty) report({\n          message: `Must contain at least one of the following fields: ${(_b = type.requiredOneOf) === null || _b === void 0 ? void 0 : _b.join(', ')}.`,\n          location: [{\n            reportOnKey: true\n          }]\n        });\n      }\n\n      for (const propName of Object.keys(node)) {\n        const propLocation = location.child([propName]);\n        let propValue = node[propName];\n        let propType = type.properties[propName];\n        if (propType === undefined) propType = type.additionalProperties;\n        if (typeof propType === 'function') propType = propType(propValue, propName);\n\n        if (types_1.isNamedType(propType)) {\n          continue; // do nothing for named schema, it is executed with the next any call\n        }\n\n        const propSchema = propType;\n        const propValueType = utils_1.oasTypeOf(propValue);\n\n        if (propSchema === undefined) {\n          if (propName.startsWith('x-')) continue;\n          report({\n            message: `Property \\`${propName}\\` is not expected here.`,\n            suggest: utils_1.getSuggest(propName, Object.keys(type.properties)),\n            location: propLocation.key()\n          });\n          continue;\n        }\n\n        if (propSchema === null) {\n          continue; // just defined, no validation\n        }\n\n        if (propSchema.resolvable !== false && ref_utils_1.isRef(propValue)) {\n          propValue = resolve(propValue).node;\n        }\n\n        if (propSchema.enum) {\n          if (!propSchema.enum.includes(propValue)) {\n            report({\n              location: propLocation,\n              message: `\\`${propName}\\` can be one of the following only: ${propSchema.enum.map(i => `\"${i}\"`).join(', ')}.`,\n              suggest: utils_1.getSuggest(propValue, propSchema.enum)\n            });\n          }\n        } else if (propSchema.type && !utils_1.matchesJsonSchemaType(propValue, propSchema.type, false)) {\n          report({\n            message: `Expected type \\`${propSchema.type}\\` but got \\`${propValueType}\\`.`,\n            location: propLocation\n          });\n        } else if (propValueType === 'array' && ((_c = propSchema.items) === null || _c === void 0 ? void 0 : _c.type)) {\n          const itemsType = (_d = propSchema.items) === null || _d === void 0 ? void 0 : _d.type;\n\n          for (let i = 0; i < propValue.length; i++) {\n            const item = propValue[i];\n\n            if (!utils_1.matchesJsonSchemaType(item, itemsType, false)) {\n              report({\n                message: `Expected type \\`${itemsType}\\` but got \\`${utils_1.oasTypeOf(item)}\\`.`,\n                location: propLocation.child([i])\n              });\n            }\n          }\n        }\n\n        if (typeof propSchema.minimum === 'number') {\n          if (propSchema.minimum > node[propName]) {\n            report({\n              message: `The value of the ${propName} field must be greater than or equal to ${propSchema.minimum}`,\n              location: location.child([propName])\n            });\n          }\n        }\n      }\n    }\n\n  };\n};\n\nexports.OasSpec = OasSpec;","map":{"version":3,"names":["Object","defineProperty","exports","value","OasSpec","types_1","require","utils_1","ref_utils_1","utils_2","any","node","report","type","location","key","resolve","ignoreNextVisitorsOnNode","_a","_b","_c","_d","nodeType","oasTypeOf","items","message","name","required","propName","hasOwnProperty","reportOnKey","allowed","call","isPlainObject","includes","extensionsPrefix","startsWith","keys","properties","child","requiredOneOf","hasProperty","join","propLocation","propValue","propType","undefined","additionalProperties","isNamedType","propSchema","propValueType","suggest","getSuggest","resolvable","isRef","enum","map","i","matchesJsonSchemaType","itemsType","length","item","minimum"],"sources":["C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@redocly/openapi-core/lib/rules/common/spec.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OasSpec = void 0;\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../utils\");\nconst ref_utils_1 = require(\"../../ref-utils\");\nconst utils_2 = require(\"../../utils\");\nconst OasSpec = () => {\n    return {\n        any(node, { report, type, location, key, resolve, ignoreNextVisitorsOnNode }) {\n            var _a, _b, _c, _d;\n            const nodeType = utils_1.oasTypeOf(node);\n            if (type.items) {\n                if (nodeType !== 'array') {\n                    report({\n                        message: `Expected type \\`${type.name}\\` (array) but got \\`${nodeType}\\``,\n                    });\n                    ignoreNextVisitorsOnNode();\n                }\n                return;\n            }\n            else if (nodeType !== 'object') {\n                report({\n                    message: `Expected type \\`${type.name}\\` (object) but got \\`${nodeType}\\``,\n                });\n                ignoreNextVisitorsOnNode();\n                return;\n            }\n            const required = typeof type.required === 'function' ? type.required(node, key) : type.required;\n            for (let propName of required || []) {\n                if (!node.hasOwnProperty(propName)) {\n                    report({\n                        message: `The field \\`${propName}\\` must be present on this level.`,\n                        location: [{ reportOnKey: true }],\n                    });\n                }\n            }\n            const allowed = (_a = type.allowed) === null || _a === void 0 ? void 0 : _a.call(type, node);\n            if (allowed && utils_2.isPlainObject(node)) {\n                for (const propName in node) {\n                    if (allowed.includes(propName) ||\n                        (type.extensionsPrefix && propName.startsWith(type.extensionsPrefix)) ||\n                        !Object.keys(type.properties).includes(propName)) {\n                        continue;\n                    }\n                    report({\n                        message: `The field \\`${propName}\\` is not allowed here.`,\n                        location: location.child([propName]).key()\n                    });\n                }\n            }\n            const requiredOneOf = type.requiredOneOf || null;\n            if (requiredOneOf) {\n                let hasProperty = false;\n                for (let propName of requiredOneOf || []) {\n                    if (node.hasOwnProperty(propName)) {\n                        hasProperty = true;\n                    }\n                }\n                if (!hasProperty)\n                    report({\n                        message: `Must contain at least one of the following fields: ${(_b = type.requiredOneOf) === null || _b === void 0 ? void 0 : _b.join(', ')}.`,\n                        location: [{ reportOnKey: true }],\n                    });\n            }\n            for (const propName of Object.keys(node)) {\n                const propLocation = location.child([propName]);\n                let propValue = node[propName];\n                let propType = type.properties[propName];\n                if (propType === undefined)\n                    propType = type.additionalProperties;\n                if (typeof propType === 'function')\n                    propType = propType(propValue, propName);\n                if (types_1.isNamedType(propType)) {\n                    continue; // do nothing for named schema, it is executed with the next any call\n                }\n                const propSchema = propType;\n                const propValueType = utils_1.oasTypeOf(propValue);\n                if (propSchema === undefined) {\n                    if (propName.startsWith('x-'))\n                        continue;\n                    report({\n                        message: `Property \\`${propName}\\` is not expected here.`,\n                        suggest: utils_1.getSuggest(propName, Object.keys(type.properties)),\n                        location: propLocation.key(),\n                    });\n                    continue;\n                }\n                if (propSchema === null) {\n                    continue; // just defined, no validation\n                }\n                if (propSchema.resolvable !== false && ref_utils_1.isRef(propValue)) {\n                    propValue = resolve(propValue).node;\n                }\n                if (propSchema.enum) {\n                    if (!propSchema.enum.includes(propValue)) {\n                        report({\n                            location: propLocation,\n                            message: `\\`${propName}\\` can be one of the following only: ${propSchema.enum\n                                .map((i) => `\"${i}\"`)\n                                .join(', ')}.`,\n                            suggest: utils_1.getSuggest(propValue, propSchema.enum),\n                        });\n                    }\n                }\n                else if (propSchema.type && !utils_1.matchesJsonSchemaType(propValue, propSchema.type, false)) {\n                    report({\n                        message: `Expected type \\`${propSchema.type}\\` but got \\`${propValueType}\\`.`,\n                        location: propLocation,\n                    });\n                }\n                else if (propValueType === 'array' && ((_c = propSchema.items) === null || _c === void 0 ? void 0 : _c.type)) {\n                    const itemsType = (_d = propSchema.items) === null || _d === void 0 ? void 0 : _d.type;\n                    for (let i = 0; i < propValue.length; i++) {\n                        const item = propValue[i];\n                        if (!utils_1.matchesJsonSchemaType(item, itemsType, false)) {\n                            report({\n                                message: `Expected type \\`${itemsType}\\` but got \\`${utils_1.oasTypeOf(item)}\\`.`,\n                                location: propLocation.child([i]),\n                            });\n                        }\n                    }\n                }\n                if (typeof propSchema.minimum === 'number') {\n                    if (propSchema.minimum > node[propName]) {\n                        report({\n                            message: `The value of the ${propName} field must be greater than or equal to ${propSchema.minimum}`,\n                            location: location.child([propName]),\n                        });\n                    }\n                }\n            }\n        },\n    };\n};\nexports.OasSpec = OasSpec;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}