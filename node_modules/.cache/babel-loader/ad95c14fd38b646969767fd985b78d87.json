{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst code_1 = require(\"../code\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        missingProperty\n      }\n    } = _ref;\n    return codegen_1.str`must have required property '${missingProperty}'`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        missingProperty\n      }\n    } = _ref2;\n    return codegen_1._`{missingProperty: ${missingProperty}}`;\n  }\n};\nconst def = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      schemaCode,\n      data,\n      $data,\n      it\n    } = cxt;\n    const {\n      opts\n    } = it;\n    if (!$data && schema.length === 0) return;\n    const useLoop = schema.length >= opts.loopRequired;\n    if (it.allErrors) allErrorsMode();else exitOnErrorMode();\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties;\n      const {\n        definedProperties\n      } = cxt.it;\n\n      for (const requiredKey of schema) {\n        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n          util_1.checkStrictMode(it, msg, it.opts.strictRequired);\n        }\n      }\n    }\n\n    function allErrorsMode() {\n      if (useLoop || $data) {\n        cxt.block$data(codegen_1.nil, loopAllRequired);\n      } else {\n        for (const prop of schema) {\n          code_1.checkReportMissingProp(cxt, prop);\n        }\n      }\n    }\n\n    function exitOnErrorMode() {\n      const missing = gen.let(\"missing\");\n\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true);\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n        cxt.ok(valid);\n      } else {\n        gen.if(code_1.checkMissingProp(cxt, schema, missing));\n        code_1.reportMissingProp(cxt, missing);\n        gen.else();\n      }\n    }\n\n    function loopAllRequired() {\n      gen.forOf(\"prop\", schemaCode, prop => {\n        cxt.setParams({\n          missingProperty: prop\n        });\n        gen.if(code_1.noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error());\n      });\n    }\n\n    function loopUntilMissing(missing, valid) {\n      cxt.setParams({\n        missingProperty: missing\n      });\n      gen.forOf(missing, schemaCode, () => {\n        gen.assign(valid, code_1.propertyInData(gen, data, missing, opts.ownProperties));\n        gen.if(codegen_1.not(valid), () => {\n          cxt.error();\n          gen.break();\n        });\n      }, codegen_1.nil);\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","missingProperty","codegen_1","def","keyword","type","schemaType","$data","code","cxt","gen","schema","schemaCode","data","it","opts","length","useLoop","loopRequired","allErrors","allErrorsMode","exitOnErrorMode","strictRequired","props","parentSchema","properties","definedProperties","requiredKey","undefined","has","schemaPath","schemaEnv","baseId","errSchemaPath","msg","util_1","block$data","loopAllRequired","prop","code_1","missing","let","valid","loopUntilMissing","ok","if","else","forOf","setParams","ownProperties","assign","break","exports"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\vocabularies\\validation\\required.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}