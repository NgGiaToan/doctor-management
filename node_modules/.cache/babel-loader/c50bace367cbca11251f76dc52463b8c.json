{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OasSpec = void 0;\n\nvar types_1 = require(\"../../types\");\n\nvar utils_1 = require(\"../utils\");\n\nvar ref_utils_1 = require(\"../../ref-utils\");\n\nvar utils_2 = require(\"../../utils\");\n\nvar OasSpec = function OasSpec() {\n  return {\n    any: function any(node, _ref) {\n      var report = _ref.report,\n          type = _ref.type,\n          location = _ref.location,\n          key = _ref.key,\n          resolve = _ref.resolve,\n          ignoreNextVisitorsOnNode = _ref.ignoreNextVisitorsOnNode;\n\n      var _a, _b, _c, _d;\n\n      var nodeType = utils_1.oasTypeOf(node);\n\n      if (type.items) {\n        if (nodeType !== 'array') {\n          report({\n            message: \"Expected type `\".concat(type.name, \"` (array) but got `\").concat(nodeType, \"`\")\n          });\n          ignoreNextVisitorsOnNode();\n        }\n\n        return;\n      } else if (nodeType !== 'object') {\n        report({\n          message: \"Expected type `\".concat(type.name, \"` (object) but got `\").concat(nodeType, \"`\")\n        });\n        ignoreNextVisitorsOnNode();\n        return;\n      }\n\n      var required = typeof type.required === 'function' ? type.required(node, key) : type.required;\n\n      var _iterator = _createForOfIteratorHelper(required || []),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _propName3 = _step.value;\n\n          if (!node.hasOwnProperty(_propName3)) {\n            report({\n              message: \"The field `\".concat(_propName3, \"` must be present on this level.\"),\n              location: [{\n                reportOnKey: true\n              }]\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var allowed = (_a = type.allowed) === null || _a === void 0 ? void 0 : _a.call(type, node);\n\n      if (allowed && utils_2.isPlainObject(node)) {\n        for (var propName in node) {\n          if (allowed.includes(propName) || type.extensionsPrefix && propName.startsWith(type.extensionsPrefix) || !Object.keys(type.properties).includes(propName)) {\n            continue;\n          }\n\n          report({\n            message: \"The field `\".concat(propName, \"` is not allowed here.\"),\n            location: location.child([propName]).key()\n          });\n        }\n      }\n\n      var requiredOneOf = type.requiredOneOf || null;\n\n      if (requiredOneOf) {\n        var hasProperty = false;\n\n        var _iterator2 = _createForOfIteratorHelper(requiredOneOf || []),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _propName = _step2.value;\n\n            if (node.hasOwnProperty(_propName)) {\n              hasProperty = true;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (!hasProperty) report({\n          message: \"Must contain at least one of the following fields: \".concat((_b = type.requiredOneOf) === null || _b === void 0 ? void 0 : _b.join(', '), \".\"),\n          location: [{\n            reportOnKey: true\n          }]\n        });\n      }\n\n      for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {\n        var _propName2 = _Object$keys[_i];\n        var propLocation = location.child([_propName2]);\n        var propValue = node[_propName2];\n        var propType = type.properties[_propName2];\n        if (propType === undefined) propType = type.additionalProperties;\n        if (typeof propType === 'function') propType = propType(propValue, _propName2);\n\n        if (types_1.isNamedType(propType)) {\n          continue; // do nothing for named schema, it is executed with the next any call\n        }\n\n        var propSchema = propType;\n        var propValueType = utils_1.oasTypeOf(propValue);\n\n        if (propSchema === undefined) {\n          if (_propName2.startsWith('x-')) continue;\n          report({\n            message: \"Property `\".concat(_propName2, \"` is not expected here.\"),\n            suggest: utils_1.getSuggest(_propName2, Object.keys(type.properties)),\n            location: propLocation.key()\n          });\n          continue;\n        }\n\n        if (propSchema === null) {\n          continue; // just defined, no validation\n        }\n\n        if (propSchema.resolvable !== false && ref_utils_1.isRef(propValue)) {\n          propValue = resolve(propValue).node;\n        }\n\n        if (propSchema.enum) {\n          if (!propSchema.enum.includes(propValue)) {\n            report({\n              location: propLocation,\n              message: \"`\".concat(_propName2, \"` can be one of the following only: \").concat(propSchema.enum.map(function (i) {\n                return \"\\\"\".concat(i, \"\\\"\");\n              }).join(', '), \".\"),\n              suggest: utils_1.getSuggest(propValue, propSchema.enum)\n            });\n          }\n        } else if (propSchema.type && !utils_1.matchesJsonSchemaType(propValue, propSchema.type, false)) {\n          report({\n            message: \"Expected type `\".concat(propSchema.type, \"` but got `\").concat(propValueType, \"`.\"),\n            location: propLocation\n          });\n        } else if (propValueType === 'array' && ((_c = propSchema.items) === null || _c === void 0 ? void 0 : _c.type)) {\n          var itemsType = (_d = propSchema.items) === null || _d === void 0 ? void 0 : _d.type;\n\n          for (var i = 0; i < propValue.length; i++) {\n            var item = propValue[i];\n\n            if (!utils_1.matchesJsonSchemaType(item, itemsType, false)) {\n              report({\n                message: \"Expected type `\".concat(itemsType, \"` but got `\").concat(utils_1.oasTypeOf(item), \"`.\"),\n                location: propLocation.child([i])\n              });\n            }\n          }\n        }\n\n        if (typeof propSchema.minimum === 'number') {\n          if (propSchema.minimum > node[_propName2]) {\n            report({\n              message: \"The value of the \".concat(_propName2, \" field must be greater than or equal to \").concat(propSchema.minimum),\n              location: location.child([_propName2])\n            });\n          }\n        }\n      }\n    }\n  };\n};\n\nexports.OasSpec = OasSpec;","map":null,"metadata":{},"sourceType":"script"}