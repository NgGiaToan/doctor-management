{"ast":null,"code":"import _objectSpread from \"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { _samplers } from './openapi-sampler';\nimport { allOfSample } from './allOf';\nimport { inferType } from './infer';\nimport { getResultForCircular, mergeDeep, popSchemaStack } from './utils';\nimport JsonPointer from 'json-pointer';\nvar $refCache = {}; // for circular JS references we use additional array and not object as we need to compare entire schemas and not strings\n\nvar seenSchemasStack = [];\nexport function clearCache() {\n  $refCache = {};\n  seenSchemasStack = [];\n}\n\nfunction inferExample(schema) {\n  var example;\n\n  if (schema.const !== undefined) {\n    example = schema.const;\n  } else if (schema.examples !== undefined && schema.examples.length) {\n    example = schema.examples[0];\n  } else if (schema.enum !== undefined && schema.enum.length) {\n    example = schema.enum[0];\n  } else if (schema.default !== undefined) {\n    example = schema.default;\n  }\n\n  return example;\n}\n\nfunction tryInferExample(schema) {\n  var example = inferExample(schema); // case when we don't infer example from schema but take from `const`, `examples`, `default` or `enum` keywords\n\n  if (example !== undefined) {\n    return {\n      value: example,\n      readOnly: schema.readOnly,\n      writeOnly: schema.writeOnly,\n      type: null\n    };\n  }\n\n  return;\n}\n\nexport function traverse(schema, options, spec, context) {\n  // checking circular JS references by checking context\n  // because context is passed only when traversing through nested objects happens\n  if (context) {\n    if (seenSchemasStack.includes(schema)) return getResultForCircular(inferType(schema));\n    seenSchemasStack.push(schema);\n  }\n\n  if (context && context.depth > options.maxSampleDepth) {\n    popSchemaStack(seenSchemasStack, context);\n    return getResultForCircular(inferType(schema));\n  }\n\n  if (schema.$ref) {\n    if (!spec) {\n      throw new Error('Your schema contains $ref. You must provide full specification in the third parameter.');\n    }\n\n    var ref = decodeURIComponent(schema.$ref);\n\n    if (ref.startsWith('#')) {\n      ref = ref.substring(1);\n    }\n\n    var referenced = JsonPointer.get(spec, ref);\n    var result;\n\n    if ($refCache[ref] !== true) {\n      $refCache[ref] = true;\n      result = traverse(referenced, options, spec, context);\n      $refCache[ref] = false;\n    } else {\n      var referencedType = inferType(referenced);\n      result = getResultForCircular(referencedType);\n    }\n\n    popSchemaStack(seenSchemasStack, context);\n    return result;\n  }\n\n  if (schema.example !== undefined) {\n    popSchemaStack(seenSchemasStack, context);\n    return {\n      value: schema.example,\n      readOnly: schema.readOnly,\n      writeOnly: schema.writeOnly,\n      type: schema.type\n    };\n  }\n\n  if (schema.allOf !== undefined) {\n    popSchemaStack(seenSchemasStack, context);\n    return tryInferExample(schema) || allOfSample(_objectSpread(_objectSpread({}, schema), {}, {\n      allOf: undefined\n    }), schema.allOf, options, spec, context);\n  }\n\n  if (schema.oneOf && schema.oneOf.length) {\n    if (schema.anyOf) {\n      if (!options.quiet) console.warn('oneOf and anyOf are not supported on the same level. Skipping anyOf');\n    }\n\n    popSchemaStack(seenSchemasStack, context); // Make sure to pass down readOnly and writeOnly annotations from the parent\n\n    var firstOneOf = Object.assign({\n      readOnly: schema.readOnly,\n      writeOnly: schema.writeOnly\n    }, schema.oneOf[0]);\n    return traverseOneOrAnyOf(schema, firstOneOf);\n  }\n\n  if (schema.anyOf && schema.anyOf.length) {\n    popSchemaStack(seenSchemasStack, context); // Make sure to pass down readOnly and writeOnly annotations from the parent\n\n    var firstAnyOf = Object.assign({\n      readOnly: schema.readOnly,\n      writeOnly: schema.writeOnly\n    }, schema.anyOf[0]);\n    return traverseOneOrAnyOf(schema, firstAnyOf);\n  }\n\n  if (schema.if && schema.then) {\n    popSchemaStack(seenSchemasStack, context);\n    return tryInferExample(schema) || traverse(mergeDeep(schema.if, schema.then), options, spec, context);\n  }\n\n  var example = inferExample(schema);\n  var type = null;\n\n  if (example === undefined) {\n    example = null;\n    type = schema.type;\n\n    if (Array.isArray(type) && schema.type.length > 0) {\n      type = schema.type[0];\n    }\n\n    if (!type) {\n      type = inferType(schema);\n    }\n\n    var sampler = _samplers[type];\n\n    if (sampler) {\n      example = sampler(schema, options, spec, context);\n    }\n  }\n\n  popSchemaStack(seenSchemasStack, context);\n  return {\n    value: example,\n    readOnly: schema.readOnly,\n    writeOnly: schema.writeOnly,\n    type: type\n  };\n\n  function traverseOneOrAnyOf(schema, selectedSubSchema) {\n    var inferred = tryInferExample(schema);\n\n    if (inferred !== undefined) {\n      return inferred;\n    }\n\n    var localExample = traverse(_objectSpread(_objectSpread({}, schema), {}, {\n      oneOf: undefined,\n      anyOf: undefined\n    }), options, spec, context);\n    var subSchemaExample = traverse(selectedSubSchema, options, spec, context);\n\n    if (typeof localExample.value === 'object' && typeof subSchemaExample.value === 'object') {\n      var mergedExample = mergeDeep(localExample.value, subSchemaExample.value);\n      return _objectSpread(_objectSpread({}, subSchemaExample), {}, {\n        value: mergedExample\n      });\n    }\n\n    return subSchemaExample;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}