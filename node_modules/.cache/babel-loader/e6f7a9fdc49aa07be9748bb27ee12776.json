{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.callRef = exports.getValidate = void 0;\n\nvar ref_error_1 = require(\"../../compile/ref_error\");\n\nvar code_1 = require(\"../code\");\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar names_1 = require(\"../../compile/names\");\n\nvar compile_1 = require(\"../../compile\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar def = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code: function code(cxt) {\n    var gen = cxt.gen,\n        $ref = cxt.schema,\n        it = cxt.it;\n    var baseId = it.baseId,\n        env = it.schemaEnv,\n        validateName = it.validateName,\n        opts = it.opts,\n        self = it.self;\n    var root = env.root;\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef();\n    var schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n    if (schOrEnv === undefined) throw new ref_error_1.default(baseId, $ref);\n    if (schOrEnv instanceof compile_1.SchemaEnv) return callValidate(schOrEnv);\n    return inlineRefSchema(schOrEnv);\n\n    function callRootRef() {\n      if (env === root) return callRef(cxt, validateName, env, env.$async);\n      var rootName = gen.scopeValue(\"root\", {\n        ref: root\n      });\n      return callRef(cxt, codegen_1._(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \".validate\"])), rootName), root, root.$async);\n    }\n\n    function callValidate(sch) {\n      var v = getValidate(cxt, sch);\n      callRef(cxt, v, sch, sch.$async);\n    }\n\n    function inlineRefSchema(sch) {\n      var schName = gen.scopeValue(\"schema\", opts.code.source === true ? {\n        ref: sch,\n        code: codegen_1.stringify(sch)\n      } : {\n        ref: sch\n      });\n      var valid = gen.name(\"valid\");\n      var schCxt = cxt.subschema({\n        schema: sch,\n        dataTypes: [],\n        schemaPath: codegen_1.nil,\n        topSchemaRef: schName,\n        errSchemaPath: $ref\n      }, valid);\n      cxt.mergeEvaluated(schCxt);\n      cxt.ok(valid);\n    }\n  }\n};\n\nfunction getValidate(cxt, sch) {\n  var gen = cxt.gen;\n  return sch.validate ? gen.scopeValue(\"validate\", {\n    ref: sch.validate\n  }) : codegen_1._(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \".validate\"])), gen.scopeValue(\"wrapper\", {\n    ref: sch\n  }));\n}\n\nexports.getValidate = getValidate;\n\nfunction callRef(cxt, v, sch, $async) {\n  var gen = cxt.gen,\n      it = cxt.it;\n  var allErrors = it.allErrors,\n      env = it.schemaEnv,\n      opts = it.opts;\n  var passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n  if ($async) callAsyncRef();else callSyncRef();\n\n  function callAsyncRef() {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\");\n    var valid = gen.let(\"valid\");\n    gen.try(function () {\n      gen.code(codegen_1._(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"await \", \"\"])), code_1.callValidateCode(cxt, v, passCxt)));\n      addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n\n      if (!allErrors) gen.assign(valid, true);\n    }, function (e) {\n      gen.if(codegen_1._(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"!(\", \" instanceof \", \")\"])), e, it.ValidationError), function () {\n        return gen.throw(e);\n      });\n      addErrorsFrom(e);\n      if (!allErrors) gen.assign(valid, false);\n    });\n    cxt.ok(valid);\n  }\n\n  function callSyncRef() {\n    var visitedNodes = gen.name(\"visitedNodes\");\n    gen.code(codegen_1._(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"const \", \" = visitedNodesForRef.get(\", \") || new Set()\"])), visitedNodes, v));\n    gen.if(codegen_1._(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"!\", \".has(\", \")\"])), visitedNodes, cxt.data), function () {\n      gen.code(codegen_1._(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"visitedNodesForRef.set(\", \", \", \")\"])), v, visitedNodes));\n      gen.code(codegen_1._(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"const dataNode = \", \"\"])), cxt.data));\n      gen.code(codegen_1._(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \".add(dataNode)\"])), visitedNodes));\n      var res = cxt.result(code_1.callValidateCode(cxt, v, passCxt), function () {\n        return addEvaluatedFrom(v);\n      }, function () {\n        return addErrorsFrom(v);\n      });\n      gen.code(codegen_1._(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \".delete(dataNode)\"])), visitedNodes));\n      return res;\n    });\n  }\n\n  function addErrorsFrom(source) {\n    var errs = codegen_1._(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\", \".errors\"])), source);\n\n    gen.assign(names_1.default.vErrors, codegen_1._(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"\", \" === null ? \", \" : \", \".concat(\", \")\"])), names_1.default.vErrors, errs, names_1.default.vErrors, errs)); // TODO tagged\n\n    gen.assign(names_1.default.errors, codegen_1._(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"\", \".length\"])), names_1.default.vErrors));\n  }\n\n  function addEvaluatedFrom(source) {\n    var _a;\n\n    if (!it.opts.unevaluated) return;\n    var schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated; // TODO refactor\n\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n        }\n      } else {\n        var props = gen.var(\"props\", codegen_1._(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\", \".evaluated.props\"])), source));\n        it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n      }\n    }\n\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n        }\n      } else {\n        var items = gen.var(\"items\", codegen_1._(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"\", \".evaluated.items\"])), source));\n        it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n      }\n    }\n  }\n}\n\nexports.callRef = callRef;\nexports.default = def; //# sourceMappingURL=ref.js.map","map":null,"metadata":{},"sourceType":"script"}