{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst validate_1 = require(\"../../compile/validate\");\n\nconst code_1 = require(\"../code\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst additionalProperties_1 = require(\"./additionalProperties\");\n\nconst def = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      it\n    } = cxt;\n\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined || it.opts.defaultAdditionalProperties === false) {\n      additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n    }\n\n    const allProps = code_1.allSchemaProperties(schema);\n\n    for (const prop of allProps) {\n      it.definedProperties.add(prop);\n    }\n\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = util_1.mergeEvaluated.props(gen, util_1.toHash(allProps), it.props);\n    }\n\n    const properties = allProps.filter(p => !util_1.alwaysValidSchema(it, schema[p]));\n    if (properties.length === 0) return;\n    const valid = gen.name(\"valid\");\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop);\n      } else {\n        gen.if(code_1.propertyInData(gen, data, prop, it.opts.ownProperties));\n        applyPropertySchema(prop);\n        if (!it.allErrors) gen.else().var(valid, true);\n        gen.endIf();\n      }\n\n      cxt.it.definedProperties.add(prop);\n      cxt.ok(valid);\n    }\n\n    function hasDefault(prop) {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n    }\n\n    function applyPropertySchema(prop) {\n      cxt.subschema({\n        keyword: \"properties\",\n        schemaProp: prop,\n        dataProp: prop\n      }, valid);\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":";;;;;;AACA;;AACA;;AACA;;AACA;;AAEA,MAAMA,GAAG,GAA0B;EACjCC,OAAO,EAAE,YADwB;EAEjCC,IAAI,EAAE,QAF2B;EAGjCC,UAAU,EAAE,QAHqB;;EAIjCC,IAAI,CAACC,GAAD,EAAgB;IAClB,MAAM;MAACC,GAAD;MAAMC,MAAN;MAAcC,YAAd;MAA4BC,IAA5B;MAAkCC;IAAlC,IAAwCL,GAA9C;;IACA,IAAIK,EAAE,CAACC,IAAH,CAAQC,gBAAR,KAA6B,KAA7B,IAAsCJ,YAAY,CAACK,oBAAb,KAAsCC,SAA5E,IAAyFJ,EAAE,CAACC,IAAH,CAAQI,2BAAR,KAAwC,KAArI,EAA4I;MAC1IC,+BAAMZ,IAAN,CAAW,IAAIa,qBAAJ,CAAeP,EAAf,EAAmBM,8BAAnB,EAA0B,sBAA1B,CAAX;IACD;;IACD,MAAME,QAAQ,GAAGC,2BAAoBZ,MAApB,CAAjB;;IACA,KAAK,MAAMa,IAAX,IAAmBF,QAAnB,EAA6B;MAC3BR,EAAE,CAACW,iBAAH,CAAqBC,GAArB,CAAyBF,IAAzB;IACD;;IACD,IAAIV,EAAE,CAACC,IAAH,CAAQY,WAAR,IAAuBL,QAAQ,CAACM,MAAhC,IAA0Cd,EAAE,CAACe,KAAH,KAAa,IAA3D,EAAiE;MAC/Df,EAAE,CAACe,KAAH,GAAWC,sBAAeD,KAAf,CAAqBnB,GAArB,EAA0BoB,cAAOR,QAAP,CAA1B,EAA4CR,EAAE,CAACe,KAA/C,CAAX;IACD;;IACD,MAAME,UAAU,GAAGT,QAAQ,CAACU,MAAT,CAAiBC,CAAD,IAAO,CAACH,yBAAkBhB,EAAlB,EAAsBH,MAAM,CAACsB,CAAD,CAA5B,CAAxB,CAAnB;IACA,IAAIF,UAAU,CAACH,MAAX,KAAsB,CAA1B,EAA6B;IAC7B,MAAMM,KAAK,GAAGxB,GAAG,CAACyB,IAAJ,CAAS,OAAT,CAAd;;IAEA,KAAK,MAAMX,IAAX,IAAmBO,UAAnB,EAA+B;MAC7B,IAAIK,UAAU,CAACZ,IAAD,CAAd,EAAsB;QACpBa,mBAAmB,CAACb,IAAD,CAAnB;MACD,CAFD,MAEO;QACLd,GAAG,CAAC4B,EAAJ,CAAOf,sBAAeb,GAAf,EAAoBG,IAApB,EAA0BW,IAA1B,EAAgCV,EAAE,CAACC,IAAH,CAAQwB,aAAxC,CAAP;QACAF,mBAAmB,CAACb,IAAD,CAAnB;QACA,IAAI,CAACV,EAAE,CAAC0B,SAAR,EAAmB9B,GAAG,CAAC+B,IAAJ,GAAWC,GAAX,CAAeR,KAAf,EAAsB,IAAtB;QACnBxB,GAAG,CAACiC,KAAJ;MACD;;MACDlC,GAAG,CAACK,EAAJ,CAAOW,iBAAP,CAAyBC,GAAzB,CAA6BF,IAA7B;MACAf,GAAG,CAACmC,EAAJ,CAAOV,KAAP;IACD;;IAED,SAASE,UAAT,CAAoBZ,IAApB,EAAgC;MAC9B,OAAOV,EAAE,CAACC,IAAH,CAAQ8B,WAAR,IAAuB,CAAC/B,EAAE,CAACgC,aAA3B,IAA4CnC,MAAM,CAACa,IAAD,CAAN,CAAauB,OAAb,KAAyB7B,SAA5E;IACD;;IAED,SAASmB,mBAAT,CAA6Bb,IAA7B,EAAyC;MACvCf,GAAG,CAACuC,SAAJ,CACE;QACE3C,OAAO,EAAE,YADX;QAEE4C,UAAU,EAAEzB,IAFd;QAGE0B,QAAQ,EAAE1B;MAHZ,CADF,EAMEU,KANF;IAQD;EACF;;AA/CgC,CAAnC;AAkDAiB,kBAAe/C,GAAf","names":["def","keyword","type","schemaType","code","cxt","gen","schema","parentSchema","data","it","opts","removeAdditional","additionalProperties","undefined","defaultAdditionalProperties","additionalProperties_1","validate_1","allProps","code_1","prop","definedProperties","add","unevaluated","length","props","util_1","properties","filter","p","valid","name","hasDefault","applyPropertySchema","if","ownProperties","allErrors","else","var","endIf","ok","useDefaults","compositeRule","default","subschema","schemaProp","dataProp","exports"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\vocabularies\\applicator\\properties.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined || it.opts.defaultAdditionalProperties === false) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}