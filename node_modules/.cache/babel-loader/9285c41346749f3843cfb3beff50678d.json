{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        min,\n        max\n      }\n    } = _ref;\n    return max === undefined ? codegen_1.str`must contain at least ${min} valid item(s)` : codegen_1.str`must contain at least ${min} and no more than ${max} valid item(s)`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        min,\n        max\n      }\n    } = _ref2;\n    return max === undefined ? codegen_1._`{minContains: ${min}}` : codegen_1._`{minContains: ${min}, maxContains: ${max}}`;\n  }\n};\nconst def = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      it\n    } = cxt;\n    let min;\n    let max;\n    const {\n      minContains,\n      maxContains\n    } = parentSchema;\n\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains;\n      max = maxContains;\n    } else {\n      min = 1;\n    }\n\n    const len = gen.const(\"len\", codegen_1._`${data}.length`);\n    cxt.setParams({\n      min,\n      max\n    });\n\n    if (max === undefined && min === 0) {\n      util_1.checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n      return;\n    }\n\n    if (max !== undefined && min > max) {\n      util_1.checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`);\n      cxt.fail();\n      return;\n    }\n\n    if (util_1.alwaysValidSchema(it, schema)) {\n      let cond = codegen_1._`${len} >= ${min}`;\n      if (max !== undefined) cond = codegen_1._`${cond} && ${len} <= ${max}`;\n      cxt.pass(cond);\n      return;\n    }\n\n    it.items = true;\n    const valid = gen.name(\"valid\");\n\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()));\n    } else {\n      gen.let(valid, false);\n      const schValid = gen.name(\"_valid\");\n      const count = gen.let(\"count\", 0);\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n    }\n\n    cxt.result(valid, () => cxt.reset());\n\n    function validateItems(_valid, block) {\n      gen.forRange(\"i\", 0, len, i => {\n        cxt.subschema({\n          keyword: \"contains\",\n          dataProp: i,\n          dataPropType: util_1.Type.Num,\n          compositeRule: true\n        }, _valid);\n        block();\n      });\n    }\n\n    function checkLimits(count) {\n      gen.code(codegen_1._`${count}++`);\n\n      if (max === undefined) {\n        gen.if(codegen_1._`${count} >= ${min}`, () => gen.assign(valid, true).break());\n      } else {\n        gen.if(codegen_1._`${count} > ${max}`, () => gen.assign(valid, false).break());\n        if (min === 1) gen.assign(valid, true);else gen.if(codegen_1._`${count} >= ${min}`, () => gen.assign(valid, true));\n      }\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","min","max","undefined","codegen_1","def","keyword","type","schemaType","before","trackErrors","code","cxt","gen","schema","parentSchema","data","it","minContains","maxContains","opts","next","len","const","setParams","util_1","fail","cond","pass","items","valid","name","validateItems","if","break","let","schValid","count","checkLimits","result","reset","_valid","block","forRange","i","subschema","dataProp","dataPropType","Num","compositeRule","assign","exports"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\vocabularies\\applicator\\contains.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else {\n      gen.let(valid, false)\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}