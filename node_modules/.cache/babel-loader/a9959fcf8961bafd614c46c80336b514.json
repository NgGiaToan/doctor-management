{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst equal_1 = require(\"../../runtime/equal\");\n\nconst error = {\n  message: \"must be equal to one of the allowed values\",\n  params: _ref => {\n    let {\n      schemaCode\n    } = _ref;\n    return codegen_1._`{allowedValues: ${schemaCode}}`;\n  }\n};\nconst def = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\");\n    const useLoop = schema.length >= it.opts.loopEnum;\n    const eql = util_1.useFunc(gen, equal_1.default);\n    let valid;\n\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\");\n      cxt.block$data(valid, loopEnum);\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n      const vSchema = gen.const(\"vSchema\", schemaCode);\n      valid = codegen_1.or(...schema.map((_x, i) => equalCode(vSchema, i)));\n    }\n\n    cxt.pass(valid);\n\n    function loopEnum() {\n      gen.assign(valid, false);\n      gen.forOf(\"v\", schemaCode, v => gen.if(codegen_1._`${eql}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n    }\n\n    function equalCode(vSchema, i) {\n      const sch = schema[i];\n      return typeof sch === \"object\" && sch !== null ? codegen_1._`${eql}(${data}, ${vSchema}[${i}])` : codegen_1._`${data} === ${sch}`;\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":";;;;;;AAEA;;AACA;;AACA;;AAIA,MAAMA,KAAK,GAA2B;EACpCC,OAAO,EAAE,4CAD2B;EAEpCC,MAAM,EAAE;IAAA,IAAC;MAACC;IAAD,CAAD;IAAA,OAAkBC,WAAC,mBAAmBD,UAAU,GAAhD;EAAA;AAF4B,CAAtC;AAKA,MAAME,GAAG,GAA0B;EACjCC,OAAO,EAAE,MADwB;EAEjCC,UAAU,EAAE,OAFqB;EAGjCC,KAAK,EAAE,IAH0B;EAIjCR,KAJiC;;EAKjCS,IAAI,CAACC,GAAD,EAAgB;IAClB,MAAM;MAACC,GAAD;MAAMC,IAAN;MAAYJ,KAAZ;MAAmBK,MAAnB;MAA2BV,UAA3B;MAAuCW;IAAvC,IAA6CJ,GAAnD;IACA,IAAI,CAACF,KAAD,IAAUK,MAAM,CAACE,MAAP,KAAkB,CAAhC,EAAmC,MAAM,IAAIC,KAAJ,CAAU,gCAAV,CAAN;IACnC,MAAMC,OAAO,GAAGJ,MAAM,CAACE,MAAP,IAAiBD,EAAE,CAACI,IAAH,CAAQC,QAAzC;IACA,MAAMC,GAAG,GAAGC,eAAQV,GAAR,EAAaW,eAAb,CAAZ;IACA,IAAIC,KAAJ;;IACA,IAAIN,OAAO,IAAIT,KAAf,EAAsB;MACpBe,KAAK,GAAGZ,GAAG,CAACa,GAAJ,CAAQ,OAAR,CAAR;MACAd,GAAG,CAACe,UAAJ,CAAeF,KAAf,EAAsBJ,QAAtB;IACD,CAHD,MAGO;MACL;MACA,IAAI,CAACO,KAAK,CAACC,OAAN,CAAcd,MAAd,CAAL,EAA4B,MAAM,IAAIG,KAAJ,CAAU,0BAAV,CAAN;MAC5B,MAAMY,OAAO,GAAGjB,GAAG,CAACkB,KAAJ,CAAU,SAAV,EAAqB1B,UAArB,CAAhB;MACAoB,KAAK,GAAGnB,aAAG,GAAGS,MAAM,CAACiB,GAAP,CAAW,CAACC,EAAD,EAAcC,CAAd,KAA4BC,SAAS,CAACL,OAAD,EAAUI,CAAV,CAAhD,CAAN,CAAR;IACD;;IACDtB,GAAG,CAACwB,IAAJ,CAASX,KAAT;;IAEA,SAASJ,QAAT,GAAiB;MACfR,GAAG,CAACwB,MAAJ,CAAWZ,KAAX,EAAkB,KAAlB;MACAZ,GAAG,CAACyB,KAAJ,CAAU,GAAV,EAAejC,UAAf,EAAoCkC,CAAD,IACjC1B,GAAG,CAAC2B,EAAJ,CAAOlC,WAAC,GAAGgB,GAAG,IAAIR,IAAI,KAAKyB,CAAC,GAA5B,EAAiC,MAAM1B,GAAG,CAACwB,MAAJ,CAAWZ,KAAX,EAAkB,IAAlB,EAAwBgB,KAAxB,EAAvC,CADF;IAGD;;IAED,SAASN,SAAT,CAAmBL,OAAnB,EAAkCI,CAAlC,EAA2C;MACzC,MAAMQ,GAAG,GAAG3B,MAAM,CAACmB,CAAD,CAAlB;MACA,OAAO,OAAOQ,GAAP,KAAe,QAAf,IAA2BA,GAAG,KAAK,IAAnC,GACHpC,WAAC,GAAGgB,GAAG,IAAIR,IAAI,KAAKgB,OAAO,IAAII,CAAC,IAD7B,GAEH5B,WAAC,GAAGQ,IAAI,QAAQ4B,GAAG,EAFvB;IAGD;EACF;;AAnCgC,CAAnC;AAsCAC,kBAAepC,GAAf","names":["error","message","params","schemaCode","codegen_1","def","keyword","schemaType","$data","code","cxt","gen","data","schema","it","length","Error","useLoop","opts","loopEnum","eql","util_1","equal_1","valid","let","block$data","Array","isArray","vSchema","const","map","_x","i","equalCode","pass","assign","forOf","v","if","break","sch","exports"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\vocabularies\\validation\\enum.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    const eql = useFunc(gen, equal)\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${eql}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${eql}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}