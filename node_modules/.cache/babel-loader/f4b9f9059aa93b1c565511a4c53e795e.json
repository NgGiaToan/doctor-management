{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\giato\\\\Downloads\\\\Workspace\\\\.Net\\\\api\\\\doctor-management-fe\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\");\n\nvar _slicedToArray = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _assertThisInitialized = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _inherits = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _wrapNativeSuper = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/wrapNativeSuper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveDocument = exports.BaseResolver = exports.makeDocumentFromString = exports.makeRefId = exports.YamlParseError = exports.ResolveError = exports.Source = void 0;\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar ref_utils_1 = require(\"./ref-utils\");\n\nvar types_1 = require(\"./types\");\n\nvar utils_1 = require(\"./utils\");\n\nvar Source = /*#__PURE__*/function () {\n  function Source(absoluteRef, body, mimeType) {\n    _classCallCheck(this, Source);\n\n    this.absoluteRef = absoluteRef;\n    this.body = body;\n    this.mimeType = mimeType;\n  } // pass safeLoad as argument to separate it from browser bundle\n\n\n  _createClass(Source, [{\n    key: \"getAst\",\n    value: function getAst(safeLoad) {\n      var _a;\n\n      if (this._ast === undefined) {\n        this._ast = (_a = safeLoad(this.body, {\n          filename: this.absoluteRef\n        })) !== null && _a !== void 0 ? _a : undefined; // fix ast representation of file with newlines only\n\n        if (this._ast && this._ast.kind === 0 && // KIND.scalar = 0\n        this._ast.value === '' && this._ast.startPosition !== 1) {\n          this._ast.startPosition = 1;\n          this._ast.endPosition = 1;\n        }\n      }\n\n      return this._ast;\n    }\n  }, {\n    key: \"getLines\",\n    value: function getLines() {\n      if (this._lines === undefined) {\n        this._lines = this.body.split(/\\r\\n|[\\n\\r]/g);\n      }\n\n      return this._lines;\n    }\n  }]);\n\n  return Source;\n}();\n\nexports.Source = Source;\n\nvar ResolveError = /*#__PURE__*/function (_Error) {\n  _inherits(ResolveError, _Error);\n\n  var _super = _createSuper(ResolveError);\n\n  function ResolveError(originalError) {\n    var _this;\n\n    _classCallCheck(this, ResolveError);\n\n    _this = _super.call(this, originalError.message);\n    _this.originalError = originalError; // Set the prototype explicitly.\n\n    Object.setPrototypeOf(_assertThisInitialized(_this), ResolveError.prototype);\n    return _this;\n  }\n\n  return _createClass(ResolveError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.ResolveError = ResolveError;\nvar jsYamlErrorLineColRegexp = /\\((\\d+):(\\d+)\\)$/;\n\nvar YamlParseError = /*#__PURE__*/function (_Error2) {\n  _inherits(YamlParseError, _Error2);\n\n  var _super2 = _createSuper(YamlParseError);\n\n  function YamlParseError(originalError, source) {\n    var _this2;\n\n    _classCallCheck(this, YamlParseError);\n\n    _this2 = _super2.call(this, originalError.message.split('\\n')[0]);\n    _this2.originalError = originalError;\n    _this2.source = source; // Set the prototype explicitly.\n\n    Object.setPrototypeOf(_assertThisInitialized(_this2), YamlParseError.prototype);\n\n    var _ref = _this2.message.match(jsYamlErrorLineColRegexp) || [],\n        _ref2 = _slicedToArray(_ref, 3),\n        line = _ref2[1],\n        col = _ref2[2];\n\n    _this2.line = parseInt(line, 10);\n    _this2.col = parseInt(col, 10);\n    return _this2;\n  }\n\n  return _createClass(YamlParseError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.YamlParseError = YamlParseError;\n\nfunction makeRefId(absoluteRef, pointer) {\n  return absoluteRef + '::' + pointer;\n}\n\nexports.makeRefId = makeRefId;\n\nfunction makeDocumentFromString(sourceString, absoluteRef) {\n  var source = new Source(absoluteRef, sourceString);\n\n  try {\n    return {\n      source: source,\n      parsed: utils_1.parseYaml(sourceString, {\n        filename: absoluteRef\n      })\n    };\n  } catch (e) {\n    throw new YamlParseError(e, source);\n  }\n}\n\nexports.makeDocumentFromString = makeDocumentFromString;\n\nvar BaseResolver = /*#__PURE__*/function () {\n  function BaseResolver() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      http: {\n        headers: []\n      }\n    };\n\n    _classCallCheck(this, BaseResolver);\n\n    this.config = config;\n    this.cache = new Map();\n  }\n\n  _createClass(BaseResolver, [{\n    key: \"getFiles\",\n    value: function getFiles() {\n      return new Set(Array.from(this.cache.keys()));\n    }\n  }, {\n    key: \"resolveExternalRef\",\n    value: function resolveExternalRef(base, ref) {\n      if (ref_utils_1.isAbsoluteUrl(ref)) {\n        return ref;\n      }\n\n      if (base && ref_utils_1.isAbsoluteUrl(base)) {\n        return new URL(ref, base).href;\n      }\n\n      return path.resolve(base ? path.dirname(base) : process.cwd(), ref);\n    }\n  }, {\n    key: \"loadExternalRef\",\n    value: function loadExternalRef(absoluteRef) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _yield$utils_1$readFi, body, mimeType;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n\n                if (!ref_utils_1.isAbsoluteUrl(absoluteRef)) {\n                  _context.next = 10;\n                  break;\n                }\n\n                _context.next = 4;\n                return utils_1.readFileFromUrl(absoluteRef, this.config.http);\n\n              case 4:\n                _yield$utils_1$readFi = _context.sent;\n                body = _yield$utils_1$readFi.body;\n                mimeType = _yield$utils_1$readFi.mimeType;\n                return _context.abrupt(\"return\", new Source(absoluteRef, body, mimeType));\n\n              case 10:\n                _context.t0 = Source;\n                _context.t1 = absoluteRef;\n                _context.next = 14;\n                return fs.promises.readFile(absoluteRef, 'utf-8');\n\n              case 14:\n                _context.t2 = _context.sent;\n                return _context.abrupt(\"return\", new _context.t0(_context.t1, _context.t2));\n\n              case 16:\n                _context.next = 21;\n                break;\n\n              case 18:\n                _context.prev = 18;\n                _context.t3 = _context[\"catch\"](0);\n                throw new ResolveError(_context.t3);\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 18]]);\n      }));\n    }\n  }, {\n    key: \"parseDocument\",\n    value: function parseDocument(source) {\n      var isRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var _a;\n\n      var ext = source.absoluteRef.substr(source.absoluteRef.lastIndexOf('.'));\n\n      if (!['.json', '.json', '.yml', '.yaml'].includes(ext) && !((_a = source.mimeType) === null || _a === void 0 ? void 0 : _a.match(/(json|yaml|openapi)/)) && !isRoot // always parse root\n      ) {\n        return {\n          source: source,\n          parsed: source.body\n        };\n      }\n\n      try {\n        return {\n          source: source,\n          parsed: utils_1.parseYaml(source.body, {\n            filename: source.absoluteRef\n          })\n        };\n      } catch (e) {\n        throw new YamlParseError(e, source);\n      }\n    }\n  }, {\n    key: \"resolveDocument\",\n    value: function resolveDocument(base, ref) {\n      var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this3 = this;\n\n        var absoluteRef, cachedDocument, doc;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                absoluteRef = this.resolveExternalRef(base, ref);\n                cachedDocument = this.cache.get(absoluteRef);\n\n                if (!cachedDocument) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", cachedDocument);\n\n              case 4:\n                doc = this.loadExternalRef(absoluteRef).then(function (source) {\n                  return _this3.parseDocument(source, isRoot);\n                });\n                this.cache.set(absoluteRef, doc);\n                return _context2.abrupt(\"return\", doc);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }]);\n\n  return BaseResolver;\n}();\n\nexports.BaseResolver = BaseResolver;\n\nfunction pushRef(head, node) {\n  return {\n    prev: head,\n    node: node\n  };\n}\n\nfunction hasRef(head, node) {\n  while (head) {\n    if (head.node === node) {\n      return true;\n    }\n\n    head = head.prev;\n  }\n\n  return false;\n}\n\nvar unknownType = {\n  name: 'unknown',\n  properties: {}\n};\nvar resolvableScalarType = {\n  name: 'scalar',\n  properties: {}\n};\n\nfunction resolveDocument(opts) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n    var rootDocument, externalRefResolver, rootType, resolvedRefMap, seedNodes, resolvePromises, resolved, resolveRefsInParallel;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            resolveRefsInParallel = function _resolveRefsInParalle(rootNode, rootNodeDocument, rootNodePointer, type) {\n              var rootNodeDocAbsoluteRef = rootNodeDocument.source.absoluteRef;\n              walk(rootNode, type, rootNodeDocAbsoluteRef + rootNodePointer);\n\n              function walk(node, type, nodeAbsoluteRef) {\n                if (typeof node !== 'object' || node === null) {\n                  return;\n                }\n\n                var nodeId = \"\".concat(type.name, \"::\").concat(nodeAbsoluteRef);\n\n                if (seedNodes.has(nodeId)) {\n                  return;\n                }\n\n                seedNodes.add(nodeId);\n\n                if (Array.isArray(node)) {\n                  var itemsType = type.items; // we continue resolving unknown types, but stop early on known scalars\n\n                  if (type !== unknownType && itemsType === undefined) {\n                    return;\n                  }\n\n                  for (var i = 0; i < node.length; i++) {\n                    walk(node[i], itemsType || unknownType, ref_utils_1.joinPointer(nodeAbsoluteRef, i));\n                  }\n\n                  return;\n                }\n\n                for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {\n                  var propName = _Object$keys[_i];\n                  var propValue = node[propName];\n                  var propType = type.properties[propName];\n                  if (propType === undefined) propType = type.additionalProperties;\n                  if (typeof propType === 'function') propType = propType(propValue, propName);\n                  if (propType === undefined) propType = unknownType;\n\n                  if (!types_1.isNamedType(propType) && (propType === null || propType === void 0 ? void 0 : propType.directResolveAs)) {\n                    propType = propType.directResolveAs;\n                    propValue = {\n                      $ref: propValue\n                    };\n                  }\n\n                  if (propType && propType.name === undefined && propType.resolvable !== false) {\n                    propType = resolvableScalarType;\n                  }\n\n                  if (!types_1.isNamedType(propType) || typeof propValue !== 'object') {\n                    continue;\n                  }\n\n                  walk(propValue, propType, ref_utils_1.joinPointer(nodeAbsoluteRef, ref_utils_1.escapePointer(propName)));\n                }\n\n                if (ref_utils_1.isRef(node)) {\n                  var promise = followRef(rootNodeDocument, node, {\n                    prev: null,\n                    node: node\n                  }).then(function (resolvedRef) {\n                    if (resolvedRef.resolved) {\n                      resolveRefsInParallel(resolvedRef.node, resolvedRef.document, resolvedRef.nodePointer, type);\n                    }\n                  });\n                  resolvePromises.push(promise);\n                }\n              }\n\n              function followRef(document, ref, refStack) {\n                return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                  var _ref_utils_1$parseRef, uri, pointer, isRemote, targetDoc, _resolvedRef, _refId, resolvedRef, target, segments, _iterator, _step, segment, refId;\n\n                  return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          if (!hasRef(refStack.prev, ref)) {\n                            _context3.next = 2;\n                            break;\n                          }\n\n                          throw new Error('Self-referencing circular pointer');\n\n                        case 2:\n                          _ref_utils_1$parseRef = ref_utils_1.parseRef(ref.$ref), uri = _ref_utils_1$parseRef.uri, pointer = _ref_utils_1$parseRef.pointer;\n                          isRemote = uri !== null;\n                          _context3.prev = 4;\n\n                          if (!isRemote) {\n                            _context3.next = 11;\n                            break;\n                          }\n\n                          _context3.next = 8;\n                          return externalRefResolver.resolveDocument(document.source.absoluteRef, uri);\n\n                        case 8:\n                          _context3.t0 = _context3.sent;\n                          _context3.next = 12;\n                          break;\n\n                        case 11:\n                          _context3.t0 = document;\n\n                        case 12:\n                          targetDoc = _context3.t0;\n                          _context3.next = 21;\n                          break;\n\n                        case 15:\n                          _context3.prev = 15;\n                          _context3.t1 = _context3[\"catch\"](4);\n                          _resolvedRef = {\n                            resolved: false,\n                            isRemote: isRemote,\n                            document: undefined,\n                            error: _context3.t1\n                          };\n                          _refId = makeRefId(document.source.absoluteRef, ref.$ref);\n                          resolvedRefMap.set(_refId, _resolvedRef);\n                          return _context3.abrupt(\"return\", _resolvedRef);\n\n                        case 21:\n                          resolvedRef = {\n                            resolved: true,\n                            document: targetDoc,\n                            isRemote: isRemote,\n                            node: document.parsed,\n                            nodePointer: '#/'\n                          };\n                          target = targetDoc.parsed;\n                          segments = pointer;\n                          _iterator = _createForOfIteratorHelper(segments);\n                          _context3.prev = 25;\n\n                          _iterator.s();\n\n                        case 27:\n                          if ((_step = _iterator.n()).done) {\n                            _context3.next = 55;\n                            break;\n                          }\n\n                          segment = _step.value;\n\n                          if (!(typeof target !== 'object')) {\n                            _context3.next = 34;\n                            break;\n                          }\n\n                          target = undefined;\n                          return _context3.abrupt(\"break\", 55);\n\n                        case 34:\n                          if (!(target[segment] !== undefined)) {\n                            _context3.next = 39;\n                            break;\n                          }\n\n                          target = target[segment];\n                          resolvedRef.nodePointer = ref_utils_1.joinPointer(resolvedRef.nodePointer, ref_utils_1.escapePointer(segment));\n                          _context3.next = 53;\n                          break;\n\n                        case 39:\n                          if (!ref_utils_1.isRef(target)) {\n                            _context3.next = 51;\n                            break;\n                          }\n\n                          _context3.next = 42;\n                          return followRef(targetDoc, target, pushRef(refStack, target));\n\n                        case 42:\n                          resolvedRef = _context3.sent;\n                          targetDoc = resolvedRef.document || targetDoc;\n\n                          if (!(typeof resolvedRef.node !== 'object')) {\n                            _context3.next = 47;\n                            break;\n                          }\n\n                          target = undefined;\n                          return _context3.abrupt(\"break\", 55);\n\n                        case 47:\n                          target = resolvedRef.node[segment];\n                          resolvedRef.nodePointer = ref_utils_1.joinPointer(resolvedRef.nodePointer, ref_utils_1.escapePointer(segment));\n                          _context3.next = 53;\n                          break;\n\n                        case 51:\n                          target = undefined;\n                          return _context3.abrupt(\"break\", 55);\n\n                        case 53:\n                          _context3.next = 27;\n                          break;\n\n                        case 55:\n                          _context3.next = 60;\n                          break;\n\n                        case 57:\n                          _context3.prev = 57;\n                          _context3.t2 = _context3[\"catch\"](25);\n\n                          _iterator.e(_context3.t2);\n\n                        case 60:\n                          _context3.prev = 60;\n\n                          _iterator.f();\n\n                          return _context3.finish(60);\n\n                        case 63:\n                          resolvedRef.node = target;\n                          resolvedRef.document = targetDoc;\n                          refId = makeRefId(document.source.absoluteRef, ref.$ref);\n\n                          if (!(resolvedRef.document && ref_utils_1.isRef(target))) {\n                            _context3.next = 70;\n                            break;\n                          }\n\n                          _context3.next = 69;\n                          return followRef(resolvedRef.document, target, pushRef(refStack, target));\n\n                        case 69:\n                          resolvedRef = _context3.sent;\n\n                        case 70:\n                          resolvedRefMap.set(refId, resolvedRef);\n                          return _context3.abrupt(\"return\", Object.assign({}, resolvedRef));\n\n                        case 72:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3, null, [[4, 15], [25, 57, 60, 63]]);\n                }));\n              }\n            };\n\n            rootDocument = opts.rootDocument, externalRefResolver = opts.externalRefResolver, rootType = opts.rootType;\n            resolvedRefMap = new Map();\n            seedNodes = new Set(); // format \"${type}::${absoluteRef}${pointer}\"\n\n            resolvePromises = [];\n            resolveRefsInParallel(rootDocument.parsed, rootDocument, '#/', rootType);\n\n          case 6:\n            _context4.next = 8;\n            return Promise.all(resolvePromises);\n\n          case 8:\n            resolved = _context4.sent;\n\n          case 9:\n            if (resolvePromises.length !== resolved.length) {\n              _context4.next = 6;\n              break;\n            }\n\n          case 10:\n            return _context4.abrupt(\"return\", resolvedRefMap);\n\n          case 11:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n}\n\nexports.resolveDocument = resolveDocument;","map":null,"metadata":{},"sourceType":"script"}