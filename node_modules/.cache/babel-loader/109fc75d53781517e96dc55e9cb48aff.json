{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.walkDocument = void 0;\n\nconst ref_utils_1 = require(\"./ref-utils\");\n\nconst resolve_1 = require(\"./resolve\");\n\nconst utils_1 = require(\"./utils\");\n\nconst types_1 = require(\"./types\");\n\nfunction collectParents(ctx) {\n  var _a;\n\n  const parents = {};\n\n  while (ctx.parent) {\n    parents[ctx.parent.type.name] = (_a = ctx.parent.activatedOn) === null || _a === void 0 ? void 0 : _a.value.node;\n    ctx = ctx.parent;\n  }\n\n  return parents;\n}\n\nfunction collectParentsLocations(ctx) {\n  var _a, _b;\n\n  const locations = {};\n\n  while (ctx.parent) {\n    if ((_a = ctx.parent.activatedOn) === null || _a === void 0 ? void 0 : _a.value.location) {\n      locations[ctx.parent.type.name] = (_b = ctx.parent.activatedOn) === null || _b === void 0 ? void 0 : _b.value.location;\n    }\n\n    ctx = ctx.parent;\n  }\n\n  return locations;\n}\n\nfunction walkDocument(opts) {\n  const {\n    document,\n    rootType,\n    normalizedVisitors,\n    resolvedRefMap,\n    ctx\n  } = opts;\n  const seenNodesPerType = {};\n  const seenRefs = new Set();\n  walkNode(document.parsed, rootType, new ref_utils_1.Location(document.source, '#/'), undefined, '');\n\n  function walkNode(node, type, location, parent, key) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\n    let currentLocation = location;\n    const {\n      node: resolvedNode,\n      location: resolvedLocation,\n      error\n    } = resolve(node);\n    const enteredContexts = new Set();\n\n    if (ref_utils_1.isRef(node)) {\n      const refEnterVisitors = normalizedVisitors.ref.enter;\n\n      for (const {\n        visit: visitor,\n        ruleId,\n        severity,\n        context\n      } of refEnterVisitors) {\n        if (!seenRefs.has(node)) {\n          enteredContexts.add(context);\n          const report = reportFn.bind(undefined, ruleId, severity);\n          visitor(node, {\n            report,\n            resolve,\n            location,\n            type,\n            parent,\n            key,\n            parentLocations: {},\n            oasVersion: ctx.oasVersion,\n            getVisitorData: getVisitorDataFn.bind(undefined, ruleId)\n          }, {\n            node: resolvedNode,\n            location: resolvedLocation,\n            error\n          });\n\n          if ((resolvedLocation === null || resolvedLocation === void 0 ? void 0 : resolvedLocation.source.absoluteRef) && ctx.refTypes) {\n            ctx.refTypes.set(resolvedLocation === null || resolvedLocation === void 0 ? void 0 : resolvedLocation.source.absoluteRef, type);\n          }\n        }\n      }\n    }\n\n    if (resolvedNode !== undefined && resolvedLocation && type.name !== 'scalar') {\n      currentLocation = resolvedLocation;\n      const isNodeSeen = (_b = (_a = seenNodesPerType[type.name]) === null || _a === void 0 ? void 0 : _a.has) === null || _b === void 0 ? void 0 : _b.call(_a, resolvedNode);\n      let visitedBySome = false;\n      const anyEnterVisitors = normalizedVisitors.any.enter;\n      const currentEnterVisitors = anyEnterVisitors.concat(((_c = normalizedVisitors[type.name]) === null || _c === void 0 ? void 0 : _c.enter) || []);\n      const activatedContexts = [];\n\n      for (const {\n        context,\n        visit,\n        skip,\n        ruleId,\n        severity\n      } of currentEnterVisitors) {\n        if (context.isSkippedLevel) {\n          if (context.parent.activatedOn && !context.parent.activatedOn.value.nextLevelTypeActivated && !context.seen.has(node)) {\n            // TODO: test for walk through duplicated $ref-ed node\n            context.seen.add(node);\n            visitedBySome = true;\n            activatedContexts.push(context);\n          }\n        } else {\n          if (context.parent && // if nested\n          context.parent.activatedOn && ((_d = context.activatedOn) === null || _d === void 0 ? void 0 : _d.value.withParentNode) !== context.parent.activatedOn.value.node && // do not enter if visited by parent children (it works thanks because deeper visitors are sorted before)\n          ((_e = context.parent.activatedOn.value.nextLevelTypeActivated) === null || _e === void 0 ? void 0 : _e.value) !== type || !context.parent && !isNodeSeen // if top-level visit each node just once\n          ) {\n            activatedContexts.push(context);\n            const activatedOn = {\n              node: resolvedNode,\n              location: resolvedLocation,\n              nextLevelTypeActivated: null,\n              withParentNode: (_g = (_f = context.parent) === null || _f === void 0 ? void 0 : _f.activatedOn) === null || _g === void 0 ? void 0 : _g.value.node,\n              skipped: (_k = ((_j = (_h = context.parent) === null || _h === void 0 ? void 0 : _h.activatedOn) === null || _j === void 0 ? void 0 : _j.value.skipped) || (skip === null || skip === void 0 ? void 0 : skip(resolvedNode, key))) !== null && _k !== void 0 ? _k : false\n            };\n            context.activatedOn = utils_1.pushStack(context.activatedOn, activatedOn);\n            let ctx = context.parent;\n\n            while (ctx) {\n              ctx.activatedOn.value.nextLevelTypeActivated = utils_1.pushStack(ctx.activatedOn.value.nextLevelTypeActivated, type);\n              ctx = ctx.parent;\n            }\n\n            if (!activatedOn.skipped) {\n              visitedBySome = true;\n              enteredContexts.add(context);\n              const {\n                ignoreNextVisitorsOnNode\n              } = visitWithContext(visit, resolvedNode, context, ruleId, severity);\n              if (ignoreNextVisitorsOnNode) break;\n            }\n          }\n        }\n      }\n\n      if (visitedBySome || !isNodeSeen) {\n        seenNodesPerType[type.name] = seenNodesPerType[type.name] || new Set();\n        seenNodesPerType[type.name].add(resolvedNode);\n\n        if (Array.isArray(resolvedNode)) {\n          const itemsType = type.items;\n\n          if (itemsType !== undefined) {\n            for (let i = 0; i < resolvedNode.length; i++) {\n              walkNode(resolvedNode[i], itemsType, resolvedLocation.child([i]), resolvedNode, i);\n            }\n          }\n        } else if (typeof resolvedNode === 'object' && resolvedNode !== null) {\n          // visit in order from type-tree first\n          const props = Object.keys(type.properties);\n\n          if (type.additionalProperties) {\n            props.push(...Object.keys(resolvedNode).filter(k => !props.includes(k)));\n          }\n\n          if (ref_utils_1.isRef(node)) {\n            props.push(...Object.keys(node).filter(k => k !== '$ref' && !props.includes(k))); // properties on the same level as $ref\n          }\n\n          for (const propName of props) {\n            let value = resolvedNode[propName];\n            let loc = resolvedLocation;\n\n            if (value === undefined) {\n              value = node[propName];\n              loc = location; // properties on the same level as $ref should resolve against original location, not target\n            }\n\n            let propType = type.properties[propName];\n            if (propType === undefined) propType = type.additionalProperties;\n            if (typeof propType === 'function') propType = propType(value, propName);\n\n            if (!types_1.isNamedType(propType) && (propType === null || propType === void 0 ? void 0 : propType.directResolveAs)) {\n              propType = propType.directResolveAs;\n              value = {\n                $ref: value\n              };\n            }\n\n            if (propType && propType.name === undefined && propType.resolvable !== false) {\n              propType = {\n                name: 'scalar',\n                properties: {}\n              };\n            }\n\n            if (!types_1.isNamedType(propType) || propType.name === 'scalar' && !ref_utils_1.isRef(value)) {\n              continue;\n            }\n\n            walkNode(value, propType, loc.child([propName]), resolvedNode, propName);\n          }\n        }\n      }\n\n      const anyLeaveVisitors = normalizedVisitors.any.leave;\n      const currentLeaveVisitors = (((_l = normalizedVisitors[type.name]) === null || _l === void 0 ? void 0 : _l.leave) || []).concat(anyLeaveVisitors);\n\n      for (const context of activatedContexts.reverse()) {\n        if (context.isSkippedLevel) {\n          context.seen.delete(resolvedNode);\n        } else {\n          context.activatedOn = utils_1.popStack(context.activatedOn);\n\n          if (context.parent) {\n            let ctx = context.parent;\n\n            while (ctx) {\n              ctx.activatedOn.value.nextLevelTypeActivated = utils_1.popStack(ctx.activatedOn.value.nextLevelTypeActivated);\n              ctx = ctx.parent;\n            }\n          }\n        }\n      }\n\n      for (const {\n        context,\n        visit,\n        ruleId,\n        severity\n      } of currentLeaveVisitors) {\n        if (!context.isSkippedLevel && enteredContexts.has(context)) {\n          visitWithContext(visit, resolvedNode, context, ruleId, severity);\n        }\n      }\n    }\n\n    currentLocation = location;\n\n    if (ref_utils_1.isRef(node)) {\n      const refLeaveVisitors = normalizedVisitors.ref.leave;\n\n      for (const {\n        visit: visitor,\n        ruleId,\n        severity,\n        context\n      } of refLeaveVisitors) {\n        if (enteredContexts.has(context)) {\n          const report = reportFn.bind(undefined, ruleId, severity);\n          visitor(node, {\n            report,\n            resolve,\n            location,\n            type,\n            parent,\n            key,\n            parentLocations: {},\n            oasVersion: ctx.oasVersion,\n            getVisitorData: getVisitorDataFn.bind(undefined, ruleId)\n          }, {\n            node: resolvedNode,\n            location: resolvedLocation,\n            error\n          });\n        }\n      }\n    } // returns true ignores all the next visitors on the specific node\n\n\n    function visitWithContext(visit, node, context, ruleId, severity) {\n      const report = reportFn.bind(undefined, ruleId, severity);\n      let ignoreNextVisitorsOnNode = false;\n      visit(node, {\n        report,\n        resolve,\n        location: currentLocation,\n        type,\n        parent,\n        key,\n        parentLocations: collectParentsLocations(context),\n        oasVersion: ctx.oasVersion,\n        ignoreNextVisitorsOnNode: () => {\n          ignoreNextVisitorsOnNode = true;\n        },\n        getVisitorData: getVisitorDataFn.bind(undefined, ruleId)\n      }, collectParents(context), context);\n      return {\n        ignoreNextVisitorsOnNode\n      };\n    }\n\n    function resolve(ref) {\n      let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentLocation.source.absoluteRef;\n      if (!ref_utils_1.isRef(ref)) return {\n        location,\n        node: ref\n      };\n      const refId = resolve_1.makeRefId(from, ref.$ref);\n      const resolvedRef = resolvedRefMap.get(refId);\n\n      if (!resolvedRef) {\n        return {\n          location: undefined,\n          node: undefined\n        };\n      }\n\n      const {\n        resolved,\n        node,\n        document,\n        nodePointer,\n        error\n      } = resolvedRef;\n      const newLocation = resolved ? new ref_utils_1.Location(document.source, nodePointer) : error instanceof resolve_1.YamlParseError ? new ref_utils_1.Location(error.source, '') : undefined;\n      return {\n        location: newLocation,\n        node,\n        error\n      };\n    }\n\n    function reportFn(ruleId, severity, opts) {\n      const loc = opts.location ? Array.isArray(opts.location) ? opts.location : [opts.location] : [Object.assign(Object.assign({}, currentLocation), {\n        reportOnKey: false\n      })];\n      ctx.problems.push(Object.assign(Object.assign({\n        ruleId: opts.ruleId || ruleId,\n        severity: opts.forceSeverity || severity\n      }, opts), {\n        suggest: opts.suggest || [],\n        location: loc.map(loc => {\n          return Object.assign(Object.assign(Object.assign({}, currentLocation), {\n            reportOnKey: false\n          }), loc);\n        })\n      }));\n    }\n\n    function getVisitorDataFn(ruleId) {\n      ctx.visitorsData[ruleId] = ctx.visitorsData[ruleId] || {};\n      return ctx.visitorsData[ruleId];\n    }\n  }\n}\n\nexports.walkDocument = walkDocument;","map":{"version":3,"names":["Object","defineProperty","exports","value","walkDocument","ref_utils_1","require","resolve_1","utils_1","types_1","collectParents","ctx","_a","parents","parent","type","name","activatedOn","node","collectParentsLocations","_b","locations","location","opts","document","rootType","normalizedVisitors","resolvedRefMap","seenNodesPerType","seenRefs","Set","walkNode","parsed","Location","source","undefined","key","_c","_d","_e","_f","_g","_h","_j","_k","_l","currentLocation","resolvedNode","resolvedLocation","error","resolve","enteredContexts","isRef","refEnterVisitors","ref","enter","visit","visitor","ruleId","severity","context","has","add","report","reportFn","bind","parentLocations","oasVersion","getVisitorData","getVisitorDataFn","absoluteRef","refTypes","set","isNodeSeen","call","visitedBySome","anyEnterVisitors","any","currentEnterVisitors","concat","activatedContexts","skip","isSkippedLevel","nextLevelTypeActivated","seen","push","withParentNode","skipped","pushStack","ignoreNextVisitorsOnNode","visitWithContext","Array","isArray","itemsType","items","i","length","child","props","keys","properties","additionalProperties","filter","k","includes","propName","loc","propType","isNamedType","directResolveAs","$ref","resolvable","anyLeaveVisitors","leave","currentLeaveVisitors","reverse","delete","popStack","refLeaveVisitors","from","refId","makeRefId","resolvedRef","get","resolved","nodePointer","newLocation","YamlParseError","assign","reportOnKey","problems","forceSeverity","suggest","map","visitorsData"],"sources":["C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@redocly/openapi-core/lib/walk.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.walkDocument = void 0;\nconst ref_utils_1 = require(\"./ref-utils\");\nconst resolve_1 = require(\"./resolve\");\nconst utils_1 = require(\"./utils\");\nconst types_1 = require(\"./types\");\nfunction collectParents(ctx) {\n    var _a;\n    const parents = {};\n    while (ctx.parent) {\n        parents[ctx.parent.type.name] = (_a = ctx.parent.activatedOn) === null || _a === void 0 ? void 0 : _a.value.node;\n        ctx = ctx.parent;\n    }\n    return parents;\n}\nfunction collectParentsLocations(ctx) {\n    var _a, _b;\n    const locations = {};\n    while (ctx.parent) {\n        if ((_a = ctx.parent.activatedOn) === null || _a === void 0 ? void 0 : _a.value.location) {\n            locations[ctx.parent.type.name] = (_b = ctx.parent.activatedOn) === null || _b === void 0 ? void 0 : _b.value.location;\n        }\n        ctx = ctx.parent;\n    }\n    return locations;\n}\nfunction walkDocument(opts) {\n    const { document, rootType, normalizedVisitors, resolvedRefMap, ctx } = opts;\n    const seenNodesPerType = {};\n    const seenRefs = new Set();\n    walkNode(document.parsed, rootType, new ref_utils_1.Location(document.source, '#/'), undefined, '');\n    function walkNode(node, type, location, parent, key) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        let currentLocation = location;\n        const { node: resolvedNode, location: resolvedLocation, error } = resolve(node);\n        const enteredContexts = new Set();\n        if (ref_utils_1.isRef(node)) {\n            const refEnterVisitors = normalizedVisitors.ref.enter;\n            for (const { visit: visitor, ruleId, severity, context } of refEnterVisitors) {\n                if (!seenRefs.has(node)) {\n                    enteredContexts.add(context);\n                    const report = reportFn.bind(undefined, ruleId, severity);\n                    visitor(node, {\n                        report,\n                        resolve,\n                        location,\n                        type,\n                        parent,\n                        key,\n                        parentLocations: {},\n                        oasVersion: ctx.oasVersion,\n                        getVisitorData: getVisitorDataFn.bind(undefined, ruleId)\n                    }, { node: resolvedNode, location: resolvedLocation, error });\n                    if ((resolvedLocation === null || resolvedLocation === void 0 ? void 0 : resolvedLocation.source.absoluteRef) && ctx.refTypes) {\n                        ctx.refTypes.set(resolvedLocation === null || resolvedLocation === void 0 ? void 0 : resolvedLocation.source.absoluteRef, type);\n                    }\n                }\n            }\n        }\n        if (resolvedNode !== undefined && resolvedLocation && type.name !== 'scalar') {\n            currentLocation = resolvedLocation;\n            const isNodeSeen = (_b = (_a = seenNodesPerType[type.name]) === null || _a === void 0 ? void 0 : _a.has) === null || _b === void 0 ? void 0 : _b.call(_a, resolvedNode);\n            let visitedBySome = false;\n            const anyEnterVisitors = normalizedVisitors.any.enter;\n            const currentEnterVisitors = anyEnterVisitors.concat(((_c = normalizedVisitors[type.name]) === null || _c === void 0 ? void 0 : _c.enter) || []);\n            const activatedContexts = [];\n            for (const { context, visit, skip, ruleId, severity } of currentEnterVisitors) {\n                if (context.isSkippedLevel) {\n                    if (context.parent.activatedOn &&\n                        !context.parent.activatedOn.value.nextLevelTypeActivated &&\n                        !context.seen.has(node)) {\n                        // TODO: test for walk through duplicated $ref-ed node\n                        context.seen.add(node);\n                        visitedBySome = true;\n                        activatedContexts.push(context);\n                    }\n                }\n                else {\n                    if ((context.parent && // if nested\n                        context.parent.activatedOn &&\n                        ((_d = context.activatedOn) === null || _d === void 0 ? void 0 : _d.value.withParentNode) !== context.parent.activatedOn.value.node &&\n                        // do not enter if visited by parent children (it works thanks because deeper visitors are sorted before)\n                        ((_e = context.parent.activatedOn.value.nextLevelTypeActivated) === null || _e === void 0 ? void 0 : _e.value) !== type) ||\n                        (!context.parent && !isNodeSeen) // if top-level visit each node just once\n                    ) {\n                        activatedContexts.push(context);\n                        const activatedOn = {\n                            node: resolvedNode,\n                            location: resolvedLocation,\n                            nextLevelTypeActivated: null,\n                            withParentNode: (_g = (_f = context.parent) === null || _f === void 0 ? void 0 : _f.activatedOn) === null || _g === void 0 ? void 0 : _g.value.node,\n                            skipped: (_k = (((_j = (_h = context.parent) === null || _h === void 0 ? void 0 : _h.activatedOn) === null || _j === void 0 ? void 0 : _j.value.skipped) || (skip === null || skip === void 0 ? void 0 : skip(resolvedNode, key)))) !== null && _k !== void 0 ? _k : false,\n                        };\n                        context.activatedOn = utils_1.pushStack(context.activatedOn, activatedOn);\n                        let ctx = context.parent;\n                        while (ctx) {\n                            ctx.activatedOn.value.nextLevelTypeActivated = utils_1.pushStack(ctx.activatedOn.value.nextLevelTypeActivated, type);\n                            ctx = ctx.parent;\n                        }\n                        if (!activatedOn.skipped) {\n                            visitedBySome = true;\n                            enteredContexts.add(context);\n                            const { ignoreNextVisitorsOnNode } = visitWithContext(visit, resolvedNode, context, ruleId, severity);\n                            if (ignoreNextVisitorsOnNode)\n                                break;\n                        }\n                    }\n                }\n            }\n            if (visitedBySome || !isNodeSeen) {\n                seenNodesPerType[type.name] = seenNodesPerType[type.name] || new Set();\n                seenNodesPerType[type.name].add(resolvedNode);\n                if (Array.isArray(resolvedNode)) {\n                    const itemsType = type.items;\n                    if (itemsType !== undefined) {\n                        for (let i = 0; i < resolvedNode.length; i++) {\n                            walkNode(resolvedNode[i], itemsType, resolvedLocation.child([i]), resolvedNode, i);\n                        }\n                    }\n                }\n                else if (typeof resolvedNode === 'object' && resolvedNode !== null) {\n                    // visit in order from type-tree first\n                    const props = Object.keys(type.properties);\n                    if (type.additionalProperties) {\n                        props.push(...Object.keys(resolvedNode).filter((k) => !props.includes(k)));\n                    }\n                    if (ref_utils_1.isRef(node)) {\n                        props.push(...Object.keys(node).filter((k) => k !== '$ref' && !props.includes(k))); // properties on the same level as $ref\n                    }\n                    for (const propName of props) {\n                        let value = resolvedNode[propName];\n                        let loc = resolvedLocation;\n                        if (value === undefined) {\n                            value = node[propName];\n                            loc = location; // properties on the same level as $ref should resolve against original location, not target\n                        }\n                        let propType = type.properties[propName];\n                        if (propType === undefined)\n                            propType = type.additionalProperties;\n                        if (typeof propType === 'function')\n                            propType = propType(value, propName);\n                        if (!types_1.isNamedType(propType) && (propType === null || propType === void 0 ? void 0 : propType.directResolveAs)) {\n                            propType = propType.directResolveAs;\n                            value = { $ref: value };\n                        }\n                        if (propType && propType.name === undefined && propType.resolvable !== false) {\n                            propType = { name: 'scalar', properties: {} };\n                        }\n                        if (!types_1.isNamedType(propType) || (propType.name === 'scalar' && !ref_utils_1.isRef(value))) {\n                            continue;\n                        }\n                        walkNode(value, propType, loc.child([propName]), resolvedNode, propName);\n                    }\n                }\n            }\n            const anyLeaveVisitors = normalizedVisitors.any.leave;\n            const currentLeaveVisitors = (((_l = normalizedVisitors[type.name]) === null || _l === void 0 ? void 0 : _l.leave) || []).concat(anyLeaveVisitors);\n            for (const context of activatedContexts.reverse()) {\n                if (context.isSkippedLevel) {\n                    context.seen.delete(resolvedNode);\n                }\n                else {\n                    context.activatedOn = utils_1.popStack(context.activatedOn);\n                    if (context.parent) {\n                        let ctx = context.parent;\n                        while (ctx) {\n                            ctx.activatedOn.value.nextLevelTypeActivated = utils_1.popStack(ctx.activatedOn.value.nextLevelTypeActivated);\n                            ctx = ctx.parent;\n                        }\n                    }\n                }\n            }\n            for (const { context, visit, ruleId, severity } of currentLeaveVisitors) {\n                if (!context.isSkippedLevel && enteredContexts.has(context)) {\n                    visitWithContext(visit, resolvedNode, context, ruleId, severity);\n                }\n            }\n        }\n        currentLocation = location;\n        if (ref_utils_1.isRef(node)) {\n            const refLeaveVisitors = normalizedVisitors.ref.leave;\n            for (const { visit: visitor, ruleId, severity, context } of refLeaveVisitors) {\n                if (enteredContexts.has(context)) {\n                    const report = reportFn.bind(undefined, ruleId, severity);\n                    visitor(node, {\n                        report,\n                        resolve,\n                        location,\n                        type,\n                        parent,\n                        key,\n                        parentLocations: {},\n                        oasVersion: ctx.oasVersion,\n                        getVisitorData: getVisitorDataFn.bind(undefined, ruleId)\n                    }, { node: resolvedNode, location: resolvedLocation, error });\n                }\n            }\n        }\n        // returns true ignores all the next visitors on the specific node\n        function visitWithContext(visit, node, context, ruleId, severity) {\n            const report = reportFn.bind(undefined, ruleId, severity);\n            let ignoreNextVisitorsOnNode = false;\n            visit(node, {\n                report,\n                resolve,\n                location: currentLocation,\n                type,\n                parent,\n                key,\n                parentLocations: collectParentsLocations(context),\n                oasVersion: ctx.oasVersion,\n                ignoreNextVisitorsOnNode: () => { ignoreNextVisitorsOnNode = true; },\n                getVisitorData: getVisitorDataFn.bind(undefined, ruleId),\n            }, collectParents(context), context);\n            return { ignoreNextVisitorsOnNode };\n        }\n        function resolve(ref, from = currentLocation.source.absoluteRef) {\n            if (!ref_utils_1.isRef(ref))\n                return { location, node: ref };\n            const refId = resolve_1.makeRefId(from, ref.$ref);\n            const resolvedRef = resolvedRefMap.get(refId);\n            if (!resolvedRef) {\n                return {\n                    location: undefined,\n                    node: undefined,\n                };\n            }\n            const { resolved, node, document, nodePointer, error } = resolvedRef;\n            const newLocation = resolved\n                ? new ref_utils_1.Location(document.source, nodePointer)\n                : error instanceof resolve_1.YamlParseError\n                    ? new ref_utils_1.Location(error.source, '')\n                    : undefined;\n            return { location: newLocation, node, error };\n        }\n        function reportFn(ruleId, severity, opts) {\n            const loc = opts.location\n                ? Array.isArray(opts.location)\n                    ? opts.location\n                    : [opts.location]\n                : [Object.assign(Object.assign({}, currentLocation), { reportOnKey: false })];\n            ctx.problems.push(Object.assign(Object.assign({ ruleId: opts.ruleId || ruleId, severity: opts.forceSeverity || severity }, opts), { suggest: opts.suggest || [], location: loc.map((loc) => {\n                    return Object.assign(Object.assign(Object.assign({}, currentLocation), { reportOnKey: false }), loc);\n                }) }));\n        }\n        function getVisitorDataFn(ruleId) {\n            ctx.visitorsData[ruleId] = ctx.visitorsData[ruleId] || {};\n            return ctx.visitorsData[ruleId];\n        }\n    }\n}\nexports.walkDocument = walkDocument;\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,YAAR,GAAuB,KAAK,CAA5B;;AACA,MAAMC,WAAW,GAAGC,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,SAAD,CAAvB;;AACA,SAASI,cAAT,CAAwBC,GAAxB,EAA6B;EACzB,IAAIC,EAAJ;;EACA,MAAMC,OAAO,GAAG,EAAhB;;EACA,OAAOF,GAAG,CAACG,MAAX,EAAmB;IACfD,OAAO,CAACF,GAAG,CAACG,MAAJ,CAAWC,IAAX,CAAgBC,IAAjB,CAAP,GAAgC,CAACJ,EAAE,GAAGD,GAAG,CAACG,MAAJ,CAAWG,WAAjB,MAAkC,IAAlC,IAA0CL,EAAE,KAAK,KAAK,CAAtD,GAA0D,KAAK,CAA/D,GAAmEA,EAAE,CAACT,KAAH,CAASe,IAA5G;IACAP,GAAG,GAAGA,GAAG,CAACG,MAAV;EACH;;EACD,OAAOD,OAAP;AACH;;AACD,SAASM,uBAAT,CAAiCR,GAAjC,EAAsC;EAClC,IAAIC,EAAJ,EAAQQ,EAAR;;EACA,MAAMC,SAAS,GAAG,EAAlB;;EACA,OAAOV,GAAG,CAACG,MAAX,EAAmB;IACf,IAAI,CAACF,EAAE,GAAGD,GAAG,CAACG,MAAJ,CAAWG,WAAjB,MAAkC,IAAlC,IAA0CL,EAAE,KAAK,KAAK,CAAtD,GAA0D,KAAK,CAA/D,GAAmEA,EAAE,CAACT,KAAH,CAASmB,QAAhF,EAA0F;MACtFD,SAAS,CAACV,GAAG,CAACG,MAAJ,CAAWC,IAAX,CAAgBC,IAAjB,CAAT,GAAkC,CAACI,EAAE,GAAGT,GAAG,CAACG,MAAJ,CAAWG,WAAjB,MAAkC,IAAlC,IAA0CG,EAAE,KAAK,KAAK,CAAtD,GAA0D,KAAK,CAA/D,GAAmEA,EAAE,CAACjB,KAAH,CAASmB,QAA9G;IACH;;IACDX,GAAG,GAAGA,GAAG,CAACG,MAAV;EACH;;EACD,OAAOO,SAAP;AACH;;AACD,SAASjB,YAAT,CAAsBmB,IAAtB,EAA4B;EACxB,MAAM;IAAEC,QAAF;IAAYC,QAAZ;IAAsBC,kBAAtB;IAA0CC,cAA1C;IAA0DhB;EAA1D,IAAkEY,IAAxE;EACA,MAAMK,gBAAgB,GAAG,EAAzB;EACA,MAAMC,QAAQ,GAAG,IAAIC,GAAJ,EAAjB;EACAC,QAAQ,CAACP,QAAQ,CAACQ,MAAV,EAAkBP,QAAlB,EAA4B,IAAIpB,WAAW,CAAC4B,QAAhB,CAAyBT,QAAQ,CAACU,MAAlC,EAA0C,IAA1C,CAA5B,EAA6EC,SAA7E,EAAwF,EAAxF,CAAR;;EACA,SAASJ,QAAT,CAAkBb,IAAlB,EAAwBH,IAAxB,EAA8BO,QAA9B,EAAwCR,MAAxC,EAAgDsB,GAAhD,EAAqD;IACjD,IAAIxB,EAAJ,EAAQQ,EAAR,EAAYiB,EAAZ,EAAgBC,EAAhB,EAAoBC,EAApB,EAAwBC,EAAxB,EAA4BC,EAA5B,EAAgCC,EAAhC,EAAoCC,EAApC,EAAwCC,EAAxC,EAA4CC,EAA5C;;IACA,IAAIC,eAAe,GAAGxB,QAAtB;IACA,MAAM;MAAEJ,IAAI,EAAE6B,YAAR;MAAsBzB,QAAQ,EAAE0B,gBAAhC;MAAkDC;IAAlD,IAA4DC,OAAO,CAAChC,IAAD,CAAzE;IACA,MAAMiC,eAAe,GAAG,IAAIrB,GAAJ,EAAxB;;IACA,IAAIzB,WAAW,CAAC+C,KAAZ,CAAkBlC,IAAlB,CAAJ,EAA6B;MACzB,MAAMmC,gBAAgB,GAAG3B,kBAAkB,CAAC4B,GAAnB,CAAuBC,KAAhD;;MACA,KAAK,MAAM;QAAEC,KAAK,EAAEC,OAAT;QAAkBC,MAAlB;QAA0BC,QAA1B;QAAoCC;MAApC,CAAX,IAA4DP,gBAA5D,EAA8E;QAC1E,IAAI,CAACxB,QAAQ,CAACgC,GAAT,CAAa3C,IAAb,CAAL,EAAyB;UACrBiC,eAAe,CAACW,GAAhB,CAAoBF,OAApB;UACA,MAAMG,MAAM,GAAGC,QAAQ,CAACC,IAAT,CAAc9B,SAAd,EAAyBuB,MAAzB,EAAiCC,QAAjC,CAAf;UACAF,OAAO,CAACvC,IAAD,EAAO;YACV6C,MADU;YAEVb,OAFU;YAGV5B,QAHU;YAIVP,IAJU;YAKVD,MALU;YAMVsB,GANU;YAOV8B,eAAe,EAAE,EAPP;YAQVC,UAAU,EAAExD,GAAG,CAACwD,UARN;YASVC,cAAc,EAAEC,gBAAgB,CAACJ,IAAjB,CAAsB9B,SAAtB,EAAiCuB,MAAjC;UATN,CAAP,EAUJ;YAAExC,IAAI,EAAE6B,YAAR;YAAsBzB,QAAQ,EAAE0B,gBAAhC;YAAkDC;UAAlD,CAVI,CAAP;;UAWA,IAAI,CAACD,gBAAgB,KAAK,IAArB,IAA6BA,gBAAgB,KAAK,KAAK,CAAvD,GAA2D,KAAK,CAAhE,GAAoEA,gBAAgB,CAACd,MAAjB,CAAwBoC,WAA7F,KAA6G3D,GAAG,CAAC4D,QAArH,EAA+H;YAC3H5D,GAAG,CAAC4D,QAAJ,CAAaC,GAAb,CAAiBxB,gBAAgB,KAAK,IAArB,IAA6BA,gBAAgB,KAAK,KAAK,CAAvD,GAA2D,KAAK,CAAhE,GAAoEA,gBAAgB,CAACd,MAAjB,CAAwBoC,WAA7G,EAA0HvD,IAA1H;UACH;QACJ;MACJ;IACJ;;IACD,IAAIgC,YAAY,KAAKZ,SAAjB,IAA8Ba,gBAA9B,IAAkDjC,IAAI,CAACC,IAAL,KAAc,QAApE,EAA8E;MAC1E8B,eAAe,GAAGE,gBAAlB;MACA,MAAMyB,UAAU,GAAG,CAACrD,EAAE,GAAG,CAACR,EAAE,GAAGgB,gBAAgB,CAACb,IAAI,CAACC,IAAN,CAAtB,MAAuC,IAAvC,IAA+CJ,EAAE,KAAK,KAAK,CAA3D,GAA+D,KAAK,CAApE,GAAwEA,EAAE,CAACiD,GAAjF,MAA0F,IAA1F,IAAkGzC,EAAE,KAAK,KAAK,CAA9G,GAAkH,KAAK,CAAvH,GAA2HA,EAAE,CAACsD,IAAH,CAAQ9D,EAAR,EAAYmC,YAAZ,CAA9I;MACA,IAAI4B,aAAa,GAAG,KAApB;MACA,MAAMC,gBAAgB,GAAGlD,kBAAkB,CAACmD,GAAnB,CAAuBtB,KAAhD;MACA,MAAMuB,oBAAoB,GAAGF,gBAAgB,CAACG,MAAjB,CAAwB,CAAC,CAAC1C,EAAE,GAAGX,kBAAkB,CAACX,IAAI,CAACC,IAAN,CAAxB,MAAyC,IAAzC,IAAiDqB,EAAE,KAAK,KAAK,CAA7D,GAAiE,KAAK,CAAtE,GAA0EA,EAAE,CAACkB,KAA9E,KAAwF,EAAhH,CAA7B;MACA,MAAMyB,iBAAiB,GAAG,EAA1B;;MACA,KAAK,MAAM;QAAEpB,OAAF;QAAWJ,KAAX;QAAkByB,IAAlB;QAAwBvB,MAAxB;QAAgCC;MAAhC,CAAX,IAAyDmB,oBAAzD,EAA+E;QAC3E,IAAIlB,OAAO,CAACsB,cAAZ,EAA4B;UACxB,IAAItB,OAAO,CAAC9C,MAAR,CAAeG,WAAf,IACA,CAAC2C,OAAO,CAAC9C,MAAR,CAAeG,WAAf,CAA2Bd,KAA3B,CAAiCgF,sBADlC,IAEA,CAACvB,OAAO,CAACwB,IAAR,CAAavB,GAAb,CAAiB3C,IAAjB,CAFL,EAE6B;YACzB;YACA0C,OAAO,CAACwB,IAAR,CAAatB,GAAb,CAAiB5C,IAAjB;YACAyD,aAAa,GAAG,IAAhB;YACAK,iBAAiB,CAACK,IAAlB,CAAuBzB,OAAvB;UACH;QACJ,CATD,MAUK;UACD,IAAKA,OAAO,CAAC9C,MAAR,IAAkB;UACnB8C,OAAO,CAAC9C,MAAR,CAAeG,WADd,IAED,CAAC,CAACqB,EAAE,GAAGsB,OAAO,CAAC3C,WAAd,MAA+B,IAA/B,IAAuCqB,EAAE,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,EAAE,CAACnC,KAAH,CAASmF,cAA1E,MAA8F1B,OAAO,CAAC9C,MAAR,CAAeG,WAAf,CAA2Bd,KAA3B,CAAiCe,IAF9H,IAGD;UACA,CAAC,CAACqB,EAAE,GAAGqB,OAAO,CAAC9C,MAAR,CAAeG,WAAf,CAA2Bd,KAA3B,CAAiCgF,sBAAvC,MAAmE,IAAnE,IAA2E5C,EAAE,KAAK,KAAK,CAAvF,GAA2F,KAAK,CAAhG,GAAoGA,EAAE,CAACpC,KAAxG,MAAmHY,IAJnH,IAKC,CAAC6C,OAAO,CAAC9C,MAAT,IAAmB,CAAC2D,UALzB,CAKqC;UALrC,EAME;YACEO,iBAAiB,CAACK,IAAlB,CAAuBzB,OAAvB;YACA,MAAM3C,WAAW,GAAG;cAChBC,IAAI,EAAE6B,YADU;cAEhBzB,QAAQ,EAAE0B,gBAFM;cAGhBmC,sBAAsB,EAAE,IAHR;cAIhBG,cAAc,EAAE,CAAC7C,EAAE,GAAG,CAACD,EAAE,GAAGoB,OAAO,CAAC9C,MAAd,MAA0B,IAA1B,IAAkC0B,EAAE,KAAK,KAAK,CAA9C,GAAkD,KAAK,CAAvD,GAA2DA,EAAE,CAACvB,WAApE,MAAqF,IAArF,IAA6FwB,EAAE,KAAK,KAAK,CAAzG,GAA6G,KAAK,CAAlH,GAAsHA,EAAE,CAACtC,KAAH,CAASe,IAJ/H;cAKhBqE,OAAO,EAAE,CAAC3C,EAAE,GAAI,CAAC,CAACD,EAAE,GAAG,CAACD,EAAE,GAAGkB,OAAO,CAAC9C,MAAd,MAA0B,IAA1B,IAAkC4B,EAAE,KAAK,KAAK,CAA9C,GAAkD,KAAK,CAAvD,GAA2DA,EAAE,CAACzB,WAApE,MAAqF,IAArF,IAA6F0B,EAAE,KAAK,KAAK,CAAzG,GAA6G,KAAK,CAAlH,GAAsHA,EAAE,CAACxC,KAAH,CAASoF,OAAhI,MAA6IN,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAAClC,YAAD,EAAeX,GAAf,CAA7L,CAAP,MAA+N,IAA/N,IAAuOQ,EAAE,KAAK,KAAK,CAAnP,GAAuPA,EAAvP,GAA4P;YALrP,CAApB;YAOAgB,OAAO,CAAC3C,WAAR,GAAsBT,OAAO,CAACgF,SAAR,CAAkB5B,OAAO,CAAC3C,WAA1B,EAAuCA,WAAvC,CAAtB;YACA,IAAIN,GAAG,GAAGiD,OAAO,CAAC9C,MAAlB;;YACA,OAAOH,GAAP,EAAY;cACRA,GAAG,CAACM,WAAJ,CAAgBd,KAAhB,CAAsBgF,sBAAtB,GAA+C3E,OAAO,CAACgF,SAAR,CAAkB7E,GAAG,CAACM,WAAJ,CAAgBd,KAAhB,CAAsBgF,sBAAxC,EAAgEpE,IAAhE,CAA/C;cACAJ,GAAG,GAAGA,GAAG,CAACG,MAAV;YACH;;YACD,IAAI,CAACG,WAAW,CAACsE,OAAjB,EAA0B;cACtBZ,aAAa,GAAG,IAAhB;cACAxB,eAAe,CAACW,GAAhB,CAAoBF,OAApB;cACA,MAAM;gBAAE6B;cAAF,IAA+BC,gBAAgB,CAAClC,KAAD,EAAQT,YAAR,EAAsBa,OAAtB,EAA+BF,MAA/B,EAAuCC,QAAvC,CAArD;cACA,IAAI8B,wBAAJ,EACI;YACP;UACJ;QACJ;MACJ;;MACD,IAAId,aAAa,IAAI,CAACF,UAAtB,EAAkC;QAC9B7C,gBAAgB,CAACb,IAAI,CAACC,IAAN,CAAhB,GAA8BY,gBAAgB,CAACb,IAAI,CAACC,IAAN,CAAhB,IAA+B,IAAIc,GAAJ,EAA7D;QACAF,gBAAgB,CAACb,IAAI,CAACC,IAAN,CAAhB,CAA4B8C,GAA5B,CAAgCf,YAAhC;;QACA,IAAI4C,KAAK,CAACC,OAAN,CAAc7C,YAAd,CAAJ,EAAiC;UAC7B,MAAM8C,SAAS,GAAG9E,IAAI,CAAC+E,KAAvB;;UACA,IAAID,SAAS,KAAK1D,SAAlB,EAA6B;YACzB,KAAK,IAAI4D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhD,YAAY,CAACiD,MAAjC,EAAyCD,CAAC,EAA1C,EAA8C;cAC1ChE,QAAQ,CAACgB,YAAY,CAACgD,CAAD,CAAb,EAAkBF,SAAlB,EAA6B7C,gBAAgB,CAACiD,KAAjB,CAAuB,CAACF,CAAD,CAAvB,CAA7B,EAA0DhD,YAA1D,EAAwEgD,CAAxE,CAAR;YACH;UACJ;QACJ,CAPD,MAQK,IAAI,OAAOhD,YAAP,KAAwB,QAAxB,IAAoCA,YAAY,KAAK,IAAzD,EAA+D;UAChE;UACA,MAAMmD,KAAK,GAAGlG,MAAM,CAACmG,IAAP,CAAYpF,IAAI,CAACqF,UAAjB,CAAd;;UACA,IAAIrF,IAAI,CAACsF,oBAAT,EAA+B;YAC3BH,KAAK,CAACb,IAAN,CAAW,GAAGrF,MAAM,CAACmG,IAAP,CAAYpD,YAAZ,EAA0BuD,MAA1B,CAAkCC,CAAD,IAAO,CAACL,KAAK,CAACM,QAAN,CAAeD,CAAf,CAAzC,CAAd;UACH;;UACD,IAAIlG,WAAW,CAAC+C,KAAZ,CAAkBlC,IAAlB,CAAJ,EAA6B;YACzBgF,KAAK,CAACb,IAAN,CAAW,GAAGrF,MAAM,CAACmG,IAAP,CAAYjF,IAAZ,EAAkBoF,MAAlB,CAA0BC,CAAD,IAAOA,CAAC,KAAK,MAAN,IAAgB,CAACL,KAAK,CAACM,QAAN,CAAeD,CAAf,CAAjD,CAAd,EADyB,CAC2D;UACvF;;UACD,KAAK,MAAME,QAAX,IAAuBP,KAAvB,EAA8B;YAC1B,IAAI/F,KAAK,GAAG4C,YAAY,CAAC0D,QAAD,CAAxB;YACA,IAAIC,GAAG,GAAG1D,gBAAV;;YACA,IAAI7C,KAAK,KAAKgC,SAAd,EAAyB;cACrBhC,KAAK,GAAGe,IAAI,CAACuF,QAAD,CAAZ;cACAC,GAAG,GAAGpF,QAAN,CAFqB,CAEL;YACnB;;YACD,IAAIqF,QAAQ,GAAG5F,IAAI,CAACqF,UAAL,CAAgBK,QAAhB,CAAf;YACA,IAAIE,QAAQ,KAAKxE,SAAjB,EACIwE,QAAQ,GAAG5F,IAAI,CAACsF,oBAAhB;YACJ,IAAI,OAAOM,QAAP,KAAoB,UAAxB,EACIA,QAAQ,GAAGA,QAAQ,CAACxG,KAAD,EAAQsG,QAAR,CAAnB;;YACJ,IAAI,CAAChG,OAAO,CAACmG,WAAR,CAAoBD,QAApB,CAAD,KAAmCA,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAACE,eAAhG,CAAJ,EAAsH;cAClHF,QAAQ,GAAGA,QAAQ,CAACE,eAApB;cACA1G,KAAK,GAAG;gBAAE2G,IAAI,EAAE3G;cAAR,CAAR;YACH;;YACD,IAAIwG,QAAQ,IAAIA,QAAQ,CAAC3F,IAAT,KAAkBmB,SAA9B,IAA2CwE,QAAQ,CAACI,UAAT,KAAwB,KAAvE,EAA8E;cAC1EJ,QAAQ,GAAG;gBAAE3F,IAAI,EAAE,QAAR;gBAAkBoF,UAAU,EAAE;cAA9B,CAAX;YACH;;YACD,IAAI,CAAC3F,OAAO,CAACmG,WAAR,CAAoBD,QAApB,CAAD,IAAmCA,QAAQ,CAAC3F,IAAT,KAAkB,QAAlB,IAA8B,CAACX,WAAW,CAAC+C,KAAZ,CAAkBjD,KAAlB,CAAtE,EAAiG;cAC7F;YACH;;YACD4B,QAAQ,CAAC5B,KAAD,EAAQwG,QAAR,EAAkBD,GAAG,CAACT,KAAJ,CAAU,CAACQ,QAAD,CAAV,CAAlB,EAAyC1D,YAAzC,EAAuD0D,QAAvD,CAAR;UACH;QACJ;MACJ;;MACD,MAAMO,gBAAgB,GAAGtF,kBAAkB,CAACmD,GAAnB,CAAuBoC,KAAhD;MACA,MAAMC,oBAAoB,GAAG,CAAC,CAAC,CAACrE,EAAE,GAAGnB,kBAAkB,CAACX,IAAI,CAACC,IAAN,CAAxB,MAAyC,IAAzC,IAAiD6B,EAAE,KAAK,KAAK,CAA7D,GAAiE,KAAK,CAAtE,GAA0EA,EAAE,CAACoE,KAA9E,KAAwF,EAAzF,EAA6FlC,MAA7F,CAAoGiC,gBAApG,CAA7B;;MACA,KAAK,MAAMpD,OAAX,IAAsBoB,iBAAiB,CAACmC,OAAlB,EAAtB,EAAmD;QAC/C,IAAIvD,OAAO,CAACsB,cAAZ,EAA4B;UACxBtB,OAAO,CAACwB,IAAR,CAAagC,MAAb,CAAoBrE,YAApB;QACH,CAFD,MAGK;UACDa,OAAO,CAAC3C,WAAR,GAAsBT,OAAO,CAAC6G,QAAR,CAAiBzD,OAAO,CAAC3C,WAAzB,CAAtB;;UACA,IAAI2C,OAAO,CAAC9C,MAAZ,EAAoB;YAChB,IAAIH,GAAG,GAAGiD,OAAO,CAAC9C,MAAlB;;YACA,OAAOH,GAAP,EAAY;cACRA,GAAG,CAACM,WAAJ,CAAgBd,KAAhB,CAAsBgF,sBAAtB,GAA+C3E,OAAO,CAAC6G,QAAR,CAAiB1G,GAAG,CAACM,WAAJ,CAAgBd,KAAhB,CAAsBgF,sBAAvC,CAA/C;cACAxE,GAAG,GAAGA,GAAG,CAACG,MAAV;YACH;UACJ;QACJ;MACJ;;MACD,KAAK,MAAM;QAAE8C,OAAF;QAAWJ,KAAX;QAAkBE,MAAlB;QAA0BC;MAA1B,CAAX,IAAmDuD,oBAAnD,EAAyE;QACrE,IAAI,CAACtD,OAAO,CAACsB,cAAT,IAA2B/B,eAAe,CAACU,GAAhB,CAAoBD,OAApB,CAA/B,EAA6D;UACzD8B,gBAAgB,CAAClC,KAAD,EAAQT,YAAR,EAAsBa,OAAtB,EAA+BF,MAA/B,EAAuCC,QAAvC,CAAhB;QACH;MACJ;IACJ;;IACDb,eAAe,GAAGxB,QAAlB;;IACA,IAAIjB,WAAW,CAAC+C,KAAZ,CAAkBlC,IAAlB,CAAJ,EAA6B;MACzB,MAAMoG,gBAAgB,GAAG5F,kBAAkB,CAAC4B,GAAnB,CAAuB2D,KAAhD;;MACA,KAAK,MAAM;QAAEzD,KAAK,EAAEC,OAAT;QAAkBC,MAAlB;QAA0BC,QAA1B;QAAoCC;MAApC,CAAX,IAA4D0D,gBAA5D,EAA8E;QAC1E,IAAInE,eAAe,CAACU,GAAhB,CAAoBD,OAApB,CAAJ,EAAkC;UAC9B,MAAMG,MAAM,GAAGC,QAAQ,CAACC,IAAT,CAAc9B,SAAd,EAAyBuB,MAAzB,EAAiCC,QAAjC,CAAf;UACAF,OAAO,CAACvC,IAAD,EAAO;YACV6C,MADU;YAEVb,OAFU;YAGV5B,QAHU;YAIVP,IAJU;YAKVD,MALU;YAMVsB,GANU;YAOV8B,eAAe,EAAE,EAPP;YAQVC,UAAU,EAAExD,GAAG,CAACwD,UARN;YASVC,cAAc,EAAEC,gBAAgB,CAACJ,IAAjB,CAAsB9B,SAAtB,EAAiCuB,MAAjC;UATN,CAAP,EAUJ;YAAExC,IAAI,EAAE6B,YAAR;YAAsBzB,QAAQ,EAAE0B,gBAAhC;YAAkDC;UAAlD,CAVI,CAAP;QAWH;MACJ;IACJ,CAtKgD,CAuKjD;;;IACA,SAASyC,gBAAT,CAA0BlC,KAA1B,EAAiCtC,IAAjC,EAAuC0C,OAAvC,EAAgDF,MAAhD,EAAwDC,QAAxD,EAAkE;MAC9D,MAAMI,MAAM,GAAGC,QAAQ,CAACC,IAAT,CAAc9B,SAAd,EAAyBuB,MAAzB,EAAiCC,QAAjC,CAAf;MACA,IAAI8B,wBAAwB,GAAG,KAA/B;MACAjC,KAAK,CAACtC,IAAD,EAAO;QACR6C,MADQ;QAERb,OAFQ;QAGR5B,QAAQ,EAAEwB,eAHF;QAIR/B,IAJQ;QAKRD,MALQ;QAMRsB,GANQ;QAOR8B,eAAe,EAAE/C,uBAAuB,CAACyC,OAAD,CAPhC;QAQRO,UAAU,EAAExD,GAAG,CAACwD,UARR;QASRsB,wBAAwB,EAAE,MAAM;UAAEA,wBAAwB,GAAG,IAA3B;QAAkC,CAT5D;QAURrB,cAAc,EAAEC,gBAAgB,CAACJ,IAAjB,CAAsB9B,SAAtB,EAAiCuB,MAAjC;MAVR,CAAP,EAWFhD,cAAc,CAACkD,OAAD,CAXZ,EAWuBA,OAXvB,CAAL;MAYA,OAAO;QAAE6B;MAAF,CAAP;IACH;;IACD,SAASvC,OAAT,CAAiBI,GAAjB,EAAiE;MAAA,IAA3CiE,IAA2C,uEAApCzE,eAAe,CAACZ,MAAhB,CAAuBoC,WAAa;MAC7D,IAAI,CAACjE,WAAW,CAAC+C,KAAZ,CAAkBE,GAAlB,CAAL,EACI,OAAO;QAAEhC,QAAF;QAAYJ,IAAI,EAAEoC;MAAlB,CAAP;MACJ,MAAMkE,KAAK,GAAGjH,SAAS,CAACkH,SAAV,CAAoBF,IAApB,EAA0BjE,GAAG,CAACwD,IAA9B,CAAd;MACA,MAAMY,WAAW,GAAG/F,cAAc,CAACgG,GAAf,CAAmBH,KAAnB,CAApB;;MACA,IAAI,CAACE,WAAL,EAAkB;QACd,OAAO;UACHpG,QAAQ,EAAEa,SADP;UAEHjB,IAAI,EAAEiB;QAFH,CAAP;MAIH;;MACD,MAAM;QAAEyF,QAAF;QAAY1G,IAAZ;QAAkBM,QAAlB;QAA4BqG,WAA5B;QAAyC5E;MAAzC,IAAmDyE,WAAzD;MACA,MAAMI,WAAW,GAAGF,QAAQ,GACtB,IAAIvH,WAAW,CAAC4B,QAAhB,CAAyBT,QAAQ,CAACU,MAAlC,EAA0C2F,WAA1C,CADsB,GAEtB5E,KAAK,YAAY1C,SAAS,CAACwH,cAA3B,GACI,IAAI1H,WAAW,CAAC4B,QAAhB,CAAyBgB,KAAK,CAACf,MAA/B,EAAuC,EAAvC,CADJ,GAEIC,SAJV;MAKA,OAAO;QAAEb,QAAQ,EAAEwG,WAAZ;QAAyB5G,IAAzB;QAA+B+B;MAA/B,CAAP;IACH;;IACD,SAASe,QAAT,CAAkBN,MAAlB,EAA0BC,QAA1B,EAAoCpC,IAApC,EAA0C;MACtC,MAAMmF,GAAG,GAAGnF,IAAI,CAACD,QAAL,GACNqE,KAAK,CAACC,OAAN,CAAcrE,IAAI,CAACD,QAAnB,IACIC,IAAI,CAACD,QADT,GAEI,CAACC,IAAI,CAACD,QAAN,CAHE,GAIN,CAACtB,MAAM,CAACgI,MAAP,CAAchI,MAAM,CAACgI,MAAP,CAAc,EAAd,EAAkBlF,eAAlB,CAAd,EAAkD;QAAEmF,WAAW,EAAE;MAAf,CAAlD,CAAD,CAJN;MAKAtH,GAAG,CAACuH,QAAJ,CAAa7C,IAAb,CAAkBrF,MAAM,CAACgI,MAAP,CAAchI,MAAM,CAACgI,MAAP,CAAc;QAAEtE,MAAM,EAAEnC,IAAI,CAACmC,MAAL,IAAeA,MAAzB;QAAiCC,QAAQ,EAAEpC,IAAI,CAAC4G,aAAL,IAAsBxE;MAAjE,CAAd,EAA2FpC,IAA3F,CAAd,EAAgH;QAAE6G,OAAO,EAAE7G,IAAI,CAAC6G,OAAL,IAAgB,EAA3B;QAA+B9G,QAAQ,EAAEoF,GAAG,CAAC2B,GAAJ,CAAS3B,GAAD,IAAS;UACpL,OAAO1G,MAAM,CAACgI,MAAP,CAAchI,MAAM,CAACgI,MAAP,CAAchI,MAAM,CAACgI,MAAP,CAAc,EAAd,EAAkBlF,eAAlB,CAAd,EAAkD;YAAEmF,WAAW,EAAE;UAAf,CAAlD,CAAd,EAAyFvB,GAAzF,CAAP;QACH,CAFsK;MAAzC,CAAhH,CAAlB;IAGH;;IACD,SAASrC,gBAAT,CAA0BX,MAA1B,EAAkC;MAC9B/C,GAAG,CAAC2H,YAAJ,CAAiB5E,MAAjB,IAA2B/C,GAAG,CAAC2H,YAAJ,CAAiB5E,MAAjB,KAA4B,EAAvD;MACA,OAAO/C,GAAG,CAAC2H,YAAJ,CAAiB5E,MAAjB,CAAP;IACH;EACJ;AACJ;;AACDxD,OAAO,CAACE,YAAR,GAAuBA,YAAvB"},"metadata":{},"sourceType":"script"}