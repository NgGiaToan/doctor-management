{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\giato\\\\Downloads\\\\Workspace\\\\.Net\\\\api\\\\doctor-management-fe\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolvePreset = exports.resolveLint = exports.resolveApis = exports.resolvePlugins = exports.resolveConfig = void 0;\n\nvar path = require(\"path\");\n\nvar colorette_1 = require(\"colorette\");\n\nvar ref_utils_1 = require(\"../ref-utils\");\n\nvar resolve_1 = require(\"../resolve\");\n\nvar builtIn_1 = require(\"./builtIn\");\n\nvar utils_1 = require(\"./utils\");\n\nvar utils_2 = require(\"../utils\");\n\nvar config_1 = require(\"./config\");\n\nfunction resolveConfig(rawConfig, configPath) {\n  var _a, _b, _c, _d, _e;\n\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var resolver, configExtends, recommendedFallback, lintConfig, apis, lint;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!((_b = (_a = rawConfig.lint) === null || _a === void 0 ? void 0 : _a.extends) === null || _b === void 0 ? void 0 : _b.some(utils_2.isNotString))) {\n              _context.next = 2;\n              break;\n            }\n\n            throw new Error(\"Error configuration format not detected in extends value must contain strings\");\n\n          case 2:\n            resolver = new resolve_1.BaseResolver(utils_1.getResolveConfig(rawConfig.resolve));\n            configExtends = (_d = (_c = rawConfig === null || rawConfig === void 0 ? void 0 : rawConfig.lint) === null || _c === void 0 ? void 0 : _c.extends) !== null && _d !== void 0 ? _d : ['recommended'];\n            recommendedFallback = !((_e = rawConfig === null || rawConfig === void 0 ? void 0 : rawConfig.lint) === null || _e === void 0 ? void 0 : _e.extends);\n            lintConfig = Object.assign(Object.assign({}, rawConfig === null || rawConfig === void 0 ? void 0 : rawConfig.lint), {\n              extends: configExtends,\n              recommendedFallback: recommendedFallback\n            });\n            _context.next = 8;\n            return resolveApis({\n              rawConfig: Object.assign(Object.assign({}, rawConfig), {\n                lint: lintConfig\n              }),\n              configPath: configPath,\n              resolver: resolver\n            });\n\n          case 8:\n            apis = _context.sent;\n            _context.next = 11;\n            return resolveLint({\n              lintConfig: lintConfig,\n              configPath: configPath,\n              resolver: resolver\n            });\n\n          case 11:\n            lint = _context.sent;\n            return _context.abrupt(\"return\", new config_1.Config(Object.assign(Object.assign({}, rawConfig), {\n              apis: apis,\n              lint: lint\n            }), configPath));\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.resolveConfig = resolveConfig;\n\nfunction resolvePlugins(plugins) {\n  var configPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  if (!plugins) return []; // @ts-ignore\n\n  var requireFunc = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require;\n  var seenPluginIds = new Map();\n  return plugins.map(function (p) {\n    if (utils_2.isString(p) && ref_utils_1.isAbsoluteUrl(p)) {\n      throw new Error(colorette_1.red(\"We don't support remote plugins yet.\"));\n    } // TODO: resolve npm packages similar to eslint\n\n\n    var pluginModule = utils_2.isString(p) ? requireFunc(path.resolve(path.dirname(configPath), p)) : p;\n    var id = pluginModule.id;\n\n    if (typeof id !== 'string') {\n      throw new Error(colorette_1.red(\"Plugin must define `id` property in \".concat(colorette_1.blue(p.toString()), \".\")));\n    }\n\n    if (seenPluginIds.has(id)) {\n      var pluginPath = seenPluginIds.get(id);\n      throw new Error(colorette_1.red(\"Plugin \\\"id\\\" must be unique. Plugin \".concat(colorette_1.blue(p.toString()), \" uses id \\\"\").concat(colorette_1.blue(id), \"\\\" already seen in \").concat(colorette_1.blue(pluginPath))));\n    }\n\n    seenPluginIds.set(id, p.toString());\n    var plugin = Object.assign(Object.assign({\n      id: id\n    }, pluginModule.configs ? {\n      configs: pluginModule.configs\n    } : {}), pluginModule.typeExtension ? {\n      typeExtension: pluginModule.typeExtension\n    } : {});\n\n    if (pluginModule.rules) {\n      if (!pluginModule.rules.oas3 && !pluginModule.rules.oas2) {\n        throw new Error(\"Plugin rules must have `oas3` or `oas2` rules \\\"\".concat(p, \".\"));\n      }\n\n      plugin.rules = {};\n\n      if (pluginModule.rules.oas3) {\n        plugin.rules.oas3 = utils_1.prefixRules(pluginModule.rules.oas3, id);\n      }\n\n      if (pluginModule.rules.oas2) {\n        plugin.rules.oas2 = utils_1.prefixRules(pluginModule.rules.oas2, id);\n      }\n    }\n\n    if (pluginModule.preprocessors) {\n      if (!pluginModule.preprocessors.oas3 && !pluginModule.preprocessors.oas2) {\n        throw new Error(\"Plugin `preprocessors` must have `oas3` or `oas2` preprocessors \\\"\".concat(p, \".\"));\n      }\n\n      plugin.preprocessors = {};\n\n      if (pluginModule.preprocessors.oas3) {\n        plugin.preprocessors.oas3 = utils_1.prefixRules(pluginModule.preprocessors.oas3, id);\n      }\n\n      if (pluginModule.preprocessors.oas2) {\n        plugin.preprocessors.oas2 = utils_1.prefixRules(pluginModule.preprocessors.oas2, id);\n      }\n    }\n\n    if (pluginModule.decorators) {\n      if (!pluginModule.decorators.oas3 && !pluginModule.decorators.oas2) {\n        throw new Error(\"Plugin `decorators` must have `oas3` or `oas2` decorators \\\"\".concat(p, \".\"));\n      }\n\n      plugin.decorators = {};\n\n      if (pluginModule.decorators.oas3) {\n        plugin.decorators.oas3 = utils_1.prefixRules(pluginModule.decorators.oas3, id);\n      }\n\n      if (pluginModule.decorators.oas2) {\n        plugin.decorators.oas2 = utils_1.prefixRules(pluginModule.decorators.oas2, id);\n      }\n    }\n\n    return plugin;\n  }).filter(utils_2.notUndefined);\n}\n\nexports.resolvePlugins = resolvePlugins;\n\nfunction resolveApis(_ref) {\n  var rawConfig = _ref.rawConfig,\n      _ref$configPath = _ref.configPath,\n      configPath = _ref$configPath === void 0 ? '' : _ref$configPath,\n      resolver = _ref.resolver;\n\n  var _a, _b;\n\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var _rawConfig$apis, apis, _rawConfig$lint, lintConfig, resolvedApis, _i, _Object$entries, _Object$entries$_i, apiName, apiContent, rawLintConfig, apiLint;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _rawConfig$apis = rawConfig.apis, apis = _rawConfig$apis === void 0 ? {} : _rawConfig$apis, _rawConfig$lint = rawConfig.lint, lintConfig = _rawConfig$lint === void 0 ? {} : _rawConfig$lint;\n            resolvedApis = {};\n            _i = 0, _Object$entries = Object.entries(apis || {});\n\n          case 3:\n            if (!(_i < _Object$entries.length)) {\n              _context2.next = 15;\n              break;\n            }\n\n            _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), apiName = _Object$entries$_i[0], apiContent = _Object$entries$_i[1];\n\n            if (!((_b = (_a = apiContent.lint) === null || _a === void 0 ? void 0 : _a.extends) === null || _b === void 0 ? void 0 : _b.some(utils_2.isNotString))) {\n              _context2.next = 7;\n              break;\n            }\n\n            throw new Error(\"Error configuration format not detected in extends value must contain strings\");\n\n          case 7:\n            rawLintConfig = getMergedLintRawConfig(lintConfig, apiContent.lint);\n            _context2.next = 10;\n            return resolveLint({\n              lintConfig: rawLintConfig,\n              configPath: configPath,\n              resolver: resolver\n            });\n\n          case 10:\n            apiLint = _context2.sent;\n            resolvedApis[apiName] = Object.assign(Object.assign({}, apiContent), {\n              lint: apiLint\n            });\n\n          case 12:\n            _i++;\n            _context2.next = 3;\n            break;\n\n          case 15:\n            return _context2.abrupt(\"return\", resolvedApis);\n\n          case 16:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\n\nexports.resolveApis = resolveApis;\n\nfunction resolveAndMergeNestedLint(_ref2) {\n  var lintConfig = _ref2.lintConfig,\n      _ref2$configPath = _ref2.configPath,\n      configPath = _ref2$configPath === void 0 ? '' : _ref2$configPath,\n      _ref2$resolver = _ref2.resolver,\n      resolver = _ref2$resolver === void 0 ? new resolve_1.BaseResolver() : _ref2$resolver;\n  var parentConfigPaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var extendPaths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  var _a, _b, _c;\n\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n    var _this = this;\n\n    var plugins, pluginPaths, resolvedConfigPath, extendConfigs, _d, _d$plugins, mergedPlugins, lint;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!parentConfigPaths.includes(configPath)) {\n              _context4.next = 2;\n              break;\n            }\n\n            throw new Error(\"Circular dependency in config file: \\\"\".concat(configPath, \"\\\"\"));\n\n          case 2:\n            plugins = utils_1.getUniquePlugins(resolvePlugins([].concat(_toConsumableArray((lintConfig === null || lintConfig === void 0 ? void 0 : lintConfig.plugins) || []), [builtIn_1.defaultPlugin]), configPath));\n            pluginPaths = (_a = lintConfig === null || lintConfig === void 0 ? void 0 : lintConfig.plugins) === null || _a === void 0 ? void 0 : _a.filter(utils_2.isString).map(function (p) {\n              return path.resolve(path.dirname(configPath), p);\n            });\n            resolvedConfigPath = ref_utils_1.isAbsoluteUrl(configPath) ? configPath : configPath && path.resolve(configPath);\n            _context4.next = 7;\n            return Promise.all(((_b = lintConfig === null || lintConfig === void 0 ? void 0 : lintConfig.extends) === null || _b === void 0 ? void 0 : _b.map(function (presetItem) {\n              return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                var pathItem, extendedLintConfig;\n                return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        if (!(!ref_utils_1.isAbsoluteUrl(presetItem) && !path.extname(presetItem))) {\n                          _context3.next = 2;\n                          break;\n                        }\n\n                        return _context3.abrupt(\"return\", resolvePreset(presetItem, plugins));\n\n                      case 2:\n                        pathItem = ref_utils_1.isAbsoluteUrl(presetItem) ? presetItem : ref_utils_1.isAbsoluteUrl(configPath) ? new URL(presetItem, configPath).href : path.resolve(path.dirname(configPath), presetItem);\n                        _context3.next = 5;\n                        return loadExtendLintConfig(pathItem, resolver);\n\n                      case 5:\n                        extendedLintConfig = _context3.sent;\n                        _context3.next = 8;\n                        return resolveAndMergeNestedLint({\n                          lintConfig: extendedLintConfig,\n                          configPath: pathItem,\n                          resolver: resolver\n                        }, [].concat(_toConsumableArray(parentConfigPaths), [resolvedConfigPath]), extendPaths);\n\n                      case 8:\n                        return _context3.abrupt(\"return\", _context3.sent);\n\n                      case 9:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3);\n              }));\n            })) || []);\n\n          case 7:\n            extendConfigs = _context4.sent;\n            _d = utils_1.mergeExtends([].concat(_toConsumableArray(extendConfigs), [Object.assign(Object.assign({}, lintConfig), {\n              plugins: plugins,\n              extends: undefined,\n              extendPaths: [].concat(_toConsumableArray(parentConfigPaths), [resolvedConfigPath]),\n              pluginPaths: pluginPaths\n            })])), _d$plugins = _d.plugins, mergedPlugins = _d$plugins === void 0 ? [] : _d$plugins, lint = __rest(_d, [\"plugins\"]);\n            return _context4.abrupt(\"return\", Object.assign(Object.assign({}, lint), {\n              extendPaths: (_c = lint.extendPaths) === null || _c === void 0 ? void 0 : _c.filter(function (path) {\n                return path && !ref_utils_1.isAbsoluteUrl(path);\n              }),\n              plugins: utils_1.getUniquePlugins(mergedPlugins),\n              recommendedFallback: lintConfig === null || lintConfig === void 0 ? void 0 : lintConfig.recommendedFallback,\n              doNotResolveExamples: lintConfig === null || lintConfig === void 0 ? void 0 : lintConfig.doNotResolveExamples\n            }));\n\n          case 10:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n}\n\nfunction resolveLint(lintOpts) {\n  var parentConfigPaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var extendPaths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n    var resolvedLint;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return resolveAndMergeNestedLint(lintOpts, parentConfigPaths, extendPaths);\n\n          case 2:\n            resolvedLint = _context5.sent;\n            return _context5.abrupt(\"return\", Object.assign(Object.assign({}, resolvedLint), {\n              rules: resolvedLint.rules && groupLintAssertionRules(resolvedLint.rules)\n            }));\n\n          case 4:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n}\n\nexports.resolveLint = resolveLint;\n\nfunction resolvePreset(presetName, plugins) {\n  var _a;\n\n  var _utils_1$parsePresetN = utils_1.parsePresetName(presetName),\n      pluginId = _utils_1$parsePresetN.pluginId,\n      configName = _utils_1$parsePresetN.configName;\n\n  var plugin = plugins.find(function (p) {\n    return p.id === pluginId;\n  });\n\n  if (!plugin) {\n    throw new Error(\"Invalid config \".concat(colorette_1.red(presetName), \": plugin \").concat(pluginId, \" is not included.\"));\n  }\n\n  var preset = (_a = plugin.configs) === null || _a === void 0 ? void 0 : _a[configName];\n\n  if (!preset) {\n    throw new Error(pluginId ? \"Invalid config \".concat(colorette_1.red(presetName), \": plugin \").concat(pluginId, \" doesn't export config with name \").concat(configName, \".\") : \"Invalid config \".concat(colorette_1.red(presetName), \": there is no such built-in config.\"));\n  }\n\n  return preset;\n}\n\nexports.resolvePreset = resolvePreset;\n\nfunction loadExtendLintConfig(filePath, resolver) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n    var fileSource, rawConfig;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.prev = 0;\n            _context6.next = 3;\n            return resolver.loadExternalRef(filePath);\n\n          case 3:\n            fileSource = _context6.sent;\n            rawConfig = utils_1.transformConfig(utils_2.parseYaml(fileSource.body));\n\n            if (rawConfig.lint) {\n              _context6.next = 7;\n              break;\n            }\n\n            throw new Error(\"Lint configuration format not detected: \\\"\".concat(filePath, \"\\\"\"));\n\n          case 7:\n            return _context6.abrupt(\"return\", rawConfig.lint);\n\n          case 10:\n            _context6.prev = 10;\n            _context6.t0 = _context6[\"catch\"](0);\n            throw new Error(\"Failed to load \\\"\".concat(filePath, \"\\\": \").concat(_context6.t0.message));\n\n          case 13:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6, null, [[0, 10]]);\n  }));\n}\n\nfunction getMergedLintRawConfig(configLint, apiLint) {\n  var resultLint = Object.assign(Object.assign(Object.assign({}, configLint), apiLint), {\n    rules: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.rules), apiLint === null || apiLint === void 0 ? void 0 : apiLint.rules),\n    oas2Rules: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas2Rules), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas2Rules),\n    oas3_0Rules: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas3_0Rules), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas3_0Rules),\n    oas3_1Rules: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas3_1Rules), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas3_1Rules),\n    preprocessors: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.preprocessors), apiLint === null || apiLint === void 0 ? void 0 : apiLint.preprocessors),\n    oas2Preprocessors: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas2Preprocessors), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas2Preprocessors),\n    oas3_0Preprocessors: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas3_0Preprocessors), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas3_0Preprocessors),\n    oas3_1Preprocessors: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas3_1Preprocessors), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas3_1Preprocessors),\n    decorators: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.decorators), apiLint === null || apiLint === void 0 ? void 0 : apiLint.decorators),\n    oas2Decorators: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas2Decorators), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas2Decorators),\n    oas3_0Decorators: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas3_0Decorators), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas3_0Decorators),\n    oas3_1Decorators: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas3_1Decorators), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas3_1Decorators),\n    recommendedFallback: (apiLint === null || apiLint === void 0 ? void 0 : apiLint.extends) ? false : configLint.recommendedFallback\n  });\n  return resultLint;\n}\n\nfunction groupLintAssertionRules(rules) {\n  if (!rules) {\n    return rules;\n  } // Create a new record to avoid mutating original\n\n\n  var transformedRules = {}; // Collect assertion rules\n\n  var assertions = [];\n\n  for (var _i2 = 0, _Object$entries2 = Object.entries(rules); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n        ruleKey = _Object$entries2$_i[0],\n        rule = _Object$entries2$_i[1];\n\n    if (ruleKey.startsWith('assert/') && typeof rule === 'object' && rule !== null) {\n      var assertion = rule;\n      assertions.push(Object.assign(Object.assign({}, assertion), {\n        assertionId: ruleKey.replace('assert/', '')\n      }));\n    } else {\n      // If it's not an assertion, keep it as is\n      transformedRules[ruleKey] = rule;\n    }\n  }\n\n  if (assertions.length > 0) {\n    transformedRules.assertions = assertions;\n  }\n\n  return transformedRules;\n}","map":null,"metadata":{},"sourceType":"script"}