{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeVisitors = void 0;\n\nfunction normalizeVisitors(visitorsConfig, types) {\n  var normalizedVisitors = {};\n  normalizedVisitors.any = {\n    enter: [],\n    leave: []\n  };\n\n  for (var _i = 0, _Object$keys = Object.keys(types); _i < _Object$keys.length; _i++) {\n    var typeName = _Object$keys[_i];\n    normalizedVisitors[typeName] = {\n      enter: [],\n      leave: []\n    };\n  }\n\n  normalizedVisitors.ref = {\n    enter: [],\n    leave: []\n  };\n\n  var _iterator = _createForOfIteratorHelper(visitorsConfig),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          ruleId = _step$value.ruleId,\n          severity = _step$value.severity,\n          visitor = _step$value.visitor;\n      normalizeVisitorLevel({\n        ruleId: ruleId,\n        severity: severity\n      }, visitor, null);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(normalizedVisitors); _i2 < _Object$keys2.length; _i2++) {\n    var v = _Object$keys2[_i2];\n    normalizedVisitors[v].enter.sort(function (a, b) {\n      return b.depth - a.depth;\n    });\n    normalizedVisitors[v].leave.sort(function (a, b) {\n      return a.depth - b.depth;\n    });\n  }\n\n  return normalizedVisitors;\n\n  function addWeakNodes(ruleConf, from, to, parentContext) {\n    var stack = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    if (stack.includes(from)) return;\n    stack = [].concat(_toConsumableArray(stack), [from]);\n    var possibleChildren = new Set();\n\n    for (var _i3 = 0, _Object$values = Object.values(from.properties); _i3 < _Object$values.length; _i3++) {\n      var type = _Object$values[_i3];\n\n      if (type === to) {\n        addWeakFromStack(ruleConf, stack);\n        continue;\n      }\n\n      if (typeof type === 'object' && type !== null && type.name) {\n        possibleChildren.add(type);\n      }\n    }\n\n    if (from.additionalProperties && typeof from.additionalProperties !== 'function') {\n      if (from.additionalProperties === to) {\n        addWeakFromStack(ruleConf, stack);\n      } else if (from.additionalProperties.name !== undefined) {\n        possibleChildren.add(from.additionalProperties);\n      }\n    }\n\n    if (from.items) {\n      if (from.items === to) {\n        addWeakFromStack(ruleConf, stack);\n      } else if (from.items.name !== undefined) {\n        possibleChildren.add(from.items);\n      }\n    }\n\n    for (var _i4 = 0, _Array$from = Array.from(possibleChildren.values()); _i4 < _Array$from.length; _i4++) {\n      var fromType = _Array$from[_i4];\n      addWeakNodes(ruleConf, fromType, to, parentContext, stack);\n    }\n\n    function addWeakFromStack(ruleConf, stack) {\n      var _iterator2 = _createForOfIteratorHelper(stack.slice(1)),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var interType = _step2.value;\n          normalizedVisitors[interType.name] = normalizedVisitors[interType.name] || {\n            enter: [],\n            leave: []\n          };\n          normalizedVisitors[interType.name].enter.push(Object.assign(Object.assign({}, ruleConf), {\n            visit: function visit() {\n              return undefined;\n            },\n            depth: 0,\n            context: {\n              isSkippedLevel: true,\n              seen: new Set(),\n              parent: parentContext\n            }\n          }));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }\n\n  function normalizeVisitorLevel(ruleConf, visitor, parentContext) {\n    var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var visitorKeys = Object.keys(types);\n\n    if (depth === 0) {\n      visitorKeys.push('any');\n      visitorKeys.push('ref');\n    } else {\n      if (visitor.any) {\n        throw new Error('any() is allowed only on top level');\n      }\n\n      if (visitor.ref) {\n        throw new Error('ref() is allowed only on top level');\n      }\n    }\n\n    for (var _i5 = 0, _visitorKeys = visitorKeys; _i5 < _visitorKeys.length; _i5++) {\n      var _typeName = _visitorKeys[_i5];\n      var typeVisitor = visitor[_typeName];\n      var normalizedTypeVisitor = normalizedVisitors[_typeName];\n      if (!typeVisitor) continue;\n      var visitorEnter = void 0;\n      var visitorLeave = void 0;\n      var visitorSkip = void 0;\n      var isObjectVisitor = typeof typeVisitor === 'object';\n\n      if (_typeName === 'ref' && isObjectVisitor && typeVisitor.skip) {\n        throw new Error('ref() visitor does not support skip');\n      }\n\n      if (typeof typeVisitor === 'function') {\n        visitorEnter = typeVisitor;\n      } else if (isObjectVisitor) {\n        visitorEnter = typeVisitor.enter;\n        visitorLeave = typeVisitor.leave;\n        visitorSkip = typeVisitor.skip;\n      }\n\n      var context = {\n        activatedOn: null,\n        type: types[_typeName],\n        parent: parentContext,\n        isSkippedLevel: false\n      };\n\n      if (typeof typeVisitor === 'object') {\n        normalizeVisitorLevel(ruleConf, typeVisitor, context, depth + 1);\n      }\n\n      if (parentContext) {\n        addWeakNodes(ruleConf, parentContext.type, types[_typeName], parentContext);\n      }\n\n      if (visitorEnter || isObjectVisitor) {\n        if (visitorEnter && typeof visitorEnter !== 'function') {\n          throw new Error('DEV: should be function');\n        }\n\n        normalizedTypeVisitor.enter.push(Object.assign(Object.assign({}, ruleConf), {\n          visit: visitorEnter || function () {\n            return undefined;\n          },\n          skip: visitorSkip,\n          depth: depth,\n          context: context\n        }));\n      }\n\n      if (visitorLeave) {\n        if (typeof visitorLeave !== 'function') {\n          throw new Error('DEV: should be function');\n        }\n\n        normalizedTypeVisitor.leave.push(Object.assign(Object.assign({}, ruleConf), {\n          visit: visitorLeave,\n          depth: depth,\n          context: context\n        }));\n      }\n    }\n  }\n}\n\nexports.normalizeVisitors = normalizeVisitors;","map":null,"metadata":{},"sourceType":"script"}