{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params\n    } = _ref;\n    return codegen_1.str`must match \"${params.ifClause}\" schema`;\n  },\n  params: _ref2 => {\n    let {\n      params\n    } = _ref2;\n    return codegen_1._`{failingKeyword: ${params.ifClause}}`;\n  }\n};\nconst def = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      parentSchema,\n      it\n    } = cxt;\n\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      util_1.checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored');\n    }\n\n    const hasThen = hasSchema(it, \"then\");\n    const hasElse = hasSchema(it, \"else\");\n    if (!hasThen && !hasElse) return;\n    const valid = gen.let(\"valid\", true);\n    const schValid = gen.name(\"_valid\");\n    validateIf();\n    cxt.reset();\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\");\n      cxt.setParams({\n        ifClause\n      });\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"));\n    } else {\n      gen.if(codegen_1.not(schValid), validateClause(\"else\"));\n    }\n\n    cxt.pass(valid, () => cxt.error(true));\n\n    function validateIf() {\n      const schCxt = cxt.subschema({\n        keyword: \"if\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false\n      }, schValid);\n      cxt.mergeEvaluated(schCxt);\n    }\n\n    function validateClause(keyword, ifClause) {\n      return () => {\n        const schCxt = cxt.subschema({\n          keyword\n        }, schValid);\n        gen.assign(valid, schValid);\n        cxt.mergeValidEvaluated(schCxt, valid);\n        if (ifClause) gen.assign(ifClause, codegen_1._`${keyword}`);else cxt.setParams({\n          ifClause: keyword\n        });\n      };\n    }\n  }\n\n};\n\nfunction hasSchema(it, keyword) {\n  const schema = it.schema[keyword];\n  return schema !== undefined && !util_1.alwaysValidSchema(it, schema);\n}\n\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","codegen_1","ifClause","def","keyword","schemaType","trackErrors","code","cxt","gen","parentSchema","it","then","undefined","else","util_1","hasThen","hasSchema","hasElse","valid","let","schValid","name","validateIf","reset","setParams","if","validateClause","pass","schCxt","subschema","compositeRule","createErrors","allErrors","mergeEvaluated","assign","mergeValidEvaluated","schema","exports"],"sources":["C:\\Users\\giato\\Downloads\\Workspace\\.Net\\api\\doctor-management-fe\\node_modules\\@redocly\\ajv\\lib\\vocabularies\\applicator\\if.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}