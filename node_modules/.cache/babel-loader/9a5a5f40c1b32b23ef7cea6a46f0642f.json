{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/giato/Downloads/Workspace/.Net/api/doctor-management-fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\giato\\\\Downloads\\\\Workspace\\\\.Net\\\\api\\\\doctor-management-fe\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assignExisting = exports.isNotString = exports.isString = exports.isNotEmptyObject = exports.slash = exports.isPathParameter = exports.readFileAsStringSync = exports.isSingular = exports.validateMimeTypeOAS3 = exports.validateMimeType = exports.splitCamelCaseIntoWords = exports.omitObjectProps = exports.pickObjectProps = exports.readFileFromUrl = exports.isEmptyArray = exports.isEmptyObject = exports.isPlainObject = exports.notUndefined = exports.loadYaml = exports.popStack = exports.pushStack = exports.stringifyYaml = exports.parseYaml = void 0;\n\nvar fs = require(\"fs\");\n\nvar minimatch = require(\"minimatch\");\n\nvar node_fetch_1 = require(\"node-fetch\");\n\nvar pluralize = require(\"pluralize\");\n\nvar js_yaml_1 = require(\"./js-yaml\");\n\nvar config_1 = require(\"./config\");\n\nvar js_yaml_2 = require(\"./js-yaml\");\n\nObject.defineProperty(exports, \"parseYaml\", {\n  enumerable: true,\n  get: function get() {\n    return js_yaml_2.parseYaml;\n  }\n});\nObject.defineProperty(exports, \"stringifyYaml\", {\n  enumerable: true,\n  get: function get() {\n    return js_yaml_2.stringifyYaml;\n  }\n});\n\nfunction pushStack(head, value) {\n  return {\n    prev: head,\n    value: value\n  };\n}\n\nexports.pushStack = pushStack;\n\nfunction popStack(head) {\n  var _a;\n\n  return (_a = head === null || head === void 0 ? void 0 : head.prev) !== null && _a !== void 0 ? _a : null;\n}\n\nexports.popStack = popStack;\n\nfunction loadYaml(filename) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var contents;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fs.promises.readFile(filename, 'utf-8');\n\n          case 2:\n            contents = _context.sent;\n            return _context.abrupt(\"return\", js_yaml_1.parseYaml(contents));\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.loadYaml = loadYaml;\n\nfunction notUndefined(x) {\n  return x !== undefined;\n}\n\nexports.notUndefined = notUndefined;\n\nfunction isPlainObject(value) {\n  return value !== null && typeof value === 'object' && !Array.isArray(value);\n}\n\nexports.isPlainObject = isPlainObject;\n\nfunction isEmptyObject(value) {\n  return isPlainObject(value) && Object.keys(value).length === 0;\n}\n\nexports.isEmptyObject = isEmptyObject;\n\nfunction isEmptyArray(value) {\n  return Array.isArray(value) && value.length === 0;\n}\n\nexports.isEmptyArray = isEmptyArray;\n\nfunction readFileFromUrl(url, config) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var headers, _iterator, _step, header, req;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            headers = {};\n            _iterator = _createForOfIteratorHelper(config.headers);\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                header = _step.value;\n\n                if (match(url, header.matches)) {\n                  headers[header.name] = header.envVariable !== undefined ? config_1.env[header.envVariable] || '' : header.value;\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            _context2.next = 5;\n            return (config.customFetch || node_fetch_1.default)(url, {\n              headers: headers\n            });\n\n          case 5:\n            req = _context2.sent;\n\n            if (req.ok) {\n              _context2.next = 8;\n              break;\n            }\n\n            throw new Error(\"Failed to load \".concat(url, \": \").concat(req.status, \" \").concat(req.statusText));\n\n          case 8:\n            _context2.next = 10;\n            return req.text();\n\n          case 10:\n            _context2.t0 = _context2.sent;\n            _context2.t1 = req.headers.get('content-type');\n            return _context2.abrupt(\"return\", {\n              body: _context2.t0,\n              mimeType: _context2.t1\n            });\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\n\nexports.readFileFromUrl = readFileFromUrl;\n\nfunction match(url, pattern) {\n  if (!pattern.match(/^https?:\\/\\//)) {\n    // if pattern doesn't specify protocol directly, do not match against it\n    url = url.replace(/^https?:\\/\\//, '');\n  }\n\n  return minimatch(url, pattern);\n}\n\nfunction pickObjectProps(object, keys) {\n  return Object.fromEntries(keys.filter(function (key) {\n    return key in object;\n  }).map(function (key) {\n    return [key, object[key]];\n  }));\n}\n\nexports.pickObjectProps = pickObjectProps;\n\nfunction omitObjectProps(object, keys) {\n  return Object.fromEntries(Object.entries(object).filter(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 1),\n        key = _ref2[0];\n\n    return !keys.includes(key);\n  }));\n}\n\nexports.omitObjectProps = omitObjectProps;\n\nfunction splitCamelCaseIntoWords(str) {\n  var camel = str.split(/(?:[-._])|([A-Z][a-z]+)/).filter(Boolean).map(function (item) {\n    return item.toLocaleLowerCase();\n  });\n  var caps = str.split(/([A-Z]{2,})/).filter(function (e) {\n    return e && e === e.toUpperCase();\n  }).map(function (item) {\n    return item.toLocaleLowerCase();\n  });\n  return new Set([].concat(_toConsumableArray(camel), _toConsumableArray(caps)));\n}\n\nexports.splitCamelCaseIntoWords = splitCamelCaseIntoWords;\n\nfunction validateMimeType(_ref3, _ref4, allowedValues) {\n  var type = _ref3.type,\n      value = _ref3.value;\n  var report = _ref4.report,\n      location = _ref4.location;\n  var ruleType = type === 'consumes' ? 'request' : 'response';\n  if (!allowedValues) throw new Error(\"Parameter \\\"allowedValues\\\" is not provided for \\\"\".concat(ruleType, \"-mime-type\\\" rule\"));\n  if (!value[type]) return;\n\n  var _iterator2 = _createForOfIteratorHelper(value[type]),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var mime = _step2.value;\n\n      if (!allowedValues.includes(mime)) {\n        report({\n          message: \"Mime type \\\"\".concat(mime, \"\\\" is not allowed\"),\n          location: location.child(value[type].indexOf(mime)).key()\n        });\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n\nexports.validateMimeType = validateMimeType;\n\nfunction validateMimeTypeOAS3(_ref5, _ref6, allowedValues) {\n  var type = _ref5.type,\n      value = _ref5.value;\n  var report = _ref6.report,\n      location = _ref6.location;\n  var ruleType = type === 'consumes' ? 'request' : 'response';\n  if (!allowedValues) throw new Error(\"Parameter \\\"allowedValues\\\" is not provided for \\\"\".concat(ruleType, \"-mime-type\\\" rule\"));\n  if (!value.content) return;\n\n  for (var _i = 0, _Object$keys = Object.keys(value.content); _i < _Object$keys.length; _i++) {\n    var mime = _Object$keys[_i];\n\n    if (!allowedValues.includes(mime)) {\n      report({\n        message: \"Mime type \\\"\".concat(mime, \"\\\" is not allowed\"),\n        location: location.child('content').child(mime).key()\n      });\n    }\n  }\n}\n\nexports.validateMimeTypeOAS3 = validateMimeTypeOAS3;\n\nfunction isSingular(path) {\n  return pluralize.isSingular(path);\n}\n\nexports.isSingular = isSingular;\n\nfunction readFileAsStringSync(filePath) {\n  return fs.readFileSync(filePath, 'utf-8');\n}\n\nexports.readFileAsStringSync = readFileAsStringSync;\n\nfunction isPathParameter(pathSegment) {\n  return pathSegment.startsWith('{') && pathSegment.endsWith('}');\n}\n\nexports.isPathParameter = isPathParameter;\n/**\n * Convert Windows backslash paths to slash paths: foo\\\\bar âž” foo/bar\n */\n\nfunction slash(path) {\n  var isExtendedLengthPath = /^\\\\\\\\\\?\\\\/.test(path);\n\n  if (isExtendedLengthPath) {\n    return path;\n  }\n\n  return path.replace(/\\\\/g, '/');\n}\n\nexports.slash = slash;\n\nfunction isNotEmptyObject(obj) {\n  return !!obj && Object.keys(obj).length > 0;\n}\n\nexports.isNotEmptyObject = isNotEmptyObject; // TODO: use it everywhere\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nexports.isString = isString;\n\nfunction isNotString(value) {\n  return !isString(value);\n}\n\nexports.isNotString = isNotString;\n\nfunction assignExisting(target, obj) {\n  for (var _i2 = 0, _Object$keys2 = Object.keys(obj); _i2 < _Object$keys2.length; _i2++) {\n    var k = _Object$keys2[_i2];\n\n    if (target.hasOwnProperty(k)) {\n      target[k] = obj[k];\n    }\n  }\n}\n\nexports.assignExisting = assignExisting;","map":null,"metadata":{},"sourceType":"script"}